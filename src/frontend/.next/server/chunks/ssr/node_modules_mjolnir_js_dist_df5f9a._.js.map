{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"input-consts.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/input/input-consts.ts"],"sourcesContent":["export const MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nexport const COMPUTE_INTERVAL = 25;\n\nexport enum InputEvent {\n  Start = 1,\n  Move = 2,\n  End = 4,\n  Cancel = 8\n}\n\nexport enum InputDirection {\n  None = 0,\n  Left = 1,\n  Right = 2,\n  Up = 4,\n  Down = 8,\n  Horizontal = 3,\n  Vertical = 12,\n  All = 15\n}\n"],"names":[],"mappings":";;;;;;AAAO,MAAM,YAAY,GAAG,uCAAuC,CAAC;AAE7D,MAAM,gBAAgB,GAAG,EAAE,CAAC;AAEnC,IAAY,UAKX;AALD,CAAA,SAAY,UAAU;IACpB,UAAA,CAAA,UAAA,CAAA,QAAA,GAAA,EAAA,GAAA,OAAS,CAAA;IACT,UAAA,CAAA,UAAA,CAAA,OAAA,GAAA,EAAA,GAAA,MAAQ,CAAA;IACR,UAAA,CAAA,UAAA,CAAA,MAAA,GAAA,EAAA,GAAA,KAAO,CAAA;IACP,UAAA,CAAA,UAAA,CAAA,SAAA,GAAA,EAAA,GAAA,QAAU,CAAA;AACZ,CAAC,EALW,UAAU,IAAA,CAAV,UAAU,GAAA,CAAA,CAAA,GAKrB;AAED,IAAY,cASX;AATD,CAAA,SAAY,cAAc;IACxB,cAAA,CAAA,cAAA,CAAA,OAAA,GAAA,EAAA,GAAA,MAAQ,CAAA;IACR,cAAA,CAAA,cAAA,CAAA,OAAA,GAAA,EAAA,GAAA,MAAQ,CAAA;IACR,cAAA,CAAA,cAAA,CAAA,QAAA,GAAA,EAAA,GAAA,OAAS,CAAA;IACT,cAAA,CAAA,cAAA,CAAA,KAAA,GAAA,EAAA,GAAA,IAAM,CAAA;IACN,cAAA,CAAA,cAAA,CAAA,OAAA,GAAA,EAAA,GAAA,MAAQ,CAAA;IACR,cAAA,CAAA,cAAA,CAAA,aAAA,GAAA,EAAA,GAAA,YAAc,CAAA;IACd,cAAA,CAAA,cAAA,CAAA,WAAA,GAAA,GAAA,GAAA,UAAa,CAAA;IACb,cAAA,CAAA,cAAA,CAAA,MAAA,GAAA,GAAA,GAAA,KAAQ,CAAA;AACV,CAAC,EATW,cAAc,IAAA,CAAd,cAAc,GAAA,CAAA,CAAA,GASzB","ignoreList":[0]}},
    {"offset": {"line": 33, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"file":"recognizer-state.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/recognizer/recognizer-state.ts"],"sourcesContent":["export enum RecognizerState {\n  Possible = 1,\n  Began = 2,\n  Changed = 4,\n  Ended = 8,\n  Recognized = 8, // eslint-disable-line\n  Cancelled = 16,\n  Failed = 32\n}\n"],"names":[],"mappings":";;;AAAA,IAAY,eAQX;AARD,CAAA,SAAY,eAAe;IACzB,eAAA,CAAA,eAAA,CAAA,WAAA,GAAA,EAAA,GAAA,UAAY,CAAA;IACZ,eAAA,CAAA,eAAA,CAAA,QAAA,GAAA,EAAA,GAAA,OAAS,CAAA;IACT,eAAA,CAAA,eAAA,CAAA,UAAA,GAAA,EAAA,GAAA,SAAW,CAAA;IACX,eAAA,CAAA,eAAA,CAAA,QAAA,GAAA,EAAA,GAAA,OAAS,CAAA;IACT,eAAA,CAAA,eAAA,CAAA,aAAA,GAAA,EAAA,GAAA,YAAc,CAAA;IACd,eAAA,CAAA,eAAA,CAAA,YAAA,GAAA,GAAA,GAAA,WAAc,CAAA;IACd,eAAA,CAAA,eAAA,CAAA,SAAA,GAAA,GAAA,GAAA,QAAW,CAAA;AACb,CAAC,EARW,eAAe,IAAA,CAAf,eAAe,GAAA,CAAA,CAAA,GAQ1B","ignoreList":[0]}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"file":"touchaction-Consts.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/touchaction/touchaction-Consts.ts"],"sourcesContent":["// magical touchAction value\nexport const TOUCH_ACTION_COMPUTE = 'compute';\nexport const TOUCH_ACTION_AUTO = 'auto';\nexport const TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nexport const TOUCH_ACTION_NONE = 'none';\nexport const TOUCH_ACTION_PAN_X = 'pan-x';\nexport const TOUCH_ACTION_PAN_Y = 'pan-y';\n"],"names":[],"mappings":"AAAA,4BAA4B;;;;;;;;;AACrB,MAAM,oBAAoB,GAAG,SAAS,CAAC;AACvC,MAAM,iBAAiB,GAAG,MAAM,CAAC;AACjC,MAAM,yBAAyB,GAAG,cAAc,CAAC,CAAC,kBAAkB;AACpE,MAAM,iBAAiB,GAAG,MAAM,CAAC;AACjC,MAAM,kBAAkB,GAAG,OAAO,CAAC;AACnC,MAAM,kBAAkB,GAAG,OAAO,CAAC","ignoreList":[0]}},
    {"offset": {"line": 73, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 79, "column": 0}, "map": {"version":3,"file":"clean-touch-actions.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/touchaction/clean-touch-actions.ts"],"sourcesContent":["import {\n  TOUCH_ACTION_NONE,\n  TOUCH_ACTION_PAN_X,\n  TOUCH_ACTION_PAN_Y,\n  TOUCH_ACTION_MANIPULATION,\n  TOUCH_ACTION_AUTO\n} from './touchaction-Consts';\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @returns valid touchAction\n */\nexport default function cleanTouchActions(actions: string): string {\n  // none\n  if (actions.includes(TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  const hasPanX = actions.includes(TOUCH_ACTION_PAN_X);\n  const hasPanY = actions.includes(TOUCH_ACTION_PAN_Y);\n\n  // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  // pan-x OR pan-y\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  }\n\n  // manipulation\n  if (actions.includes(TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n\n  return TOUCH_ACTION_AUTO;\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EACL,iBAAiB,EACjB,kBAAkB,EAClB,kBAAkB,EAClB,yBAAyB,EACzB,iBAAiB,EAClB,gCAA6B;;AAMhB,SAAU,iBAAiB,CAAC,OAAe;IACvD,OAAO;IACP,IAAI,OAAO,CAAC,QAAQ,2LAAC,oBAAiB,CAAC,EAAE,CAAC;QACxC,iMAAO,oBAAiB,CAAC;IAC3B,CAAC;IAED,MAAM,OAAO,GAAG,OAAO,CAAC,QAAQ,2LAAC,qBAAkB,CAAC,CAAC;IACrD,MAAM,OAAO,GAAG,OAAO,CAAC,QAAQ,2LAAC,qBAAkB,CAAC,CAAC;IAErD,yDAAyD;IACzD,qEAAqE;IACrE,qEAAqE;IACrE,oEAAoE;IACpE,IAAI,OAAO,IAAI,OAAO,EAAE,CAAC;QACvB,iMAAO,oBAAiB,CAAC;IAC3B,CAAC;IAED,iBAAiB;IACjB,IAAI,OAAO,IAAI,OAAO,EAAE,CAAC;QACvB,OAAO,OAAO,CAAC,CAAC,2LAAC,qBAAkB,CAAC,CAAC,2LAAC,qBAAkB,CAAC;IAC3D,CAAC;IAED,eAAe;IACf,IAAI,OAAO,CAAC,QAAQ,2LAAC,4BAAyB,CAAC,EAAE,CAAC;QAChD,iMAAO,4BAAyB,CAAC;IACnC,CAAC;IAED,iMAAO,oBAAiB,CAAC;AAC3B,CAAC","ignoreList":[0]}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 114, "column": 0}, "map": {"version":3,"file":"touchaction.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/touchaction/touchaction.ts"],"sourcesContent":["import {TOUCH_ACTION_COMPUTE} from './touchaction-Consts';\nimport cleanTouchActions from './clean-touch-actions';\n\nimport type {Manager} from '../manager';\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n */\nexport class TouchAction {\n  manager: Manager;\n  actions: string = '';\n\n  constructor(manager: Manager, value: string) {\n    this.manager = manager;\n    this.set(value);\n  }\n\n  /**\n   * set the touchAction value on the element or enable the polyfill\n   */\n  set(value: string) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n\n    if (this.manager.element) {\n      this.manager.element.style.touchAction = value;\n      this.actions = value;\n    }\n  }\n\n  /**\n   * just re-set the touchAction value\n   */\n  update() {\n    this.set(this.manager.options.touchAction);\n  }\n\n  /**\n   * compute the value for the touchAction property based on the recognizer's settings\n   */\n  compute(): string {\n    let actions: string[] = [];\n    for (const recognizer of this.manager.recognizers) {\n      if (recognizer.options.enable) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    }\n    return cleanTouchActions(actions.join(' '));\n  }\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAC,oBAAoB,EAAC,gCAA6B;AAC1D,OAAO,iBAAiB,iCAA8B;;;AAQhD,MAAO,WAAW;IAItB,YAAY,OAAgB,EAAE,KAAa,CAAA;QAF3C,IAAA,CAAA,OAAO,GAAW,EAAE,CAAC;QAGnB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IAClB,CAAC;IAED;;OAEG,CACH,GAAG,CAAC,KAAa,EAAA;QACf,kDAAkD;QAClD,IAAI,KAAK,+LAAK,uBAAoB,EAAE,CAAC;YACnC,KAAK,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;QACzB,CAAC;QAED,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;YACzB,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,WAAW,GAAG,KAAK,CAAC;YAC/C,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QACvB,CAAC;IACH,CAAC;IAED;;OAEG,CACH,MAAM,GAAA;QACJ,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;IAC7C,CAAC;IAED;;OAEG,CACH,OAAO,GAAA;QACL,IAAI,OAAO,GAAa,EAAE,CAAC;QAC3B,KAAK,MAAM,UAAU,IAAI,IAAI,CAAC,OAAO,CAAC,WAAW,CAAE,CAAC;YAClD,IAAI,UAAU,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;gBAC9B,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,cAAc,EAAE,CAAC,CAAC;YACxD,CAAC;QACH,CAAC;QACD,yMAAO,UAAA,AAAiB,EAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;IAC9C,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 162, "column": 0}, "map": {"version":3,"file":"split-str.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/utils/split-str.ts"],"sourcesContent":["/**\n * split string on whitespace\n * @returns {Array} words\n */\nexport function splitStr(str: string): string[] {\n  return str.trim().split(/\\s+/g);\n}\n"],"names":[],"mappings":"AAAA;;;GAGG;;;AACG,SAAU,QAAQ,CAAC,GAAW;IAClC,OAAO,GAAG,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;AAClC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 171, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 177, "column": 0}, "map": {"version":3,"file":"event-listeners.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/utils/event-listeners.ts"],"sourcesContent":["import {splitStr} from './split-str';\n\n/**\n * addEventListener with multiple events at once\n */\nexport function addEventListeners(\n  target: EventTarget | null,\n  types: string,\n  handler: EventListener\n) {\n  if (!target) {\n    return;\n  }\n  for (const type of splitStr(types)) {\n    target.addEventListener(type, handler, false);\n  }\n}\n\n/**\n * removeEventListener with multiple events at once\n */\nexport function removeEventListeners(\n  target: EventTarget | null,\n  types: string,\n  handler: EventListener\n) {\n  if (!target) {\n    return;\n  }\n  for (const type of splitStr(types)) {\n    target.removeEventListener(type, handler, false);\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,EAAC,QAAQ,EAAC,uBAAoB;;AAK/B,SAAU,iBAAiB,CAC/B,MAA0B,EAC1B,KAAa,EACb,OAAsB;IAEtB,IAAI,CAAC,MAAM,EAAE,CAAC;QACZ,OAAO;IACT,CAAC;IACD,KAAK,MAAM,IAAI,IAAI,0LAAA,AAAQ,EAAC,KAAK,CAAC,CAAE,CAAC;QACnC,MAAM,CAAC,gBAAgB,CAAC,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;IAChD,CAAC;AACH,CAAC;AAKK,SAAU,oBAAoB,CAClC,MAA0B,EAC1B,KAAa,EACb,OAAsB;IAEtB,IAAI,CAAC,MAAM,EAAE,CAAC;QACZ,OAAO;IACT,CAAC;IACD,KAAK,MAAM,IAAI,mLAAI,WAAA,AAAQ,EAAC,KAAK,CAAC,CAAE,CAAC;QACnC,MAAM,CAAC,mBAAmB,CAAC,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;IACnD,CAAC;AACH,CAAC","ignoreList":[0]}},
    {"offset": {"line": 199, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 205, "column": 0}, "map": {"version":3,"file":"get-window-for-element.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/utils/get-window-for-element.ts"],"sourcesContent":["/**\n * get the window object of an element\n */\nexport function getWindowForElement(element: HTMLElement): Window | null {\n  const doc = element.ownerDocument || (element as unknown as Document);\n  return doc.defaultView;\n}\n"],"names":[],"mappings":"AAAA;;GAEG;;;AACG,SAAU,mBAAmB,CAAC,OAAoB;IACtD,MAAM,GAAG,GAAG,OAAO,CAAC,aAAa,IAAK,OAA+B,CAAC;IACtE,OAAO,GAAG,CAAC,WAAW,CAAC;AACzB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 220, "column": 0}, "map": {"version":3,"file":"has-parent.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/utils/has-parent.ts"],"sourcesContent":["/**\n * find if a node is in the given parent\n */\nexport default function hasParent(node: HTMLElement, parent: HTMLElement): boolean {\n  let ancestor: Node | null = node;\n  while (ancestor) {\n    if (ancestor === parent) {\n      return true;\n    }\n    ancestor = ancestor.parentNode;\n  }\n  return false;\n}\n"],"names":[],"mappings":"AAAA;;GAEG;;;AACW,SAAU,SAAS,CAAC,IAAiB,EAAE,MAAmB;IACtE,IAAI,QAAQ,GAAgB,IAAI,CAAC;IACjC,MAAO,QAAQ,CAAE,CAAC;QAChB,IAAI,QAAQ,KAAK,MAAM,EAAE,CAAC;YACxB,OAAO,IAAI,CAAC;QACd,CAAC;QACD,QAAQ,GAAG,QAAQ,CAAC,UAAU,CAAC;IACjC,CAAC;IACD,OAAO,KAAK,CAAC;AACf,CAAC","ignoreList":[0]}},
    {"offset": {"line": 235, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"file":"get-center.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/input/get-center.ts"],"sourcesContent":["import type {Point, PointerEventLike} from './types';\n\n/**\n * get the center of all the pointers\n */\nexport function getCenter(pointers: PointerEventLike[]): Point {\n  const pointersLength = pointers.length;\n\n  // no need to loop when only one touch\n  if (pointersLength === 1) {\n    return {\n      x: Math.round(pointers[0].clientX),\n      y: Math.round(pointers[0].clientY)\n    };\n  }\n\n  let x = 0;\n  let y = 0;\n  let i = 0;\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: Math.round(x / pointersLength),\n    y: Math.round(y / pointersLength)\n  };\n}\n"],"names":[],"mappings":"AAEA;;GAEG;;;AACG,SAAU,SAAS,CAAC,QAA4B;IACpD,MAAM,cAAc,GAAG,QAAQ,CAAC,MAAM,CAAC;IAEvC,sCAAsC;IACtC,IAAI,cAAc,KAAK,CAAC,EAAE,CAAC;QACzB,OAAO;YACL,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;YAClC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;SACnC,CAAC;IACJ,CAAC;IAED,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,MAAO,CAAC,GAAG,cAAc,CAAE,CAAC;QAC1B,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;QACzB,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;QACzB,CAAC,EAAE,CAAC;IACN,CAAC;IAED,OAAO;QACL,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,cAAc,CAAC;QACjC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,cAAc,CAAC;KAClC,CAAC;AACJ,CAAC","ignoreList":[0]}},
    {"offset": {"line": 268, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 274, "column": 0}, "map": {"version":3,"file":"simple-clone-input-data.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/input/simple-clone-input-data.ts"],"sourcesContent":["import {getCenter} from './get-center';\nimport type {RawInput, PointerEventLike, SimpleInput} from './types';\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n */\nexport function simpleCloneInputData(input: RawInput): SimpleInput {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  const pointers: PointerEventLike[] = [];\n  let i = 0;\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: Math.round(input.pointers[i].clientX),\n      clientY: Math.round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: Date.now(),\n    pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAC,SAAS,EAAC,wBAAqB;;AAMjC,SAAU,oBAAoB,CAAC,KAAe;IAClD,iFAAiF;IACjF,MAAM,QAAQ,GAAuB,EAAE,CAAC;IACxC,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,MAAO,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAE,CAAC;QACjC,QAAQ,CAAC,CAAC,CAAC,GAAG;YACZ,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;YAC9C,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;SAC/C,CAAC;QACF,CAAC,EAAE,CAAC;IACN,CAAC;IAED,OAAO;QACL,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE;QACrB,QAAQ;QACR,MAAM,kLAAE,YAAA,AAAS,EAAC,QAAQ,CAAC;QAC3B,MAAM,EAAE,KAAK,CAAC,MAAM;QACpB,MAAM,EAAE,KAAK,CAAC,MAAM;KACrB,CAAC;AACJ,CAAC","ignoreList":[0]}},
    {"offset": {"line": 298, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 304, "column": 0}, "map": {"version":3,"file":"get-distance.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/input/get-distance.ts"],"sourcesContent":["import type {Point, PointerEventLike} from './types';\n\n/**\n * calculate the absolute distance between two points\n * @returns distance\n */\nexport function getPointDistance(p1: Point, p2: Point): number {\n  const x = p2.x - p1.x;\n  const y = p2.y - p1.y;\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * calculate the absolute distance between two pointer events\n * @returns distance\n */\nexport function getEventDistance(p1: PointerEventLike, p2: PointerEventLike): number {\n  const x = p2.clientX - p1.clientX;\n  const y = p2.clientY - p1.clientY;\n  return Math.sqrt(x * x + y * y);\n}\n"],"names":[],"mappings":"AAEA;;;GAGG;;;;AACG,SAAU,gBAAgB,CAAC,EAAS,EAAE,EAAS;IACnD,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;IACtB,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;IACtB,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAClC,CAAC;AAMK,SAAU,gBAAgB,CAAC,EAAoB,EAAE,EAAoB;IACzE,MAAM,CAAC,GAAG,EAAE,CAAC,OAAO,GAAG,EAAE,CAAC,OAAO,CAAC;IAClC,MAAM,CAAC,GAAG,EAAE,CAAC,OAAO,GAAG,EAAE,CAAC,OAAO,CAAC;IAClC,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAClC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 321, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 327, "column": 0}, "map": {"version":3,"file":"get-angle.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/input/get-angle.ts"],"sourcesContent":["import {Point, PointerEventLike} from './types';\n\n/**\n * calculate the angle between two coordinates\n * @returns angle in degrees\n */\nexport function getPointAngle(p1: Point, p2: Point) {\n  const x: number = p2.x - p1.x;\n  const y: number = p2.y - p1.y;\n  return (Math.atan2(y, x) * 180) / Math.PI;\n}\n\n/**\n * calculate the angle between two pointer events\n * @returns angle in degrees\n */\nexport function getEventAngle(p1: PointerEventLike, p2: PointerEventLike) {\n  const x: number = p2.clientX - p1.clientX;\n  const y: number = p2.clientY - p1.clientY;\n  return (Math.atan2(y, x) * 180) / Math.PI;\n}\n"],"names":[],"mappings":"AAEA;;;GAGG;;;;AACG,SAAU,aAAa,CAAC,EAAS,EAAE,EAAS;IAChD,MAAM,CAAC,GAAW,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;IAC9B,MAAM,CAAC,GAAW,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;IAC9B,OAAO,AAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,EAAG,IAAI,CAAC,EAAE,CAAC;AAC5C,CAAC;AAMK,SAAU,aAAa,CAAC,EAAoB,EAAE,EAAoB;IACtE,MAAM,CAAC,GAAW,EAAE,CAAC,OAAO,GAAG,EAAE,CAAC,OAAO,CAAC;IAC1C,MAAM,CAAC,GAAW,EAAE,CAAC,OAAO,GAAG,EAAE,CAAC,OAAO,CAAC;IAC1C,OAAO,AAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,EAAG,IAAI,CAAC,EAAE,CAAC;AAC5C,CAAC","ignoreList":[0]}},
    {"offset": {"line": 344, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"file":"get-direction.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/input/get-direction.ts"],"sourcesContent":["import {InputDirection} from './input-consts';\n\n/**\n * get the direction between two points\n * @returns direction\n */\nexport function getDirection(dx: number, dy: number): InputDirection {\n  if (dx === dy) {\n    return InputDirection.None;\n  }\n\n  if (Math.abs(dx) >= Math.abs(dy)) {\n    return dx < 0 ? InputDirection.Left : InputDirection.Right;\n  }\n  return dy < 0 ? InputDirection.Up : InputDirection.Down;\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAC,cAAc,EAAC,0BAAuB;;AAMxC,SAAU,YAAY,CAAC,EAAU,EAAE,EAAU;IACjD,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC;QACd,qLAAO,iBAAc,CAAC,IAAI,CAAC;IAC7B,CAAC;IAED,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC;QACjC,OAAO,EAAE,GAAG,CAAC,CAAC,CAAC,+KAAC,iBAAc,CAAC,IAAI,CAAC,CAAC,+KAAC,iBAAc,CAAC,KAAK,CAAC;IAC7D,CAAC;IACD,OAAO,EAAE,GAAG,CAAC,CAAC,CAAC,+KAAC,iBAAc,CAAC,EAAE,CAAC,CAAC,+KAAC,iBAAc,CAAC,IAAI,CAAC;AAC1D,CAAC","ignoreList":[0]}},
    {"offset": {"line": 364, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 370, "column": 0}, "map": {"version":3,"file":"get-delta-xy.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/input/get-delta-xy.ts"],"sourcesContent":["import {InputEvent} from './input-consts';\nimport type {RawInput, Session} from './types';\n\n/** Populates input.deltaX, input.deltaY */\nexport function computeDeltaXY(\n  session: Session,\n  input: RawInput\n): {\n  deltaX: number;\n  deltaY: number;\n} {\n  // getCenter is called before computeDeltaXY\n  const center = input.center!;\n  let offset = session.offsetDelta;\n  let prevDelta = session.prevDelta;\n  const prevInput = session.prevInput;\n\n  if (input.eventType === InputEvent.Start || prevInput?.eventType === InputEvent.End) {\n    prevDelta = session.prevDelta = {\n      x: prevInput?.deltaX || 0,\n      y: prevInput?.deltaY || 0\n    };\n\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n\n  return {\n    deltaX: prevDelta!.x + (center.x - offset!.x),\n    deltaY: prevDelta!.y + (center.y - offset!.y)\n  };\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAC,UAAU,EAAC,0BAAuB;;AAIpC,SAAU,cAAc,CAC5B,OAAgB,EAChB,KAAe;IAKf,4CAA4C;IAC5C,MAAM,MAAM,GAAG,KAAK,CAAC,MAAO,CAAC;IAC7B,IAAI,MAAM,GAAG,OAAO,CAAC,WAAW,CAAC;IACjC,IAAI,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;IAClC,MAAM,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;IAEpC,IAAI,KAAK,CAAC,SAAS,mLAAK,aAAU,CAAC,KAAK,IAAI,SAAS,EAAE,SAAS,mLAAK,aAAU,CAAC,GAAG,EAAE,CAAC;QACpF,SAAS,GAAG,OAAO,CAAC,SAAS,GAAG;YAC9B,CAAC,EAAE,SAAS,EAAE,MAAM,IAAI,CAAC;YACzB,CAAC,EAAE,SAAS,EAAE,MAAM,IAAI,CAAC;SAC1B,CAAC;QAEF,MAAM,GAAG,OAAO,CAAC,WAAW,GAAG;YAC7B,CAAC,EAAE,MAAM,CAAC,CAAC;YACX,CAAC,EAAE,MAAM,CAAC,CAAC;SACZ,CAAC;IACJ,CAAC;IAED,OAAO;QACL,MAAM,EAAE,SAAU,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,MAAO,CAAC,CAAC,CAAC;QAC7C,MAAM,EAAE,SAAU,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,MAAO,CAAC,CAAC,CAAC;KAC9C,CAAC;AACJ,CAAC","ignoreList":[0]}},
    {"offset": {"line": 396, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 402, "column": 0}, "map": {"version":3,"file":"get-velocity.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/input/get-velocity.ts"],"sourcesContent":["import type {Vector} from './types';\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n */\nexport function getVelocity(deltaTime: number, x: number, y: number): Vector {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n"],"names":[],"mappings":"AAEA;;GAEG;;;AACG,SAAU,WAAW,CAAC,SAAiB,EAAE,CAAS,EAAE,CAAS;IACjE,OAAO;QACL,CAAC,EAAE,CAAC,GAAG,SAAS,IAAI,CAAC;QACrB,CAAC,EAAE,CAAC,GAAG,SAAS,IAAI,CAAC;KACtB,CAAC;AACJ,CAAC","ignoreList":[0]}},
    {"offset": {"line": 413, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 419, "column": 0}, "map": {"version":3,"file":"get-scale.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/input/get-scale.ts"],"sourcesContent":["import {getEventDistance} from './get-distance';\nimport type {PointerEventLike} from './types';\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n */\nexport function getScale(start: PointerEventLike[], end: PointerEventLike[]): number {\n  return getEventDistance(end[0], end[1]) / getEventDistance(start[0], start[1]);\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAC,gBAAgB,EAAC,0BAAuB;;AAO1C,SAAU,QAAQ,CAAC,KAAyB,EAAE,GAAuB;IACzE,yLAAO,mBAAA,AAAgB,EAAC,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,qLAAG,mBAAA,AAAgB,EAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;AACjF,CAAC","ignoreList":[0]}},
    {"offset": {"line": 427, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 433, "column": 0}, "map": {"version":3,"file":"get-rotation.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/input/get-rotation.ts"],"sourcesContent":["import {getEventAngle} from './get-angle';\nimport {PointerEventLike} from './types';\n\n/**\n * calculate the rotation degrees between two pointer sets\n * @returns rotation in degrees\n */\nexport function getRotation(start: PointerEventLike[], end: PointerEventLike[]): number {\n  return getEventAngle(end[1], end[0]) - getEventAngle(start[1], start[0]);\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAC,aAAa,EAAC,uBAAoB;;AAOpC,SAAU,WAAW,CAAC,KAAyB,EAAE,GAAuB;IAC5E,sLAAO,gBAAA,AAAa,EAAC,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,kLAAG,gBAAA,AAAa,EAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3E,CAAC","ignoreList":[0]}},
    {"offset": {"line": 441, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 447, "column": 0}, "map": {"version":3,"file":"compute-interval-input-data.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/input/compute-interval-input-data.ts"],"sourcesContent":["import {InputEvent, COMPUTE_INTERVAL} from './input-consts';\nimport {getVelocity} from './get-velocity';\nimport {getDirection} from './get-direction';\n\nimport type {Session, HammerInput} from './types';\n\n/**\n * velocity is calculated every x ms\n */\nexport function computeIntervalInputData(session: Session, input: HammerInput) {\n  const last = session.lastInterval || input;\n  const deltaTime = input.timeStamp - last.timeStamp;\n  let velocity;\n  let velocityX;\n  let velocityY;\n  let direction;\n\n  if (\n    input.eventType !== InputEvent.Cancel &&\n    (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)\n  ) {\n    const deltaX = input.deltaX - last.deltaX;\n    const deltaY = input.deltaY - last.deltaY;\n\n    const v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = Math.abs(v.x) > Math.abs(v.y) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAC,UAAU,EAAE,gBAAgB,EAAC,0BAAuB;AAC5D,OAAO,EAAC,WAAW,EAAC,0BAAuB;AAC3C,OAAO,EAAC,YAAY,EAAC,2BAAwB;;;;AAOvC,SAAU,wBAAwB,CAAC,OAAgB,EAAE,KAAkB;IAC3E,MAAM,IAAI,GAAG,OAAO,CAAC,YAAY,IAAI,KAAK,CAAC;IAC3C,MAAM,SAAS,GAAG,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;IACnD,IAAI,QAAQ,CAAC;IACb,IAAI,SAAS,CAAC;IACd,IAAI,SAAS,CAAC;IACd,IAAI,SAAS,CAAC;IAEd,IACE,KAAK,CAAC,SAAS,mLAAK,aAAU,CAAC,MAAM,IACrC,CAAC,SAAS,iLAAG,mBAAgB,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,CAAC,EAC7D,CAAC;QACD,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAC1C,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAE1C,MAAM,CAAC,qLAAG,cAAA,AAAW,EAAC,SAAS,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;QACjD,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;QAChB,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;QAChB,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACrD,SAAS,GAAG,kMAAA,AAAY,EAAC,MAAM,EAAE,MAAM,CAAC,CAAC;QAEzC,OAAO,CAAC,YAAY,GAAG,KAAK,CAAC;IAC/B,CAAC,MAAM,CAAC;QACN,mEAAmE;QACnE,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QACzB,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;QAC3B,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;QAC3B,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;IAC7B,CAAC;IAED,KAAK,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC1B,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC;IAC5B,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC;IAC5B,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC;AAC9B,CAAC","ignoreList":[0]}},
    {"offset": {"line": 484, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 490, "column": 0}, "map": {"version":3,"file":"compute-input-data.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/input/compute-input-data.ts"],"sourcesContent":["import hasParent from '../utils/has-parent';\nimport {simpleCloneInputData} from './simple-clone-input-data';\nimport {getCenter} from './get-center';\nimport {getPointDistance} from './get-distance';\nimport {getPointAngle} from './get-angle';\nimport {getDirection} from './get-direction';\nimport {computeDeltaXY} from './get-delta-xy';\nimport {getVelocity} from './get-velocity';\nimport {getScale} from './get-scale';\nimport {getRotation} from './get-rotation';\nimport {computeIntervalInputData} from './compute-interval-input-data';\n\nimport type {Manager} from '../manager';\nimport type {RawInput, HammerInput} from './types';\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n */\nexport function computeInputData(manager: Manager, input: RawInput): HammerInput {\n  const {session} = manager;\n  const {pointers} = input;\n  const {length: pointersLength} = pointers;\n\n  // store the first input to calculate the distance and direction\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  }\n\n  // to compute scale and rotation we need to store the multiple touches\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  const {firstInput, firstMultiple} = session;\n  const offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n  const center = (input.center = getCenter(pointers));\n  input.timeStamp = Date.now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n  input.angle = getPointAngle(offsetCenter, center);\n  input.distance = getPointDistance(offsetCenter, center);\n\n  const {deltaX, deltaY} = computeDeltaXY(session, input);\n  input.deltaX = deltaX;\n  input.deltaY = deltaY;\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n  const overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity =\n    Math.abs(overallVelocity.x) > Math.abs(overallVelocity.y)\n      ? overallVelocity.x\n      : overallVelocity.y;\n\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n  input.maxPointers = !session.prevInput\n    ? input.pointers.length\n    : input.pointers.length > session.prevInput.maxPointers\n      ? input.pointers.length\n      : session.prevInput.maxPointers;\n\n  // find the correct target\n  let target = manager.element!;\n  if (hasParent(input.srcEvent.target as HTMLElement, target)) {\n    target = input.srcEvent.target as HTMLElement;\n  }\n  input.target = target;\n\n  computeIntervalInputData(session, input as HammerInput);\n\n  // All the optional fields have been populated\n  return input as HammerInput;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 557, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 563, "column": 0}, "map": {"version":3,"file":"input-handler.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/input/input-handler.ts"],"sourcesContent":["import {InputEvent} from './input-consts';\nimport {computeInputData} from './compute-input-data';\n\nimport type {Manager} from '../manager';\nimport type {RawInput} from './types';\n\n/**\n * handle input events\n */\nexport function inputHandler(manager: Manager, eventType: InputEvent, input: RawInput) {\n  const pointersLen = input.pointers.length;\n  const changedPointersLen = input.changedPointers.length;\n  const isFirst = eventType & InputEvent.Start && pointersLen - changedPointersLen === 0;\n  const isFinal =\n    eventType & (InputEvent.End | InputEvent.Cancel) && pointersLen - changedPointersLen === 0;\n\n  input.isFirst = Boolean(isFirst);\n  input.isFinal = Boolean(isFinal);\n\n  if (isFirst) {\n    manager.session = {};\n  }\n\n  // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n  input.eventType = eventType;\n\n  // compute scale, rotation etc\n  const processedInput = computeInputData(manager, input);\n\n  // emit secret event\n  manager.emit('hammer.input', processedInput);\n\n  manager.recognize(processedInput);\n  manager.session.prevInput = processedInput;\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAC,UAAU,EAAC,0BAAuB;AAC1C,OAAO,EAAC,gBAAgB,EAAC,gCAA6B;;;AAQhD,SAAU,YAAY,CAAC,OAAgB,EAAE,SAAqB,EAAE,KAAe;IACnF,MAAM,WAAW,GAAG,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC;IAC1C,MAAM,kBAAkB,GAAG,KAAK,CAAC,eAAe,CAAC,MAAM,CAAC;IACxD,MAAM,OAAO,GAAG,SAAS,gLAAG,cAAU,CAAC,KAAK,IAAI,WAAW,GAAG,kBAAkB,KAAK,CAAC,CAAC;IACvF,MAAM,OAAO,GACX,SAAS,GAAG,+KAAC,aAAU,CAAC,GAAG,iLAAG,aAAU,CAAC,MAAM,CAAC,IAAI,WAAW,GAAG,kBAAkB,KAAK,CAAC,CAAC;IAE7F,KAAK,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;IACjC,KAAK,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;IAEjC,IAAI,OAAO,EAAE,CAAC;QACZ,OAAO,CAAC,OAAO,GAAG,CAAA,CAAE,CAAC;IACvB,CAAC;IAED,wDAAwD;IACxD,0CAA0C;IAC1C,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC;IAE5B,8BAA8B;IAC9B,MAAM,cAAc,8LAAG,mBAAA,AAAgB,EAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IAExD,oBAAoB;IACpB,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE,cAAc,CAAC,CAAC;IAE7C,OAAO,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;IAClC,OAAO,CAAC,OAAO,CAAC,SAAS,GAAG,cAAc,CAAC;AAC7C,CAAC","ignoreList":[0]}},
    {"offset": {"line": 590, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 596, "column": 0}, "map": {"version":3,"file":"input.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/input/input.ts"],"sourcesContent":["import {addEventListeners, removeEventListeners} from '../utils/event-listeners';\nimport {getWindowForElement} from '../utils/get-window-for-element';\nimport {inputHandler} from './input-handler';\n\nimport {InputEvent} from './input-consts';\nimport type {RawInput} from './types';\nimport type {Manager} from '../manager';\n\n/**\n * create new input type manager\n */\nexport abstract class Input {\n  manager: Manager;\n  element: HTMLElement;\n  target: EventTarget;\n\n  evEl: string = '';\n  evWin: string = '';\n  evTarget: string = '';\n\n  constructor(manager: Manager) {\n    this.manager = manager;\n    this.element = manager.element!;\n    this.target = manager.options.inputTarget || manager.element!;\n  }\n\n  /** smaller wrapper around the handler, for the scope and the enabled state of the manager,\n   * so when disabled the input events are completely bypassed.\n   */\n  protected domHandler = (ev: Event) => {\n    if (this.manager.options.enable) {\n      this.handler(ev);\n    }\n  };\n\n  protected callback(eventType: InputEvent, input: RawInput) {\n    inputHandler(this.manager, eventType, input);\n  }\n\n  /**\n   * should handle the inputEvent data and trigger the callback\n   */\n  abstract handler(ev: Event): void;\n\n  // eslint-disable @typescript-eslint/unbound-method\n  /**\n   * bind the events\n   */\n  init() {\n    addEventListeners(this.element, this.evEl, this.domHandler);\n    addEventListeners(this.target, this.evTarget, this.domHandler);\n    addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  }\n\n  /**\n   * unbind the events\n   */\n  destroy() {\n    removeEventListeners(this.element, this.evEl, this.domHandler);\n    removeEventListeners(this.target, this.evTarget, this.domHandler);\n    removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  }\n  // eslint-enable @typescript-eslint/unbound-method\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAC,iBAAiB,EAAE,oBAAoB,EAAC,oCAAiC;AACjF,OAAO,EAAC,mBAAmB,EAAC,2CAAwC;AACpE,OAAO,EAAC,YAAY,EAAC,2BAAwB;;;;AASvC,MAAgB,KAAK;IASzB,YAAY,OAAgB,CAAA;QAJ5B,IAAA,CAAA,IAAI,GAAW,EAAE,CAAC;QAClB,IAAA,CAAA,KAAK,GAAW,EAAE,CAAC;QACnB,IAAA,CAAA,QAAQ,GAAW,EAAE,CAAC;QAQtB;;WAEG,CACO,IAAA,CAAA,UAAU,GAAG,CAAC,EAAS,EAAE,EAAE;YACnC,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;gBAChC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;YACnB,CAAC;QACH,CAAC,CAAC;QAZA,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,OAAQ,CAAC;QAChC,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,WAAW,IAAI,OAAO,CAAC,OAAQ,CAAC;IAChE,CAAC;IAWS,QAAQ,CAAC,SAAqB,EAAE,KAAe,EAAA;2LACvD,eAAA,AAAY,EAAC,IAAI,CAAC,OAAO,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;IAC/C,CAAC;IAOD,mDAAmD;IACnD;;OAEG,CACH,IAAI,GAAA;QACF,yMAAA,AAAiB,EAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;6LAC5D,oBAAA,AAAiB,EAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;6LAC/D,oBAAA,AAAiB,oMAAC,sBAAA,AAAmB,EAAC,IAAI,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;IACpF,CAAC;IAED;;OAEG,CACH,OAAO,GAAA;6LACL,uBAAA,AAAoB,EAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;6LAC/D,uBAAA,AAAoB,EAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;6LAClE,uBAAA,AAAoB,oMAAC,sBAAA,AAAmB,EAAC,IAAI,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;IACvF,CAAC;CAEF","ignoreList":[0]}},
    {"offset": {"line": 640, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 646, "column": 0}, "map": {"version":3,"file":"pointerevent.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/inputs/pointerevent.ts"],"sourcesContent":["import {InputEvent} from '../input/input-consts';\nimport {Input} from '../input/input';\nimport type {Manager} from '../manager';\n\nconst POINTER_INPUT_MAP = {\n  pointerdown: InputEvent.Start,\n  pointermove: InputEvent.Move,\n  pointerup: InputEvent.End,\n  pointercancel: InputEvent.Cancel,\n  pointerout: InputEvent.Cancel\n} as const;\n\nconst POINTER_ELEMENT_EVENTS = 'pointerdown';\nconst POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n/**\n * Pointer events input\n */\nexport class PointerEventInput extends Input {\n  store: PointerEvent[];\n\n  constructor(manager: Manager) {\n    super(manager);\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    this.store = this.manager.session.pointerEvents = [];\n    this.init();\n  }\n\n  /**\n   * handle mouse events\n   */\n  handler(ev: PointerEvent) {\n    const {store} = this;\n    let removePointer = false;\n\n    // @ts-ignore\n    const eventType = POINTER_INPUT_MAP[ev.type];\n    const pointerType = ev.pointerType;\n\n    const isTouch = pointerType === 'touch';\n\n    // get index of the event in the store\n    let storeIndex = store.findIndex((e) => e.pointerId === ev.pointerId);\n\n    // start and mouse must be down\n    if (eventType & InputEvent.Start && (ev.buttons || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (InputEvent.End | InputEvent.Cancel)) {\n      removePointer = true;\n    }\n\n    // it not found, so the pointer hasn't been down (so it's probably a hover)\n    if (storeIndex < 0) {\n      return;\n    }\n\n    // update the event in the store\n    store[storeIndex] = ev;\n\n    this.callback(eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      eventType,\n      pointerType,\n      srcEvent: ev\n    });\n\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  }\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAC,UAAU,EAAC,iCAA8B;AACjD,OAAO,EAAC,KAAK,EAAC,0BAAuB;;;AAGrC,MAAM,iBAAiB,GAAG;IACxB,WAAW,gLAAE,aAAU,CAAC,KAAK;IAC7B,WAAW,gLAAE,aAAU,CAAC,IAAI;IAC5B,SAAS,gLAAE,aAAU,CAAC,GAAG;IACzB,aAAa,gLAAE,aAAU,CAAC,MAAM;IAChC,UAAU,gLAAE,aAAU,CAAC,MAAM;CACrB,CAAC;AAEX,MAAM,sBAAsB,GAAG,aAAa,CAAC;AAC7C,MAAM,qBAAqB,GAAG,qCAAqC,CAAC;AAK9D,MAAO,iBAAkB,6KAAQ,QAAK;IAG1C,YAAY,OAAgB,CAAA;QAC1B,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,sBAAsB,CAAC;QACnC,IAAI,CAAC,KAAK,GAAG,qBAAqB,CAAC;QAEnC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,aAAa,GAAG,EAAE,CAAC;QACrD,IAAI,CAAC,IAAI,EAAE,CAAC;IACd,CAAC;IAED;;OAEG,CACH,OAAO,CAAC,EAAgB,EAAA;QACtB,MAAM,EAAC,KAAK,EAAC,GAAG,IAAI,CAAC;QACrB,IAAI,aAAa,GAAG,KAAK,CAAC;QAE1B,aAAa;QACb,MAAM,SAAS,GAAG,iBAAiB,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;QAC7C,MAAM,WAAW,GAAG,EAAE,CAAC,WAAW,CAAC;QAEnC,MAAM,OAAO,GAAG,WAAW,KAAK,OAAO,CAAC;QAExC,sCAAsC;QACtC,IAAI,UAAU,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,SAAS,KAAK,EAAE,CAAC,SAAS,CAAC,CAAC;QAEtE,+BAA+B;QAC/B,IAAI,SAAS,iLAAG,aAAU,CAAC,KAAK,IAAI,CAAC,EAAE,CAAC,OAAO,IAAI,OAAO,CAAC,EAAE,CAAC;YAC5D,IAAI,UAAU,GAAG,CAAC,EAAE,CAAC;gBACnB,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;gBACf,UAAU,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;YAChC,CAAC;QACH,CAAC,MAAM,IAAI,SAAS,GAAG,+KAAC,aAAU,CAAC,GAAG,iLAAG,aAAU,CAAC,MAAM,CAAC,EAAE,CAAC;YAC5D,aAAa,GAAG,IAAI,CAAC;QACvB,CAAC;QAED,2EAA2E;QAC3E,IAAI,UAAU,GAAG,CAAC,EAAE,CAAC;YACnB,OAAO;QACT,CAAC;QAED,gCAAgC;QAChC,KAAK,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC;QAEvB,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE;YACvB,QAAQ,EAAE,KAAK;YACf,eAAe,EAAE;gBAAC,EAAE;aAAC;YACrB,SAAS;YACT,WAAW;YACX,QAAQ,EAAE,EAAE;SACb,CAAC,CAAC;QAEH,IAAI,aAAa,EAAE,CAAC;YAClB,wBAAwB;YACxB,KAAK,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC;QAC9B,CAAC;IACH,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 711, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 717, "column": 0}, "map": {"version":3,"file":"prefixed.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/utils/prefixed.ts"],"sourcesContent":["const VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n\n/**\n * get the prefixed property\n * @returns prefixed property name\n */\nexport function prefixed(obj: Record<string, any>, property: string): string | undefined {\n  const camelProp = property[0].toUpperCase() + property.slice(1);\n\n  for (const prefix of VENDOR_PREFIXES) {\n    const prop = prefix ? prefix + camelProp : property;\n\n    if (prop in obj) {\n      return prop;\n    }\n  }\n  return undefined;\n}\n"],"names":[],"mappings":";;;AAAA,MAAM,eAAe,GAAG;IAAC,EAAE;IAAE,QAAQ;IAAE,KAAK;IAAE,IAAI;IAAE,IAAI;IAAE,GAAG;CAAC,CAAC;AAMzD,SAAU,QAAQ,CAAC,GAAwB,EAAE,QAAgB;IACjE,MAAM,SAAS,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAEhE,KAAK,MAAM,MAAM,IAAI,eAAe,CAAE,CAAC;QACrC,MAAM,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,QAAQ,CAAC;QAEpD,IAAI,IAAI,IAAI,GAAG,EAAE,CAAC;YAChB,OAAO,IAAI,CAAC;QACd,CAAC;IACH,CAAC;IACD,OAAO,SAAS,CAAC;AACnB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 738, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 744, "column": 0}, "map": {"version":3,"file":"manager.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/manager.ts"],"sourcesContent":["import {TouchAction} from './touchaction/touchaction';\nimport {PointerEventInput} from './inputs/pointerevent';\nimport {splitStr} from './utils/split-str';\nimport {prefixed} from './utils/prefixed';\nimport {RecognizerState} from './recognizer/recognizer-state';\n\nimport type {Input} from './input/input';\nimport type {Recognizer} from './recognizer/recognizer';\nimport type {Session, HammerInput} from './input/types';\n\nconst STOP = 1;\nconst FORCED_STOP = 2;\n\nexport type ManagerOptions = {\n  /**\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @default compute\n   */\n  touchAction?: string;\n\n  /**\n   * @default true\n   */\n  enable?: boolean;\n\n  /**\n   * EXPERIMENTAL FEATURE -- can be removed/changed\n   * Change the parent input target element.\n   * If Null, then it is being set the to main element.\n   * @default null\n   */\n  inputTarget?: null | EventTarget;\n\n  /**\n   * Some CSS properties can be used to improve the working of Hammer.\n   * Add them to this method and they will be set when creating a new Manager.\n   */\n  cssProps?: Partial<CSSStyleDeclaration>;\n};\n\nexport type HammerEvent = HammerInput & {\n  type: string;\n  preventDefault: () => void;\n};\nexport type EventHandler = (event: HammerEvent) => void;\n\nconst defaultOptions: Required<ManagerOptions> = {\n  touchAction: 'compute',\n  enable: true,\n  inputTarget: null,\n  cssProps: {\n    /**\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     */\n    userSelect: 'none',\n    /**\n     * (Webkit) Disable default dragging behavior\n     */\n    // @ts-ignore\n    userDrag: 'none',\n    /**\n     * (iOS only) Disables the default callout shown when you touch and hold a touch target.\n     * When you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     */\n    // @ts-ignore\n    touchCallout: 'none',\n    /**\n     * (iOS only) Sets the color of the highlight that appears over a link while it's being tapped.\n     */\n    // @ts-ignore\n    tapHighlightColor: 'rgba(0,0,0,0)'\n  }\n};\n\n/**\n * Manager\n */\nexport class Manager {\n  options: Required<ManagerOptions>;\n\n  element: HTMLElement | null;\n  touchAction: TouchAction;\n  oldCssProps: {[prop: string]: any};\n  session: Session;\n  recognizers: Recognizer[];\n  input: Input;\n  handlers: {[event: string]: EventHandler[]};\n\n  constructor(element: HTMLElement, options: ManagerOptions) {\n    this.options = {\n      ...defaultOptions,\n      ...options,\n      cssProps: {...defaultOptions.cssProps, ...options.cssProps},\n      inputTarget: options.inputTarget || element\n    };\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = new PointerEventInput(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    this.toggleCssProps(true);\n  }\n\n  /**\n   * set options\n   */\n  set(options: Partial<ManagerOptions>) {\n    Object.assign(this.options, options);\n\n    // Options that need a little more setup\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n    return this;\n  }\n\n  /**\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   */\n  stop(force?: boolean) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  }\n\n  /**\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   */\n  recognize(inputData: HammerInput) {\n    const {session} = this;\n    if (session.stopped) {\n      return;\n    }\n\n    // run the touch-action polyfill\n    if (this.session.prevented) {\n      inputData.srcEvent.preventDefault();\n    }\n\n    let recognizer;\n    const {recognizers} = this;\n\n    // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n    let {curRecognizer} = session;\n\n    // reset when the last recognizer is recognized\n    // or when we're in a new session\n    if (!curRecognizer || (curRecognizer && curRecognizer.state & RecognizerState.Recognized)) {\n      curRecognizer = session.curRecognizer = null;\n    }\n\n    let i = 0;\n    while (i < recognizers.length) {\n      recognizer = recognizers[i];\n\n      // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n      if (\n        session.stopped !== FORCED_STOP && // 1\n        (!curRecognizer ||\n          recognizer === curRecognizer || // 2\n          recognizer.canRecognizeWith(curRecognizer))\n      ) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      }\n\n      // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n      if (\n        !curRecognizer &&\n        recognizer.state & (RecognizerState.Began | RecognizerState.Changed | RecognizerState.Ended)\n      ) {\n        curRecognizer = session.curRecognizer = recognizer;\n      }\n      i++;\n    }\n  }\n\n  /**\n   * get a recognizer by its event name.\n   */\n  get(recognizerName: string): Recognizer | null {\n    const {recognizers} = this;\n    for (let i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizerName) {\n        return recognizers[i];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   */\n  add(recognizer: Recognizer | Recognizer[]) {\n    if (Array.isArray(recognizer)) {\n      for (const item of recognizer) {\n        this.add(item);\n      }\n      return this;\n    }\n\n    // remove existing\n    const existing = this.get(recognizer.options.event);\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n\n    this.touchAction.update();\n    return recognizer;\n  }\n\n  /**\n   * remove a recognizer by name or instance\n   */\n  remove(recognizerOrName: Recognizer | string | (Recognizer | string)[]) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.remove(item);\n      }\n      return this;\n    }\n\n    const recognizer =\n      typeof recognizerOrName === 'string' ? this.get(recognizerOrName) : recognizerOrName;\n\n    // let's make sure this recognizer exists\n    if (recognizer) {\n      const {recognizers} = this;\n      const index = recognizers.indexOf(recognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * bind event\n   */\n  on(events: string, handler: EventHandler) {\n    if (!events || !handler) {\n      return;\n    }\n    const {handlers} = this;\n    for (const event of splitStr(events)) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    }\n  }\n\n  /**\n   * unbind event, leave hander blank to remove all handlers\n   */\n  off(events: string, handler?: EventHandler) {\n    if (!events) {\n      return;\n    }\n\n    const {handlers} = this;\n    for (const event of splitStr(events)) {\n      if (!handler) {\n        delete handlers[event];\n      } else if (handlers[event]) {\n        handlers[event].splice(handlers[event].indexOf(handler), 1);\n      }\n    }\n  }\n\n  /**\n   * emit event to the listeners\n   */\n  emit(event: string, data: HammerInput) {\n    // no handlers, so skip it all\n    const handlers = this.handlers[event] && this.handlers[event].slice();\n    if (!handlers || !handlers.length) {\n      return;\n    }\n\n    const evt = data as HammerEvent;\n    evt.type = event;\n    evt.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n\n    let i = 0;\n    while (i < handlers.length) {\n      handlers[i](evt);\n      i++;\n    }\n  }\n\n  /**\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n  destroy() {\n    this.toggleCssProps(false);\n\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  }\n\n  /**\n   * add/remove the css properties as defined in manager.options.cssProps\n   */\n  private toggleCssProps(add: boolean) {\n    const {element} = this;\n    if (!element) {\n      return;\n    }\n    for (const [name, value] of Object.entries(this.options.cssProps)) {\n      const prop = prefixed(element.style, name) as any;\n      if (add) {\n        this.oldCssProps[prop] = element.style[prop];\n        element.style[prop] = value as any;\n      } else {\n        element.style[prop] = this.oldCssProps[prop] || '';\n      }\n    }\n    if (!add) {\n      this.oldCssProps = {};\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1004, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1010, "column": 0}, "map": {"version":3,"file":"unique-id.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/utils/unique-id.ts"],"sourcesContent":["/**\n * get a unique id\n */\nlet _uniqueId = 1;\nexport function uniqueId(): number {\n  return _uniqueId++;\n}\n"],"names":[],"mappings":"AAAA;;GAEG;;;AACH,IAAI,SAAS,GAAG,CAAC,CAAC;AACZ,SAAU,QAAQ;IACtB,OAAO,SAAS,EAAE,CAAC;AACrB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1019, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1025, "column": 0}, "map": {"version":3,"file":"state-str.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/recognizer/state-str.ts"],"sourcesContent":["import {RecognizerState} from './recognizer-state';\n\n/**\n * get a usable string, used as event postfix\n */\nexport function stateStr(state: RecognizerState) {\n  if (state & RecognizerState.Cancelled) {\n    return 'cancel';\n  } else if (state & RecognizerState.Ended) {\n    return 'end';\n  } else if (state & RecognizerState.Changed) {\n    return 'move';\n  } else if (state & RecognizerState.Began) {\n    return 'start';\n  }\n  return '';\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAC,eAAe,EAAC,8BAA2B;;AAK7C,SAAU,QAAQ,CAAC,KAAsB;IAC7C,IAAI,KAAK,0LAAG,kBAAe,CAAC,SAAS,EAAE,CAAC;QACtC,OAAO,QAAQ,CAAC;IAClB,CAAC,MAAM,IAAI,KAAK,0LAAG,kBAAe,CAAC,KAAK,EAAE,CAAC;QACzC,OAAO,KAAK,CAAC;IACf,CAAC,MAAM,IAAI,KAAK,0LAAG,kBAAe,CAAC,OAAO,EAAE,CAAC;QAC3C,OAAO,MAAM,CAAC;IAChB,CAAC,MAAM,IAAI,KAAK,0LAAG,kBAAe,CAAC,KAAK,EAAE,CAAC;QACzC,OAAO,OAAO,CAAC;IACjB,CAAC;IACD,OAAO,EAAE,CAAC;AACZ,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1042, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1048, "column": 0}, "map": {"version":3,"file":"recognizer.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/recognizer/recognizer.ts"],"sourcesContent":["import {RecognizerState} from './recognizer-state';\nimport {uniqueId} from '../utils/unique-id';\nimport {stateStr} from './state-str';\n\nimport type {Manager} from '../manager';\nimport type {HammerInput} from '../input/types';\n\nexport type RecognizerOptions = {\n  /** Name of the event */\n  event: string;\n  /** Enable this recognizer */\n  enable: boolean;\n};\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n */\nexport abstract class Recognizer<OptionsT extends RecognizerOptions = any> {\n  id: number;\n  state: RecognizerState;\n  manager!: Manager;\n\n  readonly options: OptionsT;\n\n  protected simultaneous: {[id: string]: Recognizer};\n  protected requireFail: Recognizer[];\n\n  constructor(options: OptionsT) {\n    this.options = options;\n\n    this.id = uniqueId();\n\n    this.state = RecognizerState.Possible;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  /**\n   * set options\n   */\n  set(options: Partial<OptionsT>) {\n    Object.assign(this.options, options);\n\n    // also update the touchAction, in case something changed about the directions/enabled state\n    this.manager.touchAction.update();\n    return this;\n  }\n\n  /**\n   * recognize simultaneous with an other recognizer.\n   */\n  recognizeWith(recognizerOrName: Recognizer | string | (Recognizer | string)[]) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.recognizeWith(item);\n      }\n      return this;\n    }\n\n    let otherRecognizer: Recognizer | null;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n      if (!otherRecognizer) {\n        throw new Error(`Cannot find recognizer ${recognizerOrName}`);\n      }\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    const {simultaneous} = this;\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n    return this;\n  }\n\n  /**\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   */\n  dropRecognizeWith(recognizerOrName: Recognizer | string | (Recognizer | string)[]) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.dropRecognizeWith(item);\n      }\n      return this;\n    }\n\n    let otherRecognizer: Recognizer | null;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    if (otherRecognizer) {\n      delete this.simultaneous[otherRecognizer.id];\n    }\n    return this;\n  }\n\n  /**\n   * recognizer can only run when an other is failing\n   */\n  requireFailure(recognizerOrName: Recognizer | string | (Recognizer | string)[]) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.requireFailure(item);\n      }\n      return this;\n    }\n\n    let otherRecognizer: Recognizer | null;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n      if (!otherRecognizer) {\n        throw new Error(`Cannot find recognizer ${recognizerOrName}`);\n      }\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    const {requireFail} = this;\n    if (requireFail.indexOf(otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n    return this;\n  }\n\n  /**\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   */\n  dropRequireFailure(recognizerOrName: Recognizer | string | (Recognizer | string)[]) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.dropRequireFailure(item);\n      }\n      return this;\n    }\n\n    let otherRecognizer: Recognizer | null;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    if (otherRecognizer) {\n      const index = this.requireFail.indexOf(otherRecognizer);\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * has require failures boolean\n   */\n  hasRequireFailures(): boolean {\n    return Boolean(this.requireFail.find((recognier) => recognier.options.enable));\n  }\n\n  /**\n   * if the recognizer can recognize simultaneous with an other recognizer\n   */\n  canRecognizeWith(otherRecognizer: Recognizer): boolean {\n    return Boolean(this.simultaneous[otherRecognizer.id]);\n  }\n\n  /**\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   */\n  protected emit(input?: HammerInput) {\n    // Some recognizers override emit() with their own logic\n    if (!input) return;\n\n    const {state} = this;\n\n    // 'panstart' and 'panmove'\n    if (state < RecognizerState.Ended) {\n      this.manager.emit(this.options.event + stateStr(state), input);\n    }\n\n    // simple 'eventName' events\n    this.manager.emit(this.options.event, input);\n\n    // additional event(panleft, panright, pinchin, pinchout...)\n    if (input.additionalEvent) {\n      this.manager.emit(input.additionalEvent, input);\n    }\n\n    // panend and pancancel\n    if (state >= RecognizerState.Ended) {\n      this.manager.emit(this.options.event + stateStr(state), input);\n    }\n  }\n\n  /**\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   */\n  protected tryEmit(input?: HammerInput) {\n    if (this.canEmit()) {\n      this.emit(input);\n    } else {\n      // it's failing anyway\n      this.state = RecognizerState.Failed;\n    }\n  }\n\n  /**\n   * can we emit?\n   */\n  protected canEmit(): boolean {\n    let i = 0;\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (RecognizerState.Failed | RecognizerState.Possible))) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  }\n\n  /**\n   * update the recognizer\n   */\n  recognize(inputData: HammerInput) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    const inputDataClone = {...inputData};\n\n    // is is enabled and allow recognizing?\n    if (!this.options.enable) {\n      this.reset();\n      this.state = RecognizerState.Failed;\n      return;\n    }\n\n    // reset when we've reached the end\n    if (\n      this.state &\n      (RecognizerState.Recognized | RecognizerState.Cancelled | RecognizerState.Failed)\n    ) {\n      this.state = RecognizerState.Possible;\n    }\n\n    this.state = this.process(inputDataClone);\n\n    // the recognizer has recognized a gesture\n    // so trigger an event\n    if (\n      this.state &\n      (RecognizerState.Began |\n        RecognizerState.Changed |\n        RecognizerState.Ended |\n        RecognizerState.Cancelled)\n    ) {\n      this.tryEmit(inputDataClone);\n    }\n  }\n\n  /**\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   */\n\n  abstract process(inputData: HammerInput): RecognizerState;\n\n  /**\n   * return the preferred touch-action\n   */\n  abstract getTouchAction(): string[];\n\n  /**\n   * return the event names that are emitted by this recognizer\n   */\n  getEventNames(): string[] {\n    return [this.options.event];\n  }\n\n  /**\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   */\n  reset(): void {}\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1259, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1265, "column": 0}, "map": {"version":3,"file":"attribute.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/recognizers/attribute.ts"],"sourcesContent":["import {Recognizer, RecognizerOptions} from '../recognizer/recognizer';\nimport {RecognizerState} from '../recognizer/recognizer-state';\nimport {InputEvent} from '../input/input-consts';\nimport type {HammerInput} from '../input/types';\n\ntype AttrRecognizerOptions = RecognizerOptions & {\n  pointers: number;\n};\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n */\nexport abstract class AttrRecognizer<\n  OptionsT extends AttrRecognizerOptions\n> extends Recognizer<OptionsT> {\n  /**\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   */\n  attrTest(input: HammerInput): boolean {\n    const optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  }\n\n  /**\n   * Process the input and return the state for the recognizer\n   */\n  process(input: HammerInput) {\n    const {state} = this;\n    const {eventType} = input;\n\n    const isRecognized = state & (RecognizerState.Began | RecognizerState.Changed);\n    const isValid = this.attrTest(input);\n\n    // on cancel input and we've recognized before, return STATE_CANCELLED\n    if (isRecognized && (eventType & InputEvent.Cancel || !isValid)) {\n      return state | RecognizerState.Cancelled;\n    } else if (isRecognized || isValid) {\n      if (eventType & InputEvent.End) {\n        return state | RecognizerState.Ended;\n      } else if (!(state & RecognizerState.Began)) {\n        return RecognizerState.Began;\n      }\n      return state | RecognizerState.Changed;\n    }\n    return RecognizerState.Failed;\n  }\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAC,UAAU,EAAoB,oCAAiC;AACvE,OAAO,EAAC,eAAe,EAAC,0CAAuC;AAC/D,OAAO,EAAC,UAAU,EAAC,iCAA8B;;;;AAU3C,MAAgB,cAEpB,uLAAQ,aAAoB;IAC5B;;OAEG,CACH,QAAQ,CAAC,KAAkB,EAAA;QACzB,MAAM,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC;QAC7C,OAAO,cAAc,KAAK,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,MAAM,KAAK,cAAc,CAAC;IAC1E,CAAC;IAED;;OAEG,CACH,OAAO,CAAC,KAAkB,EAAA;QACxB,MAAM,EAAC,KAAK,EAAC,GAAG,IAAI,CAAC;QACrB,MAAM,EAAC,SAAS,EAAC,GAAG,KAAK,CAAC;QAE1B,MAAM,YAAY,GAAG,KAAK,GAAG,wLAAC,kBAAe,CAAC,KAAK,0LAAG,kBAAe,CAAC,OAAO,CAAC,CAAC;QAC/E,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAErC,sEAAsE;QACtE,IAAI,YAAY,IAAI,CAAC,SAAS,iLAAG,aAAU,CAAC,MAAM,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC;YAChE,OAAO,KAAK,0LAAG,kBAAe,CAAC,SAAS,CAAC;QAC3C,CAAC,MAAM,IAAI,YAAY,IAAI,OAAO,EAAE,CAAC;YACnC,IAAI,SAAS,iLAAG,aAAU,CAAC,GAAG,EAAE,CAAC;gBAC/B,OAAO,KAAK,0LAAG,kBAAe,CAAC,KAAK,CAAC;YACvC,CAAC,MAAM,IAAI,CAAC,CAAC,KAAK,0LAAG,kBAAe,CAAC,KAAK,CAAC,EAAE,CAAC;gBAC5C,8LAAO,kBAAe,CAAC,KAAK,CAAC;YAC/B,CAAC;YACD,OAAO,KAAK,0LAAG,kBAAe,CAAC,OAAO,CAAC;QACzC,CAAC;QACD,8LAAO,kBAAe,CAAC,MAAM,CAAC;IAChC,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 1302, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1308, "column": 0}, "map": {"version":3,"file":"tap.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/recognizers/tap.ts"],"sourcesContent":["/* global setTimeout, clearTimeout */\nimport {Recognizer} from '../recognizer/recognizer';\nimport {TOUCH_ACTION_MANIPULATION} from '../touchaction/touchaction-Consts';\nimport {InputEvent} from '../input/input-consts';\nimport {RecognizerState} from '../recognizer/recognizer-state';\nimport {getPointDistance} from '../input/get-distance';\nimport type {Point, HammerInput} from '../input/types';\n\nexport type TapRecognizerOptions = {\n  /** Name of the event.\n   * @default 'tap'\n   */\n  event?: string;\n  /** Enable this event.\n   * @default true\n   */\n  enable?: boolean;\n  /** Required pointers.\n   * @default 1\n   */\n  pointers?: number;\n  /** Required number of taps in succession.\n   * @default 1\n   */\n  taps?: number;\n  /** Maximum time in ms between multiple taps.\n   * @default 300\n   */\n  interval?: number;\n  /** Maximum press time in ms.\n   * @default 250\n   */\n  time?: number;\n  /** While doing a tap some small movement is allowed.\n   * @default 9\n   */\n  threshold?: number;\n  /** The maximum position difference between multiple taps.\n   * @default 10\n   */\n  posThreshold?: number;\n};\n\n/**\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n */\nexport class TapRecognizer extends Recognizer<Required<TapRecognizerOptions>> {\n  /** previous time for tap counting */\n  private pTime: number | null = null;\n  /** previous center for tap counting */\n  private pCenter: Point | null = null;\n\n  private _timer: any = null;\n  private _input: HammerInput | null = null;\n\n  private count: number = 0;\n\n  constructor(options: TapRecognizerOptions = {}) {\n    super({\n      enable: true,\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      time: 250,\n      threshold: 9,\n      posThreshold: 10,\n      ...options\n    });\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  }\n\n  process(input: HammerInput) {\n    const {options} = this;\n\n    const validPointers = input.pointers.length === options.pointers;\n    const validMovement = input.distance < options.threshold;\n    const validTouchTime = input.deltaTime < options.time;\n\n    this.reset();\n\n    if (input.eventType & InputEvent.Start && this.count === 0) {\n      return this.failTimeout();\n    }\n\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== InputEvent.End) {\n        return this.failTimeout();\n      }\n\n      const validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      const validMultiTap =\n        !this.pCenter || getPointDistance(this.pCenter, input.center) < options.posThreshold;\n\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input;\n\n      // if tap count matches we have recognized it,\n      // else it has began recognizing...\n      const tapCount = this.count % options.taps;\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return RecognizerState.Recognized;\n        }\n        this._timer = setTimeout(() => {\n          this.state = RecognizerState.Recognized;\n          this.tryEmit(this._input!);\n        }, options.interval);\n        return RecognizerState.Began;\n      }\n    }\n    return RecognizerState.Failed;\n  }\n\n  failTimeout() {\n    this._timer = setTimeout(() => {\n      this.state = RecognizerState.Failed;\n    }, this.options.interval);\n    return RecognizerState.Failed;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n  }\n\n  emit(input: HammerInput) {\n    if (this.state === RecognizerState.Recognized) {\n      input.tapCount = this.count;\n      this.manager.emit(this.options.event, input);\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1404, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1410, "column": 0}, "map": {"version":3,"file":"pan.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/recognizers/pan.ts"],"sourcesContent":["import {AttrRecognizer} from './attribute';\nimport {InputDirection} from '../input/input-consts';\nimport {RecognizerState} from '../recognizer/recognizer-state';\nimport {TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y} from '../touchaction/touchaction-Consts';\nimport type {HammerInput} from '../input/types';\n\nexport type PanRecognizerOptions = {\n  /** Name of the event.\n   * @default 'pan'\n   */\n  event?: string;\n  /** Enable this event.\n   * @default true\n   */\n  enable?: boolean;\n  /** Required number of pointers. 0 for all pointers.\n   * @default 1\n   */\n  pointers?: number;\n  /** Required direction of panning.\n   * @default InputDirection.All\n   */\n  direction?: InputDirection;\n  /** Minimal pan distance required before recognizing.\n   * @default 10\n   */\n  threshold?: number;\n};\n\nconst EVENT_NAMES = ['', 'start', 'move', 'end', 'cancel', 'up', 'down', 'left', 'right'] as const;\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n */\nexport class PanRecognizer extends AttrRecognizer<Required<PanRecognizerOptions>> {\n  pX: number | null;\n  pY: number | null;\n\n  constructor(options: PanRecognizerOptions = {}) {\n    super({\n      enable: true,\n      pointers: 1,\n      event: 'pan',\n      threshold: 10,\n      direction: InputDirection.All,\n      ...options\n    });\n    this.pX = null;\n    this.pY = null;\n  }\n\n  getTouchAction(): string[] {\n    const {\n      options: {direction}\n    } = this;\n    const actions: string[] = [];\n    if (direction & InputDirection.Horizontal) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n    if (direction & InputDirection.Vertical) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n    return actions;\n  }\n\n  getEventNames(): string[] {\n    return EVENT_NAMES.map((suffix) => this.options.event + suffix);\n  }\n\n  directionTest(input: HammerInput): boolean {\n    const {options} = this;\n    let hasMoved = true;\n    let {distance} = input;\n    let {direction} = input;\n    const x = input.deltaX;\n    const y = input.deltaY;\n\n    // lock to axis?\n    if (!(direction & options.direction)) {\n      if (options.direction & InputDirection.Horizontal) {\n        direction =\n          x === 0 ? InputDirection.None : x < 0 ? InputDirection.Left : InputDirection.Right;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? InputDirection.None : y < 0 ? InputDirection.Up : InputDirection.Down;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && Boolean(direction & options.direction);\n  }\n\n  attrTest(input: HammerInput): boolean {\n    return (\n      super.attrTest(input) &&\n      (Boolean(this.state & RecognizerState.Began) ||\n        (!(this.state & RecognizerState.Began) && this.directionTest(input)))\n    );\n  }\n\n  emit(input: HammerInput) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n\n    const direction = InputDirection[input.direction].toLowerCase();\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n    super.emit(input);\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1494, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1500, "column": 0}, "map": {"version":3,"file":"swipe.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/recognizers/swipe.ts"],"sourcesContent":["import {AttrRecognizer} from './attribute';\nimport {InputDirection, InputEvent} from '../input/input-consts';\nimport {PanRecognizer} from './pan';\nimport type {HammerInput} from '../input/types';\n\nexport type SwipeRecognizerOptions = {\n  /** Name of the event.\n   * @default 'swipe'\n   */\n  event?: string;\n  /** Enable this event.\n   * @default true\n   */\n  enable?: boolean;\n  /** Required number of pointers.\n   * @default 1\n   */\n  pointers?: number;\n  /** Direction of the panning.\n   * @default InputDirection.All\n   */\n  direction?: InputDirection;\n  /** Minimal distance required before recognizing.\n   * @default 10\n   */\n  threshold?: number;\n  /** Minimal velocity required before recognizing, in px/ms\n   * @default 0.3\n   */\n  velocity?: number;\n};\n\nconst EVENT_NAMES = ['', 'up', 'down', 'left', 'right'] as const;\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n */\nexport class SwipeRecognizer extends AttrRecognizer<Required<SwipeRecognizerOptions>> {\n  constructor(options: SwipeRecognizerOptions = {}) {\n    super({\n      enable: true,\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: InputDirection.All,\n      pointers: 1,\n      ...options\n    });\n  }\n\n  getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  }\n\n  getEventNames(): string[] {\n    return EVENT_NAMES.map((suffix) => this.options.event + suffix);\n  }\n\n  attrTest(input: HammerInput): boolean {\n    const {direction} = this.options;\n    let velocity = 0;\n\n    if (direction & InputDirection.All) {\n      velocity = input.overallVelocity;\n    } else if (direction & InputDirection.Horizontal) {\n      velocity = input.overallVelocityX;\n    } else if (direction & InputDirection.Vertical) {\n      velocity = input.overallVelocityY;\n    }\n\n    return (\n      super.attrTest(input) &&\n      Boolean(direction & input.offsetDirection) &&\n      input.distance > this.options.threshold &&\n      input.maxPointers === this.options.pointers &&\n      Math.abs(velocity) > this.options.velocity &&\n      Boolean(input.eventType & InputEvent.End)\n    );\n  }\n\n  emit(input: HammerInput) {\n    const direction = InputDirection[input.offsetDirection].toLowerCase();\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  }\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAC,cAAc,EAAC,uBAAoB;AAC3C,OAAO,EAAC,cAAc,EAAE,UAAU,EAAC,iCAA8B;AACjE,OAAO,EAAC,aAAa,EAAC,iBAAc;;;;AA8BpC,MAAM,WAAW,GAAG;IAAC,EAAE;IAAE,IAAI;IAAE,MAAM;IAAE,MAAM;IAAE,OAAO;CAAU,CAAC;AAM3D,MAAO,eAAgB,uLAAQ,iBAAgD;IACnF,YAAY,UAAkC,CAAA,CAAE,CAAA;QAC9C,KAAK,CAAC;YACJ,MAAM,EAAE,IAAI;YACZ,KAAK,EAAE,OAAO;YACd,SAAS,EAAE,EAAE;YACb,QAAQ,EAAE,GAAG;YACb,SAAS,gLAAE,iBAAc,CAAC,GAAG;YAC7B,QAAQ,EAAE,CAAC;YACX,GAAG,OAAO;SACX,CAAC,CAAC;IACL,CAAC;IAED,cAAc,GAAA;QACZ,+KAAO,gBAAa,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC3D,CAAC;IAED,aAAa,GAAA;QACX,OAAO,WAAW,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAG,CAAD,GAAK,CAAC,OAAO,CAAC,KAAK,GAAG,MAAM,CAAC,CAAC;IAClE,CAAC;IAED,QAAQ,CAAC,KAAkB,EAAA;QACzB,MAAM,EAAC,SAAS,EAAC,GAAG,IAAI,CAAC,OAAO,CAAC;QACjC,IAAI,QAAQ,GAAG,CAAC,CAAC;QAEjB,IAAI,SAAS,iLAAG,iBAAc,CAAC,GAAG,EAAE,CAAC;YACnC,QAAQ,GAAG,KAAK,CAAC,eAAe,CAAC;QACnC,CAAC,MAAM,IAAI,SAAS,iLAAG,iBAAc,CAAC,UAAU,EAAE,CAAC;YACjD,QAAQ,GAAG,KAAK,CAAC,gBAAgB,CAAC;QACpC,CAAC,MAAM,IAAI,SAAS,iLAAG,iBAAc,CAAC,QAAQ,EAAE,CAAC;YAC/C,QAAQ,GAAG,KAAK,CAAC,gBAAgB,CAAC;QACpC,CAAC;QAED,OAAO,AACL,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,IACrB,OAAO,CAAC,SAAS,GAAG,KAAK,CAAC,eAAe,CAAC,IAC1C,KAAK,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,IACvC,KAAK,CAAC,WAAW,KAAK,IAAI,CAAC,OAAO,CAAC,QAAQ,IAC3C,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,IAC1C,OAAO,CAAC,KAAK,CAAC,SAAS,iLAAG,aAAU,CAAC,GAAG,CAAC,CAC1C,CAAC;IACJ,CAAC;IAED,IAAI,CAAC,KAAkB,EAAA;QACrB,MAAM,SAAS,iLAAG,iBAAc,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC,WAAW,EAAE,CAAC;QACtE,IAAI,SAAS,EAAE,CAAC;YACd,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,GAAG,SAAS,EAAE,KAAK,CAAC,CAAC;QAC3D,CAAC;QAED,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IAC/C,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 1554, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1560, "column": 0}, "map": {"version":3,"file":"pinch.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/recognizers/pinch.ts"],"sourcesContent":["import {AttrRecognizer} from './attribute';\nimport {TOUCH_ACTION_NONE} from '../touchaction/touchaction-Consts';\nimport {RecognizerState} from '../recognizer/recognizer-state';\nimport type {HammerInput} from '../input/types';\n\nexport type PinchRecognizerOptions = {\n  /** Name of the event.\n   * @default 'pinch'\n   */\n  event?: string;\n  /** Enable this event.\n   * @default true\n   */\n  enable?: boolean;\n  /** Required number of pointers, with a minimum of 2.\n   * @default 2\n   */\n  pointers?: number;\n  /** Minimal scale before recognizing.\n   * @default 0\n   */\n  threshold?: number;\n};\n\nconst EVENT_NAMES = ['', 'start', 'move', 'end', 'cancel', 'in', 'out'] as const;\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n */\nexport class PinchRecognizer extends AttrRecognizer<Required<PinchRecognizerOptions>> {\n  constructor(options: PinchRecognizerOptions = {}) {\n    super({\n      enable: true,\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2,\n      ...options\n    });\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  }\n\n  getEventNames(): string[] {\n    return EVENT_NAMES.map((suffix) => this.options.event + suffix);\n  }\n\n  attrTest(input: HammerInput): boolean {\n    return (\n      super.attrTest(input) &&\n      (Math.abs(input.scale - 1) > this.options.threshold ||\n        Boolean(this.state & RecognizerState.Began))\n    );\n  }\n\n  emit(input: HammerInput) {\n    if (input.scale !== 1) {\n      const inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n    super.emit(input);\n  }\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAC,cAAc,EAAC,uBAAoB;AAC3C,OAAO,EAAC,iBAAiB,EAAC,6CAA0C;AACpE,OAAO,EAAC,eAAe,EAAC,0CAAuC;;;;AAsB/D,MAAM,WAAW,GAAG;IAAC,EAAE;IAAE,OAAO;IAAE,MAAM;IAAE,KAAK;IAAE,QAAQ;IAAE,IAAI;IAAE,KAAK;CAAU,CAAC;AAM3E,MAAO,eAAgB,uLAAQ,iBAAgD;IACnF,YAAY,UAAkC,CAAA,CAAE,CAAA;QAC9C,KAAK,CAAC;YACJ,MAAM,EAAE,IAAI;YACZ,KAAK,EAAE,OAAO;YACd,SAAS,EAAE,CAAC;YACZ,QAAQ,EAAE,CAAC;YACX,GAAG,OAAO;SACX,CAAC,CAAC;IACL,CAAC;IAED,cAAc,GAAA;QACZ,OAAO;sMAAC,oBAAiB;SAAC,CAAC;IAC7B,CAAC;IAED,aAAa,GAAA;QACX,OAAO,WAAW,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAG,CAAD,GAAK,CAAC,OAAO,CAAC,KAAK,GAAG,MAAM,CAAC,CAAC;IAClE,CAAC;IAED,QAAQ,CAAC,KAAkB,EAAA;QACzB,OAAO,AACL,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,IACrB,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,IACjD,OAAO,CAAC,IAAI,CAAC,KAAK,0LAAG,kBAAe,CAAC,KAAK,CAAC,CAAC,CAC/C,CAAC;IACJ,CAAC;IAED,IAAI,CAAC,KAAkB,EAAA;QACrB,IAAI,KAAK,CAAC,KAAK,KAAK,CAAC,EAAE,CAAC;YACtB,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC;YAC7C,KAAK,CAAC,eAAe,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;QACrD,CAAC;QACD,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACpB,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 1607, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1613, "column": 0}, "map": {"version":3,"file":"rotate.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/recognizers/rotate.ts"],"sourcesContent":["import {AttrRecognizer} from './attribute';\nimport {TOUCH_ACTION_NONE} from '../touchaction/touchaction-Consts';\nimport {RecognizerState} from '../recognizer/recognizer-state';\nimport type {HammerInput} from '../input/types';\n\nexport type RotateRecognizerOptions = {\n  /** Name of the event.\n   * @default 'rotate'\n   */\n  event?: string;\n  /** Enable this event.\n   * @default true\n   */\n  enable?: boolean;\n  /** Required number of pointers, with a minimum of 2.\n   * @default 2\n   */\n  pointers?: number;\n  /** Minimal rotation before recognizing.\n   * @default 0\n   */\n  threshold?: number;\n};\n\nconst EVENT_NAMES = ['', 'start', 'move', 'end', 'cancel'] as const;\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n */\nexport class RotateRecognizer extends AttrRecognizer<Required<RotateRecognizerOptions>> {\n  constructor(options: RotateRecognizerOptions = {}) {\n    super({\n      enable: true,\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2,\n      ...options\n    });\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  }\n\n  getEventNames(): string[] {\n    return EVENT_NAMES.map((suffix) => this.options.event + suffix);\n  }\n\n  attrTest(input: HammerInput): boolean {\n    return (\n      super.attrTest(input) &&\n      (Math.abs(input.rotation) > this.options.threshold ||\n        Boolean(this.state & RecognizerState.Began))\n    );\n  }\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAC,cAAc,EAAC,uBAAoB;AAC3C,OAAO,EAAC,iBAAiB,EAAC,6CAA0C;AACpE,OAAO,EAAC,eAAe,EAAC,0CAAuC;;;;AAsB/D,MAAM,WAAW,GAAG;IAAC,EAAE;IAAE,OAAO;IAAE,MAAM;IAAE,KAAK;IAAE,QAAQ;CAAU,CAAC;AAM9D,MAAO,gBAAiB,uLAAQ,iBAAiD;IACrF,YAAY,UAAmC,CAAA,CAAE,CAAA;QAC/C,KAAK,CAAC;YACJ,MAAM,EAAE,IAAI;YACZ,KAAK,EAAE,QAAQ;YACf,SAAS,EAAE,CAAC;YACZ,QAAQ,EAAE,CAAC;YACX,GAAG,OAAO;SACX,CAAC,CAAC;IACL,CAAC;IAED,cAAc,GAAA;QACZ,OAAO;sMAAC,oBAAiB;SAAC,CAAC;IAC7B,CAAC;IAED,aAAa,GAAA;QACX,OAAO,WAAW,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAG,CAAD,GAAK,CAAC,OAAO,CAAC,KAAK,GAAG,MAAM,CAAC,CAAC;IAClE,CAAC;IAED,QAAQ,CAAC,KAAkB,EAAA;QACzB,OAAO,AACL,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,IACrB,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,IAChD,OAAO,CAAC,IAAI,CAAC,KAAK,0LAAG,kBAAe,CAAC,KAAK,CAAC,CAAC,CAC/C,CAAC;IACJ,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 1651, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1657, "column": 0}, "map": {"version":3,"file":"press.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/recognizers/press.ts"],"sourcesContent":["/* global setTimeout, clearTimeout */\nimport {Recognizer} from '../recognizer/recognizer';\nimport {RecognizerState} from '../recognizer/recognizer-state';\nimport {TOUCH_ACTION_AUTO} from '../touchaction/touchaction-Consts';\nimport {InputEvent} from '../input/input-consts';\nimport {HammerInput} from '../input/types';\n\nexport type PressRecognizerOptions = {\n  /** Name of the event.\n   * @default 'press'\n   */\n  event?: string;\n  /** Enable this event.\n   * @default true\n   */\n  enable?: boolean;\n  /** Required number of pointers.\n   * @default 1\n   */\n  pointers?: number;\n  /** Minimal press time in ms.\n   * @default 251\n   */\n  time?: number;\n  /** Minimal movement that is allowed while pressing.\n   * @default 9\n   */\n  threshold?: number;\n};\n\nconst EVENT_NAMES = ['', 'up'] as const;\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n */\nexport class PressRecognizer extends Recognizer<Required<PressRecognizerOptions>> {\n  private _timer: any = null;\n  private _input: HammerInput | null = null;\n\n  constructor(options: PressRecognizerOptions = {}) {\n    super({\n      enable: true,\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      threshold: 9,\n      ...options\n    });\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  }\n\n  getEventNames(): string[] {\n    return EVENT_NAMES.map((suffix) => this.options.event + suffix);\n  }\n\n  process(input: HammerInput) {\n    const {options} = this;\n    const validPointers = input.pointers.length === options.pointers;\n    const validMovement = input.distance < options.threshold;\n    const validTime = input.deltaTime > options.time;\n\n    this._input = input;\n\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (\n      !validMovement ||\n      !validPointers ||\n      (input.eventType & (InputEvent.End | InputEvent.Cancel) && !validTime)\n    ) {\n      this.reset();\n    } else if (input.eventType & InputEvent.Start) {\n      this.reset();\n      this._timer = setTimeout(() => {\n        this.state = RecognizerState.Recognized;\n        this.tryEmit();\n      }, options.time);\n    } else if (input.eventType & InputEvent.End) {\n      return RecognizerState.Recognized;\n    }\n    return RecognizerState.Failed;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n  }\n\n  emit(input?: HammerInput) {\n    if (this.state !== RecognizerState.Recognized) {\n      return;\n    }\n\n    if (input && input.eventType & InputEvent.End) {\n      this.manager.emit(`${this.options.event}up`, input);\n    } else {\n      this._input!.timeStamp = Date.now();\n      this.manager.emit(this.options.event, this._input!);\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1729, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1735, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/hammerjs/index.ts"],"sourcesContent":["export {InputEvent} from './input/input-consts';\nexport {RecognizerState} from './recognizer/recognizer-state';\nexport {InputDirection} from './input/input-consts';\n\nexport {Manager} from './manager';\nexport {Input} from './input/input';\nexport {TouchAction} from './touchaction/touchaction';\nexport {PointerEventInput} from './inputs/pointerevent';\n\nexport {Recognizer} from './recognizer/recognizer';\nexport {AttrRecognizer} from './recognizers/attribute';\nexport {TapRecognizer as Tap} from './recognizers/tap';\nexport {PanRecognizer as Pan} from './recognizers/pan';\nexport {SwipeRecognizer as Swipe} from './recognizers/swipe';\nexport {PinchRecognizer as Pinch} from './recognizers/pinch';\nexport {RotateRecognizer as Rotate} from './recognizers/rotate';\nexport {PressRecognizer as Press} from './recognizers/press';\n\nexport type {HammerEvent, ManagerOptions} from './manager';\nexport type {TapRecognizerOptions} from './recognizers/tap';\nexport type {PanRecognizerOptions} from './recognizers/pan';\nexport type {SwipeRecognizerOptions} from './recognizers/swipe';\nexport type {PinchRecognizerOptions} from './recognizers/pinch';\nexport type {RotateRecognizerOptions} from './recognizers/rotate';\nexport type {PressRecognizerOptions} from './recognizers/press';\n"],"names":[],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 1752, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1780, "column": 0}, "map": {"version":3,"file":"input.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/inputs/input.ts"],"sourcesContent":["// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {MjolnirEventRaw} from '../types';\n\nexport interface InputOptions {\n  enable?: boolean;\n}\n\nexport class Input<EventType extends MjolnirEventRaw, Options extends InputOptions> {\n  element: HTMLElement;\n  options: Options;\n  callback: (e: EventType) => void;\n\n  constructor(element: HTMLElement, callback: (e: EventType) => void, options: Options) {\n    this.element = element;\n    this.callback = callback;\n    this.options = options;\n  }\n}\n"],"names":[],"mappings":"AAAA,aAAa;AACb,+BAA+B;AAC/B,oCAAoC;;;;AAQ9B,MAAO,KAAK;IAKhB,YAAY,OAAoB,EAAE,QAAgC,EAAE,OAAgB,CAAA;QAClF,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACzB,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 1793, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1799, "column": 0}, "map": {"version":3,"file":"globals.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/utils/globals.ts"],"sourcesContent":["// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global'\n\n/* global window, global, document, navigator */\nexport const userAgent =\n  typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent.toLowerCase() : '';\n\nconst window_ = typeof window !== 'undefined' ? window : global;\nconst global_ = typeof global !== 'undefined' ? global : window;\nconst document_ = typeof document !== 'undefined' ? document : {};\n\nexport {window_ as window, global_ as global, document_ as document};\n"],"names":[],"mappings":"AAAA,aAAa;AACb,+BAA+B;AAC/B,oCAAoC;AAEpC,wEAAwE;AACxE,8BAA8B;AAE9B,8CAAA,EAAgD;;;;;;AACzC,MAAM,SAAS,GACpB,OAAO,SAAS,KAAK,WAAW,IAAI,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;AAEnG,MAAM,OAAO,GAAG,OAAO,MAAM,KAAK,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC;AAChE,MAAM,OAAO,GAAG,OAAO,MAAM,KAAK,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC;AAChE,MAAM,SAAS,GAAG,OAAO,QAAQ,KAAK,WAAW,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1816, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1822, "column": 0}, "map": {"version":3,"file":"wheel-input.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/inputs/wheel-input.ts"],"sourcesContent":["// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {MjolnirWheelEventRaw} from '../types';\nimport {Input, InputOptions} from './input';\n\nimport {userAgent} from '../utils/globals';\n\nconst firefox = userAgent.indexOf('firefox') !== -1;\n\n// Constants for normalizing input delta\nconst WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;\nconst WHEEL_DELTA_PER_LINE = 40;\n// Slow down zoom if shift key is held for more precise zooming\nconst SHIFT_MULTIPLIER = 0.25;\n\nexport class WheelInput extends Input<MjolnirWheelEventRaw, Required<InputOptions>> {\n  constructor(\n    element: HTMLElement,\n    callback: (event: MjolnirWheelEventRaw) => void,\n    options: InputOptions\n  ) {\n    super(element, callback, {enable: true, ...options});\n\n    element.addEventListener('wheel', this.handleEvent, {passive: false});\n  }\n\n  destroy() {\n    this.element.removeEventListener('wheel', this.handleEvent);\n  }\n\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType: string, enabled: boolean) {\n    if (eventType === 'wheel') {\n      this.options.enable = enabled;\n    }\n  }\n\n  /* eslint-disable complexity, max-statements */\n  handleEvent = (event: WheelEvent) => {\n    if (!this.options.enable) {\n      return;\n    }\n\n    let value = event.deltaY;\n    if (globalThis.WheelEvent) {\n      // Firefox doubles the values on retina screens...\n      if (firefox && event.deltaMode === globalThis.WheelEvent.DOM_DELTA_PIXEL) {\n        value /= globalThis.devicePixelRatio;\n      }\n      if (event.deltaMode === globalThis.WheelEvent.DOM_DELTA_LINE) {\n        value *= WHEEL_DELTA_PER_LINE;\n      }\n    }\n\n    if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {\n      // This one is definitely a mouse wheel event.\n      // Normalize this value to match trackpad.\n      value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);\n    }\n\n    if (event.shiftKey && value) {\n      value = value * SHIFT_MULTIPLIER;\n    }\n\n    this.callback({\n      type: 'wheel',\n      center: {\n        x: event.clientX,\n        y: event.clientY\n      },\n      delta: -value,\n      srcEvent: event,\n      pointerType: 'mouse',\n      target: event.target as HTMLElement\n    });\n  };\n}\n"],"names":[],"mappings":"AAAA,aAAa;AACb,+BAA+B;AAC/B,oCAAoC;;;;AAGpC,OAAO,EAAC,KAAK,EAAe,mBAAgB;AAE5C,OAAO,EAAC,SAAS,EAAC,4BAAyB;;;AAE3C,MAAM,OAAO,6JAAG,YAAS,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;AAEpD,wCAAwC;AACxC,MAAM,wBAAwB,GAAG,cAAc,CAAC;AAChD,MAAM,oBAAoB,GAAG,EAAE,CAAC;AAChC,+DAA+D;AAC/D,MAAM,gBAAgB,GAAG,IAAI,CAAC;AAExB,MAAO,UAAW,kKAAQ,QAAmD;IACjF,YACE,OAAoB,EACpB,QAA+C,EAC/C,OAAqB,CAAA;QAErB,KAAK,CAAC,OAAO,EAAE,QAAQ,EAAE;YAAC,MAAM,EAAE,IAAI;YAAE,GAAG,OAAO;QAAA,CAAC,CAAC,CAAC;QAmBvD,6CAAA,EAA+C,CAC/C,IAAA,CAAA,WAAW,GAAG,CAAC,KAAiB,EAAE,EAAE;YAClC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;gBACzB,OAAO;YACT,CAAC;YAED,IAAI,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC;YACzB,IAAI,UAAU,CAAC,UAAU,EAAE,CAAC;gBAC1B,kDAAkD;gBAClD,IAAI,OAAO,IAAI,KAAK,CAAC,SAAS,KAAK,UAAU,CAAC,UAAU,CAAC,eAAe,EAAE,CAAC;oBACzE,KAAK,IAAI,UAAU,CAAC,gBAAgB,CAAC;gBACvC,CAAC;gBACD,IAAI,KAAK,CAAC,SAAS,KAAK,UAAU,CAAC,UAAU,CAAC,cAAc,EAAE,CAAC;oBAC7D,KAAK,IAAI,oBAAoB,CAAC;gBAChC,CAAC;YACH,CAAC;YAED,IAAI,KAAK,KAAK,CAAC,IAAI,KAAK,GAAG,wBAAwB,KAAK,CAAC,EAAE,CAAC;gBAC1D,8CAA8C;gBAC9C,0CAA0C;gBAC1C,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,wBAAwB,CAAC,CAAC;YACvD,CAAC;YAED,IAAI,KAAK,CAAC,QAAQ,IAAI,KAAK,EAAE,CAAC;gBAC5B,KAAK,GAAG,KAAK,GAAG,gBAAgB,CAAC;YACnC,CAAC;YAED,IAAI,CAAC,QAAQ,CAAC;gBACZ,IAAI,EAAE,OAAO;gBACb,MAAM,EAAE;oBACN,CAAC,EAAE,KAAK,CAAC,OAAO;oBAChB,CAAC,EAAE,KAAK,CAAC,OAAO;iBACjB;gBACD,KAAK,EAAE,CAAC,KAAK;gBACb,QAAQ,EAAE,KAAK;gBACf,WAAW,EAAE,OAAO;gBACpB,MAAM,EAAE,KAAK,CAAC,MAAqB;aACpC,CAAC,CAAC;QACL,CAAC,CAAC;QAvDA,OAAO,CAAC,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW,EAAE;YAAC,OAAO,EAAE,KAAK;QAAA,CAAC,CAAC,CAAC;IACxE,CAAC;IAED,OAAO,GAAA;QACL,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;IAC9D,CAAC;IAED;;;OAGG,CACH,eAAe,CAAC,SAAiB,EAAE,OAAgB,EAAA;QACjD,IAAI,SAAS,KAAK,OAAO,EAAE,CAAC;YAC1B,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC;QAChC,CAAC;IACH,CAAC;CAyCF","ignoreList":[0]}},
    {"offset": {"line": 1894, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1900, "column": 0}, "map": {"version":3,"file":"move-input.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/inputs/move-input.ts"],"sourcesContent":["// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {MjolnirPointerEventRaw} from '../types';\nimport {Input, InputOptions} from './input';\n\nconst MOUSE_EVENTS = [\n  'mousedown',\n  'mousemove',\n  'mouseup',\n  'mouseover',\n  'mouseout',\n  'mouseleave'\n] as const;\n\ntype MoveEventType = 'pointermove' | 'pointerover' | 'pointerout' | 'pointerenter' | 'pointerleave';\n\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\nexport class MoveInput extends Input<MjolnirPointerEventRaw, Required<InputOptions>> {\n  pressed: boolean;\n  enableMoveEvent: boolean;\n  enableEnterEvent: boolean;\n  enableLeaveEvent: boolean;\n  enableOutEvent: boolean;\n  enableOverEvent: boolean;\n\n  constructor(\n    element: HTMLElement,\n    callback: (event: MjolnirPointerEventRaw) => void,\n    options: InputOptions\n  ) {\n    super(element, callback, {enable: true, ...options});\n\n    this.pressed = false;\n    const {enable} = this.options;\n\n    this.enableMoveEvent = enable;\n    this.enableLeaveEvent = enable;\n    this.enableEnterEvent = enable;\n    this.enableOutEvent = enable;\n    this.enableOverEvent = enable;\n\n    MOUSE_EVENTS.forEach((event) => element.addEventListener(event, this.handleEvent));\n  }\n\n  destroy() {\n    MOUSE_EVENTS.forEach((event) => this.element.removeEventListener(event, this.handleEvent));\n  }\n\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType: string, enabled: boolean) {\n    switch (eventType) {\n      case 'pointermove':\n        this.enableMoveEvent = enabled;\n        break;\n      case 'pointerover':\n        this.enableOverEvent = enabled;\n        break;\n      case 'pointerout':\n        this.enableOutEvent = enabled;\n        break;\n      case 'pointerenter':\n        this.enableEnterEvent = enabled;\n        break;\n      case 'pointerleave':\n        this.enableLeaveEvent = enabled;\n        break;\n      default:\n      // ignore\n    }\n  }\n\n  handleEvent = (event: MouseEvent) => {\n    this.handleOverEvent(event);\n    this.handleOutEvent(event);\n    this.handleEnterEvent(event);\n    this.handleLeaveEvent(event);\n    this.handleMoveEvent(event);\n  };\n\n  handleOverEvent(event: MouseEvent) {\n    if (this.enableOverEvent && event.type === 'mouseover') {\n      this._emit('pointerover', event);\n    }\n  }\n\n  handleOutEvent(event: MouseEvent) {\n    if (this.enableOutEvent && event.type === 'mouseout') {\n      this._emit('pointerout', event);\n    }\n  }\n\n  handleEnterEvent(event: MouseEvent) {\n    if (this.enableEnterEvent && event.type === 'mouseenter') {\n      this._emit('pointerenter', event);\n    }\n  }\n\n  handleLeaveEvent(event: MouseEvent) {\n    if (this.enableLeaveEvent && event.type === 'mouseleave') {\n      this._emit('pointerleave', event);\n    }\n  }\n\n  handleMoveEvent(event: MouseEvent) {\n    if (this.enableMoveEvent) {\n      switch (event.type) {\n        case 'mousedown':\n          if (event.button >= 0) {\n            // Button is down\n            this.pressed = true;\n          }\n          break;\n        case 'mousemove':\n          // Move events use `bottons` to track the button being pressed\n          if (event.buttons === 0) {\n            // Button is not down\n            this.pressed = false;\n          }\n          if (!this.pressed) {\n            // Drag events are emitted by hammer already\n            // we just need to emit the move event on hover\n            this._emit('pointermove', event);\n          }\n          break;\n        case 'mouseup':\n          this.pressed = false;\n          break;\n        default:\n      }\n    }\n  }\n\n  _emit(type: MoveEventType, event: MouseEvent) {\n    this.callback({\n      type,\n      center: {\n        x: event.clientX,\n        y: event.clientY\n      },\n      srcEvent: event,\n      pointerType: 'mouse',\n      target: event.target as HTMLElement\n    });\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2025, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2031, "column": 0}, "map": {"version":3,"file":"key-input.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/inputs/key-input.ts"],"sourcesContent":["// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {MjolnirKeyEventRaw} from '../types';\nimport {Input, InputOptions} from './input';\n\nconst KEY_EVENTS = ['keydown', 'keyup'] as const;\n\ntype KeyInputOptions = InputOptions & {\n  tabIndex?: number;\n};\n\nexport class KeyInput extends Input<MjolnirKeyEventRaw, Required<KeyInputOptions>> {\n  enableDownEvent: boolean;\n  enableUpEvent: boolean;\n\n  constructor(\n    element: HTMLElement,\n    callback: (event: MjolnirKeyEventRaw) => void,\n    options: KeyInputOptions\n  ) {\n    super(element, callback, {enable: true, tabIndex: 0, ...options});\n\n    this.enableDownEvent = this.options.enable;\n    this.enableUpEvent = this.options.enable;\n\n    element.tabIndex = this.options.tabIndex;\n    element.style.outline = 'none';\n    KEY_EVENTS.forEach((event) => element.addEventListener(event, this.handleEvent));\n  }\n\n  destroy() {\n    KEY_EVENTS.forEach((event) => this.element.removeEventListener(event, this.handleEvent));\n  }\n\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType: string, enabled: boolean) {\n    if (eventType === 'keydown') {\n      this.enableDownEvent = enabled;\n    }\n    if (eventType === 'keyup') {\n      this.enableUpEvent = enabled;\n    }\n  }\n\n  handleEvent = (event: KeyboardEvent) => {\n    // Ignore if focused on text input\n    const targetElement = (event.target || event.srcElement) as HTMLElement;\n    if (\n      (targetElement.tagName === 'INPUT' && (targetElement as HTMLInputElement).type === 'text') ||\n      targetElement.tagName === 'TEXTAREA'\n    ) {\n      return;\n    }\n\n    if (this.enableDownEvent && event.type === 'keydown') {\n      this.callback({\n        type: 'keydown',\n        srcEvent: event,\n        key: event.key,\n        target: event.target as HTMLElement\n      });\n    }\n\n    if (this.enableUpEvent && event.type === 'keyup') {\n      this.callback({\n        type: 'keyup',\n        srcEvent: event,\n        key: event.key,\n        target: event.target as HTMLElement\n      });\n    }\n  };\n}\n"],"names":[],"mappings":"AAAA,aAAa;AACb,+BAA+B;AAC/B,oCAAoC;;;;AAGpC,OAAO,EAAC,KAAK,EAAe,mBAAgB;;AAE5C,MAAM,UAAU,GAAG;IAAC,SAAS;IAAE,OAAO;CAAU,CAAC;AAM3C,MAAO,QAAS,kKAAQ,QAAoD;IAIhF,YACE,OAAoB,EACpB,QAA6C,EAC7C,OAAwB,CAAA;QAExB,KAAK,CAAC,OAAO,EAAE,QAAQ,EAAE;YAAC,MAAM,EAAE,IAAI;YAAE,QAAQ,EAAE,CAAC;YAAE,GAAG,OAAO;QAAA,CAAC,CAAC,CAAC;QA2BpE,IAAA,CAAA,WAAW,GAAG,CAAC,KAAoB,EAAE,EAAE;YACrC,kCAAkC;YAClC,MAAM,aAAa,GAAG,AAAC,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,UAAU,CAAgB,CAAC;YACxE,IACE,AAAC,aAAa,CAAC,OAAO,KAAK,OAAO,IAAK,aAAkC,CAAC,IAAI,KAAK,MAAM,CAAC,GAC1F,aAAa,CAAC,OAAO,KAAK,UAAU,EACpC,CAAC;gBACD,OAAO;YACT,CAAC;YAED,IAAI,IAAI,CAAC,eAAe,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;gBACrD,IAAI,CAAC,QAAQ,CAAC;oBACZ,IAAI,EAAE,SAAS;oBACf,QAAQ,EAAE,KAAK;oBACf,GAAG,EAAE,KAAK,CAAC,GAAG;oBACd,MAAM,EAAE,KAAK,CAAC,MAAqB;iBACpC,CAAC,CAAC;YACL,CAAC;YAED,IAAI,IAAI,CAAC,aAAa,IAAI,KAAK,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;gBACjD,IAAI,CAAC,QAAQ,CAAC;oBACZ,IAAI,EAAE,OAAO;oBACb,QAAQ,EAAE,KAAK;oBACf,GAAG,EAAE,KAAK,CAAC,GAAG;oBACd,MAAM,EAAE,KAAK,CAAC,MAAqB;iBACpC,CAAC,CAAC;YACL,CAAC;QACH,CAAC,CAAC;QApDA,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;QAC3C,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;QAEzC,OAAO,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC;QACzC,OAAO,CAAC,KAAK,CAAC,OAAO,GAAG,MAAM,CAAC;QAC/B,UAAU,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,CAAG,CAAD,MAAQ,CAAC,gBAAgB,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;IACnF,CAAC;IAED,OAAO,GAAA;QACL,UAAU,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,CAAG,CAAD,GAAK,CAAC,OAAO,CAAC,mBAAmB,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;IAC3F,CAAC;IAED;;;OAGG,CACH,eAAe,CAAC,SAAiB,EAAE,OAAgB,EAAA;QACjD,IAAI,SAAS,KAAK,SAAS,EAAE,CAAC;YAC5B,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC;QACjC,CAAC;QACD,IAAI,SAAS,KAAK,OAAO,EAAE,CAAC;YAC1B,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC;QAC/B,CAAC;IACH,CAAC;CA8BF","ignoreList":[0]}},
    {"offset": {"line": 2094, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2100, "column": 0}, "map": {"version":3,"file":"contextmenu-input.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/inputs/contextmenu-input.ts"],"sourcesContent":["// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {MjolnirPointerEventRaw} from '../types';\nimport {Input, InputOptions} from './input';\n\nexport class ContextmenuInput extends Input<MjolnirPointerEventRaw, InputOptions> {\n  constructor(\n    element: HTMLElement,\n    callback: (event: MjolnirPointerEventRaw) => void,\n    options: InputOptions\n  ) {\n    super(element, callback, options);\n\n    element.addEventListener('contextmenu', this.handleEvent);\n  }\n\n  destroy() {\n    this.element.removeEventListener('contextmenu', this.handleEvent);\n  }\n\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType: string, enabled: boolean) {\n    if (eventType === 'contextmenu') {\n      this.options.enable = enabled;\n    }\n  }\n\n  handleEvent = (event: MouseEvent) => {\n    if (!this.options.enable) {\n      return;\n    }\n\n    this.callback({\n      type: 'contextmenu',\n      center: {\n        x: event.clientX,\n        y: event.clientY\n      },\n      srcEvent: event,\n      pointerType: 'mouse',\n      target: event.target as HTMLElement\n    });\n  };\n}\n"],"names":[],"mappings":"AAAA,aAAa;AACb,+BAA+B;AAC/B,oCAAoC;;;;AAGpC,OAAO,EAAC,KAAK,EAAe,mBAAgB;;AAEtC,MAAO,gBAAiB,kKAAQ,QAA2C;IAC/E,YACE,OAAoB,EACpB,QAAiD,EACjD,OAAqB,CAAA;QAErB,KAAK,CAAC,OAAO,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;QAmBpC,IAAA,CAAA,WAAW,GAAG,CAAC,KAAiB,EAAE,EAAE;YAClC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;gBACzB,OAAO;YACT,CAAC;YAED,IAAI,CAAC,QAAQ,CAAC;gBACZ,IAAI,EAAE,aAAa;gBACnB,MAAM,EAAE;oBACN,CAAC,EAAE,KAAK,CAAC,OAAO;oBAChB,CAAC,EAAE,KAAK,CAAC,OAAO;iBACjB;gBACD,QAAQ,EAAE,KAAK;gBACf,WAAW,EAAE,OAAO;gBACpB,MAAM,EAAE,KAAK,CAAC,MAAqB;aACpC,CAAC,CAAC;QACL,CAAC,CAAC;QAhCA,OAAO,CAAC,gBAAgB,CAAC,aAAa,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;IAC5D,CAAC;IAED,OAAO,GAAA;QACL,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,aAAa,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;IACpE,CAAC;IAED;;;OAGG,CACH,eAAe,CAAC,SAAiB,EAAE,OAAgB,EAAA;QACjD,IAAI,SAAS,KAAK,aAAa,EAAE,CAAC;YAChC,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC;QAChC,CAAC;IACH,CAAC;CAkBF","ignoreList":[0]}},
    {"offset": {"line": 2140, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2146, "column": 0}, "map": {"version":3,"file":"event-utils.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/utils/event-utils.ts"],"sourcesContent":["// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {MjolnirEventRaw, Point} from '../types';\nimport type {HammerEvent} from '../hammerjs/index';\n\n/* Constants */\nconst DOWN_EVENT = 1;\nconst MOVE_EVENT = 2;\nconst UP_EVENT = 4;\nconst MOUSE_EVENTS = {\n  pointerdown: DOWN_EVENT,\n  pointermove: MOVE_EVENT,\n  pointerup: UP_EVENT,\n  mousedown: DOWN_EVENT,\n  mousemove: MOVE_EVENT,\n  mouseup: UP_EVENT\n};\n\n// MouseEvent.button https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\nconst MOUSE_EVENT_BUTTON_LEFT = 0;\nconst MOUSE_EVENT_BUTTON_MIDDLE = 1;\nconst MOUSE_EVENT_BUTTON_RIGHT = 2;\n// MouseEvent.buttons https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\nconst MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;\nconst MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;\nconst MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;\n\n/**\n * Extract the involved mouse button\n */\nexport function whichButtons(event: MjolnirEventRaw): {\n  leftButton: boolean;\n  middleButton: boolean;\n  rightButton: boolean;\n} | null {\n  const eventType = MOUSE_EVENTS[event.srcEvent.type];\n  if (!eventType) {\n    // Not a mouse evet\n    return null;\n  }\n\n  const {buttons, button} = event.srcEvent as PointerEvent;\n  let leftButton = false;\n  let middleButton = false;\n  let rightButton = false;\n\n  if (eventType === MOVE_EVENT) {\n    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);\n    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);\n    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);\n  } else {\n    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;\n    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;\n    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;\n  }\n\n  return {leftButton, middleButton, rightButton};\n}\n\n/**\n * Calculate event position relative to the root element\n */\nexport function getOffsetPosition(\n  event: MjolnirEventRaw,\n  rootElement: HTMLElement\n): {\n  center: Point;\n  offsetCenter: Point;\n} | null {\n  const center = (event as HammerEvent).center;\n\n  // `center` is a hammer.js event property\n  if (!center) {\n    // Not a gestural event\n    return null;\n  }\n\n  const rect = rootElement.getBoundingClientRect();\n\n  // Fix scale for map affected by a CSS transform.\n  // See https://stackoverflow.com/a/26893663/3528533\n  const scaleX = rect.width / rootElement.offsetWidth || 1;\n  const scaleY = rect.height / rootElement.offsetHeight || 1;\n\n  // Calculate center relative to the root element\n  const offsetCenter = {\n    x: (center.x - rect.left - rootElement.clientLeft) / scaleX,\n    y: (center.y - rect.top - rootElement.clientTop) / scaleY\n  };\n\n  return {center, offsetCenter};\n}\n"],"names":[],"mappings":"AAAA,aAAa;AACb,+BAA+B;AAC/B,oCAAoC;AAKpC,aAAA,EAAe;;;;AACf,MAAM,UAAU,GAAG,CAAC,CAAC;AACrB,MAAM,UAAU,GAAG,CAAC,CAAC;AACrB,MAAM,QAAQ,GAAG,CAAC,CAAC;AACnB,MAAM,YAAY,GAAG;IACnB,WAAW,EAAE,UAAU;IACvB,WAAW,EAAE,UAAU;IACvB,SAAS,EAAE,QAAQ;IACnB,SAAS,EAAE,UAAU;IACrB,SAAS,EAAE,UAAU;IACrB,OAAO,EAAE,QAAQ;CAClB,CAAC;AAEF,uFAAuF;AACvF,MAAM,uBAAuB,GAAG,CAAC,CAAC;AAClC,MAAM,yBAAyB,GAAG,CAAC,CAAC;AACpC,MAAM,wBAAwB,GAAG,CAAC,CAAC;AACnC,yFAAyF;AACzF,MAAM,6BAA6B,GAAG,CAAC,CAAC;AACxC,MAAM,8BAA8B,GAAG,CAAC,CAAC;AACzC,MAAM,+BAA+B,GAAG,CAAC,CAAC;AAKpC,SAAU,YAAY,CAAC,KAAsB;IAKjD,MAAM,SAAS,GAAG,YAAY,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;IACpD,IAAI,CAAC,SAAS,EAAE,CAAC;QACf,mBAAmB;QACnB,OAAO,IAAI,CAAC;IACd,CAAC;IAED,MAAM,EAAC,OAAO,EAAE,MAAM,EAAC,GAAG,KAAK,CAAC,QAAwB,CAAC;IACzD,IAAI,UAAU,GAAG,KAAK,CAAC;IACvB,IAAI,YAAY,GAAG,KAAK,CAAC;IACzB,IAAI,WAAW,GAAG,KAAK,CAAC;IAExB,IAAI,SAAS,KAAK,UAAU,EAAE,CAAC;QAC7B,UAAU,GAAG,OAAO,CAAC,OAAO,GAAG,6BAA6B,CAAC,CAAC;QAC9D,YAAY,GAAG,OAAO,CAAC,OAAO,GAAG,+BAA+B,CAAC,CAAC;QAClE,WAAW,GAAG,OAAO,CAAC,OAAO,GAAG,8BAA8B,CAAC,CAAC;IAClE,CAAC,MAAM,CAAC;QACN,UAAU,GAAG,MAAM,KAAK,uBAAuB,CAAC;QAChD,YAAY,GAAG,MAAM,KAAK,yBAAyB,CAAC;QACpD,WAAW,GAAG,MAAM,KAAK,wBAAwB,CAAC;IACpD,CAAC;IAED,OAAO;QAAC,UAAU;QAAE,YAAY;QAAE,WAAW;IAAA,CAAC,CAAC;AACjD,CAAC;AAKK,SAAU,iBAAiB,CAC/B,KAAsB,EACtB,WAAwB;IAKxB,MAAM,MAAM,GAAI,KAAqB,CAAC,MAAM,CAAC;IAE7C,yCAAyC;IACzC,IAAI,CAAC,MAAM,EAAE,CAAC;QACZ,uBAAuB;QACvB,OAAO,IAAI,CAAC;IACd,CAAC;IAED,MAAM,IAAI,GAAG,WAAW,CAAC,qBAAqB,EAAE,CAAC;IAEjD,iDAAiD;IACjD,mDAAmD;IACnD,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,GAAG,WAAW,CAAC,WAAW,IAAI,CAAC,CAAC;IACzD,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,GAAG,WAAW,CAAC,YAAY,IAAI,CAAC,CAAC;IAE3D,gDAAgD;IAChD,MAAM,YAAY,GAAG;QACnB,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,GAAG,WAAW,CAAC,UAAU,CAAC,GAAG,MAAM;QAC3D,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,GAAG,WAAW,CAAC,SAAS,CAAC,GAAG,MAAM;KAC1D,CAAC;IAEF,OAAO;QAAC,MAAM;QAAE,YAAY;IAAA,CAAC,CAAC;AAChC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2219, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2225, "column": 0}, "map": {"version":3,"file":"event-registrar.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/utils/event-registrar.ts"],"sourcesContent":["// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {EventManager} from '../event-manager';\nimport {whichButtons, getOffsetPosition} from './event-utils';\nimport type {\n  MjolnirEventRaw,\n  MjolnirEventWrapper,\n  MjolnirEvent,\n  MjolnirEventHandler\n} from '../types';\n\nexport type HandlerOptions = {\n  /** Optional element from which the event is originated from.\n   * @default 'root'\n   */\n  srcElement?: 'root' | HTMLElement;\n  /** Handler with higher priority will be called first.\n   * Handler with the same priority will be called in the order of registration.\n   * @default 0\n   */\n  priority?: number;\n};\n\ntype EventHandler = {\n  type: string;\n  handler: (event: MjolnirEvent) => void;\n  once?: boolean;\n  passive?: boolean;\n  srcElement: 'root' | HTMLElement;\n  priority: number;\n};\n\nconst DEFAULT_OPTIONS: Required<HandlerOptions> = {\n  srcElement: 'root',\n  priority: 0\n};\n\nexport class EventRegistrar {\n  eventManager: EventManager;\n  recognizerName: string;\n  handlers: EventHandler[];\n  handlersByElement: Map<'root' | HTMLElement, EventHandler[]>;\n  _active: boolean;\n\n  constructor(eventManager: EventManager, recognizerName: string) {\n    this.eventManager = eventManager;\n    this.recognizerName = recognizerName;\n    this.handlers = [];\n    // Element -> handler map\n    this.handlersByElement = new Map();\n\n    this._active = false;\n  }\n\n  // Returns true if there are no non-passive handlers\n  isEmpty(): boolean {\n    return !this._active;\n  }\n\n  add(\n    type: string,\n    handler: MjolnirEventHandler,\n    options?: HandlerOptions,\n    once: boolean = false,\n    passive: boolean = false\n  ) {\n    const {handlers, handlersByElement} = this;\n    const opts: Required<HandlerOptions> = {...DEFAULT_OPTIONS, ...options};\n\n    let entries = handlersByElement.get(opts.srcElement);\n    if (!entries) {\n      entries = [];\n      handlersByElement.set(opts.srcElement, entries);\n    }\n    const entry: EventHandler = {\n      type,\n      handler,\n      srcElement: opts.srcElement,\n      priority: opts.priority\n    };\n    if (once) {\n      entry.once = true;\n    }\n    if (passive) {\n      entry.passive = true;\n    }\n    handlers.push(entry);\n    this._active = this._active || !entry.passive;\n\n    // Sort handlers by descending priority\n    // Handlers with the same priority are excuted in the order of registration\n    let insertPosition = entries.length - 1;\n    while (insertPosition >= 0) {\n      if (entries[insertPosition].priority >= entry.priority) {\n        break;\n      }\n      insertPosition--;\n    }\n    entries.splice(insertPosition + 1, 0, entry);\n  }\n\n  remove(type: string, handler: MjolnirEventHandler) {\n    const {handlers, handlersByElement} = this;\n\n    for (let i = handlers.length - 1; i >= 0; i--) {\n      const entry = handlers[i];\n\n      if (entry.type === type && entry.handler === handler) {\n        handlers.splice(i, 1);\n        const entries = handlersByElement.get(entry.srcElement)!;\n        entries.splice(entries.indexOf(entry), 1);\n        if (entries.length === 0) {\n          handlersByElement.delete(entry.srcElement);\n        }\n      }\n    }\n    this._active = handlers.some((entry) => !entry.passive);\n  }\n\n  /**\n   * Handles hammerjs event\n   */\n  handleEvent = (event: MjolnirEventRaw) => {\n    if (this.isEmpty()) {\n      return;\n    }\n\n    const mjolnirEvent = this._normalizeEvent(event);\n    let target = event.srcEvent.target as HTMLElement;\n\n    while (target && target !== mjolnirEvent.rootElement) {\n      this._emit(mjolnirEvent, target);\n      if (mjolnirEvent.handled) {\n        return;\n      }\n      target = target.parentNode as HTMLElement;\n    }\n    this._emit(mjolnirEvent, 'root');\n  };\n\n  /**\n   * Invoke handlers on a particular element\n   */\n  _emit<T extends MjolnirEventRaw>(\n    event: MjolnirEventWrapper<T>,\n    srcElement: 'root' | HTMLElement\n  ) {\n    const entries = this.handlersByElement.get(srcElement);\n\n    if (entries) {\n      let immediatePropagationStopped = false;\n\n      // Prevents the current event from bubbling up\n      const stopPropagation = () => {\n        event.handled = true;\n      };\n      // Prevent any remaining listeners from being called\n      const stopImmediatePropagation = () => {\n        event.handled = true;\n        immediatePropagationStopped = true;\n      };\n      const entriesToRemove: EventHandler[] = [];\n\n      for (let i = 0; i < entries.length; i++) {\n        const {type, handler, once} = entries[i];\n        // @ts-ignore\n        handler({\n          ...event,\n          type,\n          stopPropagation,\n          stopImmediatePropagation\n        });\n        if (once) {\n          entriesToRemove.push(entries[i]);\n        }\n        if (immediatePropagationStopped) {\n          break;\n        }\n      }\n\n      for (let i = 0; i < entriesToRemove.length; i++) {\n        const {type, handler} = entriesToRemove[i];\n        this.remove(type, handler);\n      }\n    }\n  }\n\n  /**\n   * Normalizes hammerjs and custom events to have predictable fields.\n   */\n  _normalizeEvent<T extends MjolnirEventRaw>(event: T): MjolnirEventWrapper<T> {\n    const rootElement = this.eventManager.getElement();\n\n    // @ts-ignore\n    return {\n      ...event,\n      ...whichButtons(event),\n      ...getOffsetPosition(event, rootElement!),\n      preventDefault: () => {\n        event.srcEvent.preventDefault();\n      },\n      stopImmediatePropagation: null,\n      stopPropagation: null,\n      handled: false,\n      rootElement\n    };\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2375, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2381, "column": 0}, "map": {"version":3,"file":"event-manager.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/event-manager.ts"],"sourcesContent":["// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Manager as HammerManager, Recognizer} from './hammerjs/index';\nimport type {\n  MjolnirEventRaw,\n  MjolnirEvent,\n  MjolnirEventHandler,\n  MjolnirEventHandlers\n} from './types';\n\nimport {WheelInput} from './inputs/wheel-input';\nimport {MoveInput} from './inputs/move-input';\nimport {KeyInput} from './inputs/key-input';\nimport {ContextmenuInput} from './inputs/contextmenu-input';\n\nimport {EventRegistrar, HandlerOptions} from './utils/event-registrar';\n\ntype RecognizerConstructor = {new (options: any): Recognizer};\n\ntype RecognizerTupleNormalized = {\n  recognizer: Recognizer;\n  /** Allow another gesture to be recognized simultaneously with this one.\n   * For example an interaction can trigger pinch and rotate at the same time. */\n  recognizeWith?: string[];\n  /** Another recognizer is mutually exclusive with this one.\n   * For example an interaction could be singletap or doubletap; pan-horizontal or pan-vertical; but never both. */\n  requireFailure?: string[];\n};\n\nexport type RecognizerTuple =\n  | Recognizer\n  | RecognizerConstructor\n  | RecognizerTupleNormalized\n  /** hammer.js/mjolnir.js@2 style */\n  | [\n      recognizer: RecognizerConstructor,\n      options?: any,\n      /** Allow another gesture to be recognized simultaneously with this one.\n       * For example an interaction can trigger pinch and rotate at the same time. */\n      recognizeWith?: string | string[],\n      /** Another recognizer is mutually exclusive with this one.\n       * For example an interaction could be singletap or doubletap; pan-horizontal or pan-vertical; but never both. */\n      requireFailure?: string | string[]\n    ];\n\nexport type EventManagerOptions = {\n  /** Event listeners */\n  events?: MjolnirEventHandlers;\n  /** Gesture recognizers */\n  recognizers?: RecognizerTuple[];\n  /** Touch action to set on the target element.\n   * Use 'compute' to automatically set as the least restrictive value to support the recognizers.\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action\n   * @default 'compute'\n   */\n  touchAction?: 'none' | 'compute' | 'manipulation' | 'pan-x' | 'pan-y' | 'pan-x pan-y';\n  /** Tab index of the target element */\n  tabIndex?: number;\n  /**\n   * Optional CSS properties to be applied to the target element.\n   */\n  cssProps?: Partial<CSSStyleDeclaration>;\n};\n\nfunction normalizeRecognizer(item: RecognizerTuple): RecognizerTupleNormalized {\n  if ('recognizer' in item) {\n    return item;\n  }\n  let recognizer: Recognizer;\n  const itemArray = Array.isArray(item) ? [...item] : [item];\n  if (typeof itemArray[0] === 'function') {\n    // Backward compatibility: v2 / hammerjs style\n    const RecognizerType = itemArray.shift();\n    const options = itemArray.shift() || {};\n    recognizer = new RecognizerType(options);\n  } else {\n    recognizer = itemArray.shift();\n  }\n  return {\n    recognizer,\n    recognizeWith: typeof itemArray[0] === 'string' ? [itemArray[0]] : itemArray[0],\n    requireFailure: typeof itemArray[1] === 'string' ? [itemArray[1]] : itemArray[1]\n  };\n}\n\n// Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\nexport class EventManager {\n  private element: HTMLElement | null;\n  private manager: HammerManager;\n  private options: Required<EventManagerOptions>;\n  private events: Map<string, EventRegistrar>;\n\n  // Custom handlers\n  private wheelInput: WheelInput;\n  private moveInput: MoveInput;\n  private contextmenuInput: ContextmenuInput;\n  private keyInput: KeyInput;\n\n  constructor(element: HTMLElement | null = null, options: EventManagerOptions = {}) {\n    this.options = {\n      recognizers: [],\n      events: {},\n      touchAction: 'compute',\n      tabIndex: 0,\n      cssProps: {},\n      ...options\n    };\n    this.events = new Map();\n    this.element = element;\n\n    if (!element) return;\n\n    this.manager = new HammerManager(element, this.options);\n    for (const item of this.options.recognizers) {\n      const {recognizer, recognizeWith, requireFailure} = normalizeRecognizer(item);\n      this.manager.add(recognizer);\n      if (recognizeWith) {\n        recognizer.recognizeWith(recognizeWith);\n      }\n      if (requireFailure) {\n        recognizer.requireFailure(requireFailure);\n      }\n    }\n\n    this.manager.on('hammer.input', this._onBasicInput);\n\n    // Handle events not handled by Hammer.js:\n    // - mouse wheel\n    // - pointer/touch/mouse move\n    this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.moveInput = new MoveInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.keyInput = new KeyInput(element, this._onOtherEvent, {\n      enable: false,\n      tabIndex: options.tabIndex\n    });\n    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n      enable: false\n    });\n\n    // Register all passed events.\n    this.on(this.options.events);\n  }\n\n  getElement(): HTMLElement | null {\n    return this.element;\n  }\n\n  // Tear down internal event management implementations.\n  destroy(): void {\n    // manager etc. cannot exist if there is no element\n    if (!this.element) return;\n\n    this.wheelInput.destroy();\n    this.moveInput.destroy();\n    this.keyInput.destroy();\n    this.contextmenuInput.destroy();\n    this.manager.destroy();\n  }\n\n  /** Register multiple event handlers */\n  on(events: MjolnirEventHandlers, opts?: HandlerOptions): void;\n  on<EventT extends MjolnirEvent>(\n    event: EventT['type'],\n    handler: (ev: EventT) => void,\n    opts?: HandlerOptions\n  ): void;\n\n  /** Register an event handler function to be called on `event` */\n  on(event: any, handler: any, opts?: any) {\n    this._addEventHandler(event, handler, opts, false);\n  }\n\n  /** Register an event handler function to be called on `event`, then remove it */\n  once(events: MjolnirEventHandlers, opts?: HandlerOptions): void;\n  once<EventT extends MjolnirEvent>(\n    event: EventT['type'],\n    handler: (ev: EventT) => void,\n    opts?: HandlerOptions\n  ): void;\n\n  once(event: any, handler: any, opts?: any) {\n    this._addEventHandler(event, handler, opts, true);\n  }\n\n  /** Register an event handler function to be called on `event`\n   * This handler does not ask the event to be recognized at all times.\n   * Instead, it only \"intercepts\" the event if some other handler is getting it.\n   */\n  watch(events: MjolnirEventHandlers, opts?: HandlerOptions): void;\n  watch<EventT extends MjolnirEvent>(\n    event: EventT['type'],\n    handler: (ev: EventT) => void,\n    opts?: HandlerOptions\n  ): void;\n\n  watch(event: any, handler: any, opts?: any) {\n    this._addEventHandler(event, handler, opts, false, true);\n  }\n\n  /**\n   * Deregister a previously-registered event handler.\n   */\n  off(events: MjolnirEventHandlers): void;\n  off<EventT extends MjolnirEvent>(event: EventT['type'], handler: (ev: EventT) => void): void;\n\n  off(event: any, handler?: any) {\n    this._removeEventHandler(event, handler);\n  }\n\n  /*\n   * Enable/disable recognizer for the given event\n   */\n  private _toggleRecognizer(name: string, enabled: boolean): void {\n    const {manager} = this;\n    if (!manager) {\n      return;\n    }\n    const recognizer = manager.get(name);\n    if (recognizer) {\n      recognizer.set({enable: enabled});\n      manager.touchAction.update();\n    }\n    this.wheelInput?.enableEventType(name, enabled);\n    this.moveInput?.enableEventType(name, enabled);\n    this.keyInput?.enableEventType(name, enabled);\n    this.contextmenuInput?.enableEventType(name, enabled);\n  }\n\n  /**\n   * Process the event registration for a single event + handler.\n   */\n  private _addEventHandler(\n    event: string | MjolnirEventHandlers,\n    handler: MjolnirEventHandler,\n    opts?: HandlerOptions,\n    once?: boolean,\n    passive?: boolean\n  ) {\n    if (typeof event !== 'string') {\n      // @ts-ignore\n      opts = handler;\n      // If `event` is a map, call `on()` for each entry.\n      for (const [eventName, eventHandler] of Object.entries(event)) {\n        this._addEventHandler(eventName, eventHandler, opts, once, passive);\n      }\n      return;\n    }\n\n    const {manager, events} = this;\n    if (!manager) return;\n\n    let eventRegistrar = events.get(event);\n    if (!eventRegistrar) {\n      // Enable recognizer for this event.\n      const recognizerName = this._getRecognizerName(event) || event;\n\n      eventRegistrar = new EventRegistrar(this, recognizerName);\n      events.set(event, eventRegistrar);\n      // Listen to the event\n      if (manager) {\n        manager.on(event, eventRegistrar.handleEvent);\n      }\n    }\n    eventRegistrar.add(event, handler, opts, once, passive);\n    if (!eventRegistrar.isEmpty()) {\n      this._toggleRecognizer(eventRegistrar.recognizerName, true);\n    }\n  }\n\n  /**\n   * Process the event deregistration for a single event + handler.\n   */\n  private _removeEventHandler(event: string | MjolnirEventHandlers, handler?: MjolnirEventHandler) {\n    if (typeof event !== 'string') {\n      // If `event` is a map, call `off()` for each entry.\n      for (const [eventName, eventHandler] of Object.entries(event)) {\n        this._removeEventHandler(eventName, eventHandler);\n      }\n      return;\n    }\n\n    const {events} = this;\n\n    const eventRegistrar = events.get(event);\n\n    if (!eventRegistrar) {\n      return;\n    }\n\n    eventRegistrar.remove(event, handler!);\n\n    if (eventRegistrar.isEmpty()) {\n      const {recognizerName} = eventRegistrar;\n      // Disable recognizer if no more handlers are attached to its events\n      let isRecognizerUsed = false;\n      for (const eh of events.values()) {\n        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n          isRecognizerUsed = true;\n          break;\n        }\n      }\n      if (!isRecognizerUsed) {\n        this._toggleRecognizer(recognizerName, false);\n      }\n    }\n  }\n\n  private _getRecognizerName(event: string): string | undefined {\n    return this.manager.recognizers.find((recognizer) => {\n      return recognizer.getEventNames().includes(event);\n    })?.options.event;\n  }\n\n  /**\n   * Handle basic events using the 'hammer.input' Hammer.js API:\n   * Before running Recognizers, Hammer emits a 'hammer.input' event\n   * with the basic event info. This function emits all basic events\n   * aliased to the \"class\" of event received.\n   * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n   */\n  private _onBasicInput = (event: MjolnirEventRaw) => {\n    this.manager.emit(event.srcEvent.type, event as any);\n  };\n\n  /**\n   * Handle events not supported by Hammer.js,\n   * and pipe back out through same (Hammer) channel used by other events.\n   */\n  private _onOtherEvent = (event: MjolnirEventRaw) => {\n    // console.log('onotherevent', event.type, event)\n    this.manager.emit(event.type, event as any);\n  };\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2599, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2605, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/l03542515/Documents/visioncityv1/src/frontend/node_modules/mjolnir.js/src/index.ts"],"sourcesContent":["// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport {EventManager} from './event-manager';\nexport {\n  Recognizer,\n  Pan,\n  Rotate,\n  Pinch,\n  Swipe,\n  Press,\n  Tap,\n  InputDirection,\n  InputEvent\n} from './hammerjs/index';\n\n// types\nexport type {EventManagerOptions, RecognizerTuple} from './event-manager';\nexport type {\n  MjolnirEvent,\n  MjolnirGestureEvent,\n  MjolnirKeyEvent,\n  MjolnirWheelEvent,\n  MjolnirPointerEvent\n} from './types';\n\nexport type {\n  PanRecognizerOptions,\n  RotateRecognizerOptions,\n  PinchRecognizerOptions,\n  SwipeRecognizerOptions,\n  PressRecognizerOptions,\n  TapRecognizerOptions\n} from './hammerjs/index';\n"],"names":[],"mappings":"AAAA,aAAa;AACb,+BAA+B;AAC/B,oCAAoC","ignoreList":[0]}},
    {"offset": {"line": 2612, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}