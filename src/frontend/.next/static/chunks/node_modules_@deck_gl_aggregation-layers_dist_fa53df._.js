(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@deck_gl_aggregation-layers_dist_fa53df._.js", {

"[project]/node_modules/@deck.gl/aggregation-layers/dist/common/utils/color-utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "COLOR_RANGE_FILTER": (()=>COLOR_RANGE_FILTER),
    "colorRangeToFlatArray": (()=>colorRangeToFlatArray),
    "createColorRangeTexture": (()=>createColorRangeTexture),
    "defaultColorRange": (()=>defaultColorRange),
    "updateColorRangeTexture": (()=>updateColorRangeTexture)
});
const defaultColorRange = [
    [
        255,
        255,
        178
    ],
    [
        254,
        217,
        118
    ],
    [
        254,
        178,
        76
    ],
    [
        253,
        141,
        60
    ],
    [
        240,
        59,
        32
    ],
    [
        189,
        0,
        38
    ]
];
function colorRangeToFlatArray(colorRange, normalize = false, ArrayType = Float32Array) {
    let flatArray;
    if (Number.isFinite(colorRange[0])) {
        // its already a flat array.
        flatArray = new ArrayType(colorRange);
    } else {
        // flatten it
        flatArray = new ArrayType(colorRange.length * 4);
        let index = 0;
        for(let i = 0; i < colorRange.length; i++){
            const color = colorRange[i];
            flatArray[index++] = color[0];
            flatArray[index++] = color[1];
            flatArray[index++] = color[2];
            flatArray[index++] = Number.isFinite(color[3]) ? color[3] : 255;
        }
    }
    if (normalize) {
        for(let i = 0; i < flatArray.length; i++){
            flatArray[i] /= 255;
        }
    }
    return flatArray;
}
const COLOR_RANGE_FILTER = {
    linear: 'linear',
    quantile: 'nearest',
    quantize: 'nearest',
    ordinal: 'nearest'
};
function updateColorRangeTexture(texture, type) {
    texture.setSampler({
        minFilter: COLOR_RANGE_FILTER[type],
        magFilter: COLOR_RANGE_FILTER[type]
    });
}
function createColorRangeTexture(device, colorRange, type = 'linear') {
    const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);
    return device.createTexture({
        format: 'rgba8unorm',
        mipmaps: false,
        sampler: {
            minFilter: COLOR_RANGE_FILTER[type],
            magFilter: COLOR_RANGE_FILTER[type],
            addressModeU: 'clamp-to-edge',
            addressModeV: 'clamp-to-edge'
        },
        data: colors,
        width: colors.length / 4,
        height: 1
    });
} //# sourceMappingURL=color-utils.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/triangle-layer-vertex.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Inspired by screen-grid-layer vertex shader in deck.gl
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = `\
#version 300 es
#define SHADER_NAME heatp-map-layer-vertex-shader
uniform sampler2D maxTexture;
in vec3 positions;
in vec2 texCoords;
out vec2 vTexCoords;
out float vIntensityMin;
out float vIntensityMax;
void main(void) {
gl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));
vTexCoords = texCoords;
vec4 maxTexture = texture(maxTexture, vec2(0.5));
float maxValue = triangle.aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;
float minValue = maxValue * triangle.threshold;
if (triangle.colorDomain[1] > 0.) {
maxValue = triangle.colorDomain[1];
minValue = triangle.colorDomain[0];
}
vIntensityMax = triangle.intensity / maxValue;
vIntensityMin = triangle.intensity / minValue;
}
`;
 //# sourceMappingURL=triangle-layer-vertex.glsl.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/triangle-layer-fragment.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = `\
#version 300 es
#define SHADER_NAME triangle-layer-fragment-shader
precision highp float;
uniform sampler2D weightsTexture;
uniform sampler2D colorTexture;
in vec2 vTexCoords;
in float vIntensityMin;
in float vIntensityMax;
out vec4 fragColor;
vec4 getLinearColor(float value) {
float factor = clamp(value * vIntensityMax, 0., 1.);
vec4 color = texture(colorTexture, vec2(factor, 0.5));
color.a *= min(value * vIntensityMin, 1.0);
return color;
}
void main(void) {
vec4 weights = texture(weightsTexture, vTexCoords);
float weight = weights.r;
if (triangle.aggregationMode > 0.5) {
weight /= max(1.0, weights.a);
}
if (weight <= 0.) {
discard;
}
vec4 linearColor = getLinearColor(weight);
linearColor.a *= layer.opacity;
fragColor = linearColor;
}
`;
 //# sourceMappingURL=triangle-layer-fragment.glsl.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/triangle-layer-uniforms.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "triangleUniforms": (()=>triangleUniforms)
});
const uniformBlock = `\
uniform triangleUniforms {
  float aggregationMode;
  vec2 colorDomain;
  float intensity;
  float threshold;
} triangle;
`;
const triangleUniforms = {
    name: 'triangle',
    vs: uniformBlock,
    fs: uniformBlock,
    uniformTypes: {
        aggregationMode: 'f32',
        colorDomain: 'vec2<f32>',
        intensity: 'f32',
        threshold: 'f32'
    }
}; //# sourceMappingURL=triangle-layer-uniforms.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/triangle-layer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$triangle$2d$layer$2d$vertex$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/triangle-layer-vertex.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$triangle$2d$layer$2d$fragment$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/triangle-layer-fragment.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$shaderlib$2f$project32$2f$project32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__project32$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js [app-client] (ecmascript) <export default as project32>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$triangle$2d$layer$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/triangle-layer-uniforms.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/model/model.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Layer$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/lib/layer.js [app-client] (ecmascript) <export default as Layer>");
;
;
;
;
;
class TriangleLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Layer$3e$__["Layer"] {
    getShaders() {
        return super.getShaders({
            vs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$triangle$2d$layer$2d$vertex$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
            fs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$triangle$2d$layer$2d$fragment$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
            modules: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$shaderlib$2f$project32$2f$project32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__project32$3e$__["project32"],
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$triangle$2d$layer$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["triangleUniforms"]
            ]
        });
    }
    initializeState({ device }) {
        this.setState({
            model: this._getModel(device)
        });
    }
    _getModel(device) {
        const { vertexCount, data } = this.props;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Model"](device, {
            ...this.getShaders(),
            id: this.props.id,
            attributes: data.attributes,
            bufferLayout: [
                {
                    name: 'positions',
                    format: 'float32x3'
                },
                {
                    name: 'texCoords',
                    format: 'float32x2'
                }
            ],
            topology: 'triangle-strip',
            vertexCount
        });
    }
    draw() {
        const { model } = this.state;
        const { aggregationMode, colorDomain, intensity, threshold, colorTexture, maxTexture, weightsTexture } = this.props;
        const triangleProps = {
            aggregationMode,
            colorDomain,
            intensity,
            threshold,
            colorTexture,
            maxTexture,
            weightsTexture
        };
        model.shaderInputs.setProps({
            triangle: triangleProps
        });
        model.draw(this.context.renderPass);
    }
}
TriangleLayer.layerName = 'TriangleLayer';
const __TURBOPACK__default__export__ = TriangleLayer;
 //# sourceMappingURL=triangle-layer.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/heatmap-layer-uniforms.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "maxWeightUniforms": (()=>maxWeightUniforms),
    "weightUniforms": (()=>weightUniforms)
});
const uniformBlock = `\
uniform weightUniforms {
  vec4 commonBounds;
  float radiusPixels;
  float textureWidth;
  float weightsScale;
} weight;
`;
const weightUniforms = {
    name: 'weight',
    vs: uniformBlock,
    uniformTypes: {
        commonBounds: 'vec4<f32>',
        radiusPixels: 'f32',
        textureWidth: 'f32',
        weightsScale: 'f32'
    }
};
const maxWeightUniforms = {
    name: 'maxWeight',
    vs: `\
uniform maxWeightUniforms {
  float textureSize;
} maxWeight;
`,
    uniformTypes: {
        textureSize: 'f32'
    }
}; //# sourceMappingURL=heatmap-layer-uniforms.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/weights-vs.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = `\
#version 300 es
in vec3 positions;
in vec3 positions64Low;
in float weights;
out vec4 weightsTexture;
void main()
{
weightsTexture = vec4(weights * weight.weightsScale, 0., 0., 1.);
float radiusTexels = project_pixel_size(weight.radiusPixels) * weight.textureWidth / (weight.commonBounds.z - weight.commonBounds.x);
gl_PointSize = radiusTexels * 2.;
vec3 commonPosition = project_position(positions, positions64Low);
gl_Position.xy = (commonPosition.xy - weight.commonBounds.xy) / (weight.commonBounds.zw - weight.commonBounds.xy) ;
gl_Position.xy = (gl_Position.xy * 2.) - (1.);
gl_Position.w = 1.0;
}
`;
 //# sourceMappingURL=weights-vs.glsl.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/weights-fs.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = `\
#version 300 es
in vec4 weightsTexture;
out vec4 fragColor;
float gaussianKDE(float u){
return pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);
}
void main()
{
float dist = length(gl_PointCoord - vec2(0.5, 0.5));
if (dist > 0.5) {
discard;
}
fragColor = weightsTexture * gaussianKDE(2. * dist);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
 //# sourceMappingURL=weights-fs.glsl.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/max-vs.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = `\
#version 300 es
uniform sampler2D inTexture;
out vec4 outTexture;
void main()
{
int yIndex = gl_VertexID / int(maxWeight.textureSize);
int xIndex = gl_VertexID - (yIndex * int(maxWeight.textureSize));
vec2 uv = (0.5 + vec2(float(xIndex), float(yIndex))) / maxWeight.textureSize;
outTexture = texture(inTexture, uv);
gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
gl_PointSize = 1.0;
}
`;
 //# sourceMappingURL=max-vs.glsl.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/max-fs.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = `\
#version 300 es
in vec4 outTexture;
out vec4 fragColor;
void main() {
fragColor = outTexture;
fragColor.g = outTexture.r / max(1.0, outTexture.a);
}
`;
 //# sourceMappingURL=max-fs.glsl.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/heatmap-layer-utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "boundsContain": (()=>boundsContain),
    "getBounds": (()=>getBounds),
    "getTextureCoordinates": (()=>getTextureCoordinates),
    "packVertices": (()=>packVertices),
    "scaleToAspectRatio": (()=>scaleToAspectRatio)
});
function getBounds(points) {
    // Now build bounding box in world space (aligned to world coordiante system)
    const x = points.map((p)=>p[0]);
    const y = points.map((p)=>p[1]);
    const xMin = Math.min.apply(null, x);
    const xMax = Math.max.apply(null, x);
    const yMin = Math.min.apply(null, y);
    const yMax = Math.max.apply(null, y);
    return [
        xMin,
        yMin,
        xMax,
        yMax
    ];
}
function boundsContain(currentBounds, targetBounds) {
    if (targetBounds[0] >= currentBounds[0] && targetBounds[2] <= currentBounds[2] && targetBounds[1] >= currentBounds[1] && targetBounds[3] <= currentBounds[3]) {
        return true;
    }
    return false;
}
const scratchArray = new Float32Array(12);
function packVertices(points, dimensions = 2) {
    let index = 0;
    for (const point of points){
        for(let i = 0; i < dimensions; i++){
            scratchArray[index++] = point[i] || 0;
        }
    }
    return scratchArray;
}
function scaleToAspectRatio(boundingBox, width, height) {
    const [xMin, yMin, xMax, yMax] = boundingBox;
    const currentWidth = xMax - xMin;
    const currentHeight = yMax - yMin;
    let newWidth = currentWidth;
    let newHeight = currentHeight;
    if (currentWidth / currentHeight < width / height) {
        // expand bounding box width
        newWidth = width / height * currentHeight;
    } else {
        newHeight = height / width * currentWidth;
    }
    if (newWidth < width) {
        newWidth = width;
        newHeight = height;
    }
    const xCenter = (xMax + xMin) / 2;
    const yCenter = (yMax + yMin) / 2;
    return [
        xCenter - newWidth / 2,
        yCenter - newHeight / 2,
        xCenter + newWidth / 2,
        yCenter + newHeight / 2
    ];
}
function getTextureCoordinates(point, bounds) {
    const [xMin, yMin, xMax, yMax] = bounds;
    return [
        (point[0] - xMin) / (xMax - xMin),
        (point[1] - yMin) / (yMax - yMin)
    ];
} //# sourceMappingURL=heatmap-layer-utils.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/common/utils/prop-utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "filterProps": (()=>filterProps)
});
function filterProps(props, filterKeys) {
    const filteredProps = {};
    for(const key in props){
        if (!filterKeys.includes(key)) {
            filteredProps[key] = props[key];
        }
    }
    return filteredProps;
} //# sourceMappingURL=prop-utils.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/aggregation-layer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$prop$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/utils/prop-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lifecycle$2f$props$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__compareProps__as__$5f$compareProps$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/lifecycle/props.js [app-client] (ecmascript) <export compareProps as _compareProps>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$attribute$2f$attribute$2d$manager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__AttributeManager$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/lib/attribute/attribute-manager.js [app-client] (ecmascript) <export default as AttributeManager>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$composite$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__CompositeLayer$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/lib/composite-layer.js [app-client] (ecmascript) <export default as CompositeLayer>");
;
;
/** Legacy AggregationLayer, to be removed in v9.1 */ class AggregationLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$composite$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__CompositeLayer$3e$__["CompositeLayer"] {
    initializeAggregationLayer(dimensions) {
        super.initializeState(this.context);
        this.setState({
            // Layer props , when changed doesn't require updating aggregation
            ignoreProps: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$prop$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filterProps"])(this.constructor._propTypes, dimensions.data.props),
            dimensions
        });
    }
    updateState(opts) {
        super.updateState(opts);
        const { changeFlags } = opts;
        if (changeFlags.extensionsChanged) {
            const shaders = this.getShaders({});
            if (shaders && shaders.defines) {
                shaders.defines.NON_INSTANCED_MODEL = 1;
            }
            this.updateShaders(shaders);
        }
        // Explictly call to update attributes as 'CompositeLayer' doesn't call this
        this._updateAttributes();
    }
    updateAttributes(changedAttributes) {
        // Super classes, can refer to state.changedAttributes to determine what
        // attributes changed
        this.setState({
            changedAttributes
        });
    }
    getAttributes() {
        return this.getAttributeManager().getAttributes();
    }
    getModuleSettings() {
        // For regular layer draw this happens during draw cycle (_drawLayersInViewport) not during update cycle
        // For aggregation layers this is called during updateState to update aggregation data
        // NOTE: it is similar to LayerPass._getShaderModuleProps() but doesn't inlcude `effects` it is not needed for aggregation
        const { viewport, mousePosition, device } = this.context;
        const moduleSettings = Object.assign(Object.create(this.props), {
            viewport,
            mousePosition,
            picking: {
                isActive: 0
            },
            // @ts-expect-error TODO - assuming WebGL context
            devicePixelRatio: device.canvasContext.cssToDeviceRatio()
        });
        return moduleSettings;
    }
    updateShaders(shaders) {
    // Default implemention is empty, subclasses can update their Model objects if needed
    }
    /**
     * Checks if aggregation is dirty
     * @param {Object} updateOpts - object {props, oldProps, changeFlags}
     * @param {Object} params - object {dimension, compareAll}
     * @param {Object} params.dimension - {props, accessors} array of props and/or accessors
     * @param {Boolean} params.compareAll - when `true` it will include non layer props for comparision
     * @returns {Boolean} - returns true if dimensions' prop or accessor is changed
     **/ isAggregationDirty(updateOpts, params = {}) {
        const { props, oldProps, changeFlags } = updateOpts;
        const { compareAll = false, dimension } = params;
        const { ignoreProps } = this.state;
        const { props: dataProps, accessors = [] } = dimension;
        const { updateTriggersChanged } = changeFlags;
        if (changeFlags.dataChanged) {
            return true;
        }
        if (updateTriggersChanged) {
            if (updateTriggersChanged.all) {
                return true;
            }
            for (const accessor of accessors){
                if (updateTriggersChanged[accessor]) {
                    return true;
                }
            }
        }
        if (compareAll) {
            if (changeFlags.extensionsChanged) {
                return true;
            }
            // Compare non layer props too (like extension props)
            // ignoreprops refers to all Layer props other than aggregation props that need to be comapred
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lifecycle$2f$props$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__compareProps__as__$5f$compareProps$3e$__["_compareProps"])({
                oldProps,
                newProps: props,
                ignoreProps,
                propTypes: this.constructor._propTypes
            });
        }
        // Compare props of the dimension
        for (const name of dataProps){
            if (props[name] !== oldProps[name]) {
                return true;
            }
        }
        return false;
    }
    /**
     * Checks if an attribute is changed
     * @param {String} name - name of the attribute
     * @returns {Boolean} - `true` if attribute `name` is changed, `false` otherwise,
     *                       If `name` is not passed or `undefiend`, `true` if any attribute is changed, `false` otherwise
     **/ isAttributeChanged(name) {
        const { changedAttributes } = this.state;
        if (!name) {
            // if name not specified return true if any attribute is changed
            return !isObjectEmpty(changedAttributes);
        }
        return changedAttributes && changedAttributes[name] !== undefined;
    }
    // Private
    // override Composite layer private method to create AttributeManager instance
    _getAttributeManager() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$attribute$2f$attribute$2d$manager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__AttributeManager$3e$__["AttributeManager"](this.context.device, {
            id: this.props.id,
            stats: this.context.stats
        });
    }
}
AggregationLayer.layerName = 'AggregationLayer';
const __TURBOPACK__default__export__ = AggregationLayer;
// Helper methods
// Returns true if given object is empty, false otherwise.
function isObjectEmpty(obj) {
    let isEmpty = true;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for(const key in obj){
        isEmpty = false;
        break;
    }
    return isEmpty;
} //# sourceMappingURL=aggregation-layer.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/heatmap-layer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* global setTimeout clearTimeout */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/utils/color-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$shaderlib$2f$project32$2f$project32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__project32$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js [app-client] (ecmascript) <export default as project32>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$triangle$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/triangle-layer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/lib/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$attribute$2f$attribute$2d$manager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__AttributeManager$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/lib/attribute/attribute-manager.js [app-client] (ecmascript) <export default as AttributeManager>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__log$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/utils/log.js [app-client] (ecmascript) <export default as log>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$compute$2f$texture$2d$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/compute/texture-transform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$heatmap$2d$layer$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/heatmap-layer-uniforms.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$weights$2d$vs$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/weights-vs.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$weights$2d$fs$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/weights-fs.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$max$2d$vs$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/max-vs.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$max$2d$fs$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/max-fs.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$heatmap$2d$layer$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/heatmap-layer-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$aggregation$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/aggregation-layer.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
const RESOLUTION = 2; // (number of common space pixels) / (number texels)
const TEXTURE_PROPS = {
    format: 'rgba8unorm',
    mipmaps: false,
    sampler: {
        minFilter: 'linear',
        magFilter: 'linear',
        addressModeU: 'clamp-to-edge',
        addressModeV: 'clamp-to-edge'
    }
};
const DEFAULT_COLOR_DOMAIN = [
    0,
    0
];
const AGGREGATION_MODE = {
    SUM: 0,
    MEAN: 1
};
const defaultProps = {
    getPosition: {
        type: 'accessor',
        value: (x)=>x.position
    },
    getWeight: {
        type: 'accessor',
        value: 1
    },
    intensity: {
        type: 'number',
        min: 0,
        value: 1
    },
    radiusPixels: {
        type: 'number',
        min: 1,
        max: 100,
        value: 50
    },
    colorRange: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultColorRange"],
    threshold: {
        type: 'number',
        min: 0,
        max: 1,
        value: 0.05
    },
    colorDomain: {
        type: 'array',
        value: null,
        optional: true
    },
    // 'SUM' or 'MEAN'
    aggregation: 'SUM',
    weightsTextureSize: {
        type: 'number',
        min: 128,
        max: 2048,
        value: 2048
    },
    debounceTimeout: {
        type: 'number',
        min: 0,
        max: 1000,
        value: 500
    }
};
const FLOAT_TARGET_FEATURES = [
    'float32-renderable-webgl',
    'texture-blend-float-webgl' // ability to blend when rendering to float texture
];
const DIMENSIONS = {
    data: {
        props: [
            'radiusPixels'
        ]
    }
};
/** Visualizes the spatial distribution of data. */ class HeatmapLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$aggregation$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    getShaders(shaders) {
        let modules = [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$shaderlib$2f$project32$2f$project32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__project32$3e$__["project32"]
        ];
        if (shaders.modules) {
            modules = [
                ...modules,
                ...shaders.modules
            ];
        }
        return super.getShaders({
            ...shaders,
            modules
        });
    }
    initializeState() {
        super.initializeAggregationLayer(DIMENSIONS);
        this.setState({
            colorDomain: DEFAULT_COLOR_DOMAIN
        });
        this._setupTextureParams();
        this._setupAttributes();
        this._setupResources();
    }
    shouldUpdateState({ changeFlags }) {
        // Need to be updated when viewport changes
        return changeFlags.somethingChanged;
    }
    /* eslint-disable max-statements,complexity */ updateState(opts) {
        super.updateState(opts);
        this._updateHeatmapState(opts);
    }
    _updateHeatmapState(opts) {
        const { props, oldProps } = opts;
        const changeFlags = this._getChangeFlags(opts);
        if (changeFlags.dataChanged || changeFlags.viewportChanged) {
            // if data is changed, do not debounce and immediately update the weight map
            changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);
            this._updateTextureRenderingBounds();
        }
        if (changeFlags.dataChanged || changeFlags.boundsChanged) {
            // Update weight map immediately
            clearTimeout(this.state.updateTimer);
            this.setState({
                isWeightMapDirty: true
            });
        } else if (changeFlags.viewportZoomChanged) {
            // Update weight map when zoom stops
            this._debouncedUpdateWeightmap();
        }
        if (props.colorRange !== oldProps.colorRange) {
            this._updateColorTexture(opts);
        }
        if (this.state.isWeightMapDirty) {
            this._updateWeightmap();
        }
        this.setState({
            zoom: opts.context.viewport.zoom
        });
    }
    renderLayers() {
        const { weightsTexture, triPositionBuffer, triTexCoordBuffer, maxWeightsTexture, colorTexture, colorDomain } = this.state;
        const { updateTriggers, intensity, threshold, aggregation } = this.props;
        const TriangleLayerClass = this.getSubLayerClass('triangle', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$triangle$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
        return new TriangleLayerClass(this.getSubLayerProps({
            id: 'triangle-layer',
            updateTriggers
        }), {
            // position buffer is filled with world coordinates generated from viewport.unproject
            // i.e. LNGLAT if geospatial, CARTESIAN otherwise
            coordinateSystem: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COORDINATE_SYSTEM"].DEFAULT,
            data: {
                attributes: {
                    positions: triPositionBuffer,
                    texCoords: triTexCoordBuffer
                }
            },
            vertexCount: 4,
            maxTexture: maxWeightsTexture,
            colorTexture,
            aggregationMode: AGGREGATION_MODE[aggregation] || 0,
            weightsTexture,
            intensity,
            threshold,
            colorDomain
        });
    }
    finalizeState(context) {
        super.finalizeState(context);
        const { weightsTransform, weightsTexture, maxWeightTransform, maxWeightsTexture, triPositionBuffer, triTexCoordBuffer, colorTexture, updateTimer } = this.state;
        weightsTransform?.destroy();
        weightsTexture?.destroy();
        maxWeightTransform?.destroy();
        maxWeightsTexture?.destroy();
        triPositionBuffer?.destroy();
        triTexCoordBuffer?.destroy();
        colorTexture?.destroy();
        if (updateTimer) {
            clearTimeout(updateTimer);
        }
    }
    // PRIVATE
    // override Composite layer private method to create AttributeManager instance
    _getAttributeManager() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$attribute$2f$attribute$2d$manager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__AttributeManager$3e$__["AttributeManager"](this.context.device, {
            id: this.props.id,
            stats: this.context.stats
        });
    }
    _getChangeFlags(opts) {
        const changeFlags = {};
        const { dimensions } = this.state;
        changeFlags.dataChanged = this.isAttributeChanged() && 'attribute changed' || this.isAggregationDirty(opts, {
            compareAll: true,
            dimension: dimensions.data
        }) && 'aggregation is dirty';
        changeFlags.viewportChanged = opts.changeFlags.viewportChanged;
        const { zoom } = this.state;
        if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {
            changeFlags.viewportZoomChanged = true;
        }
        return changeFlags;
    }
    _createTextures() {
        const { textureSize, format } = this.state;
        this.setState({
            weightsTexture: this.context.device.createTexture({
                ...TEXTURE_PROPS,
                width: textureSize,
                height: textureSize,
                format
            }),
            maxWeightsTexture: this.context.device.createTexture({
                ...TEXTURE_PROPS,
                width: 1,
                height: 1,
                format
            })
        });
    }
    _setupAttributes() {
        const attributeManager = this.getAttributeManager();
        attributeManager.add({
            positions: {
                size: 3,
                type: 'float64',
                accessor: 'getPosition'
            },
            weights: {
                size: 1,
                accessor: 'getWeight'
            }
        });
        this.setState({
            positionAttributeName: 'positions'
        });
    }
    _setupTextureParams() {
        const { device } = this.context;
        const { weightsTextureSize } = this.props;
        const textureSize = Math.min(weightsTextureSize, device.limits.maxTextureDimension2D);
        const floatTargetSupport = FLOAT_TARGET_FEATURES.every((feature)=>device.features.has(feature));
        const format = floatTargetSupport ? 'rgba32float' : 'rgba8unorm';
        const weightsScale = floatTargetSupport ? 1 : 1 / 255;
        this.setState({
            textureSize,
            format,
            weightsScale
        });
        if (!floatTargetSupport) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__log$3e$__["log"].warn(`HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`)();
        }
    }
    _createWeightsTransform(shaders) {
        let { weightsTransform } = this.state;
        const { weightsTexture } = this.state;
        const attributeManager = this.getAttributeManager();
        weightsTransform?.destroy();
        weightsTransform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$compute$2f$texture$2d$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureTransform"](this.context.device, {
            id: `${this.id}-weights-transform`,
            bufferLayout: attributeManager.getBufferLayouts(),
            vertexCount: 1,
            targetTexture: weightsTexture,
            parameters: {
                depthWriteEnabled: false,
                blendColorOperation: 'add',
                blendColorSrcFactor: 'one',
                blendColorDstFactor: 'one',
                blendAlphaSrcFactor: 'one',
                blendAlphaDstFactor: 'one'
            },
            topology: 'point-list',
            ...shaders,
            modules: [
                ...shaders.modules,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$heatmap$2d$layer$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weightUniforms"]
            ]
        });
        this.setState({
            weightsTransform
        });
    }
    _setupResources() {
        this._createTextures();
        const { device } = this.context;
        const { textureSize, weightsTexture, maxWeightsTexture } = this.state;
        const weightsTransformShaders = this.getShaders({
            vs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$weights$2d$vs$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
            fs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$weights$2d$fs$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
        });
        this._createWeightsTransform(weightsTransformShaders);
        const maxWeightsTransformShaders = this.getShaders({
            vs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$max$2d$vs$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
            fs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$max$2d$fs$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
            modules: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$heatmap$2d$layer$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["maxWeightUniforms"]
            ]
        });
        const maxWeightTransform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$compute$2f$texture$2d$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureTransform"](device, {
            id: `${this.id}-max-weights-transform`,
            targetTexture: maxWeightsTexture,
            ...maxWeightsTransformShaders,
            vertexCount: textureSize * textureSize,
            topology: 'point-list',
            parameters: {
                depthWriteEnabled: false,
                blendColorOperation: 'max',
                blendAlphaOperation: 'max',
                blendColorSrcFactor: 'one',
                blendColorDstFactor: 'one',
                blendAlphaSrcFactor: 'one',
                blendAlphaDstFactor: 'one'
            }
        });
        const maxWeightProps = {
            inTexture: weightsTexture,
            textureSize
        };
        maxWeightTransform.model.shaderInputs.setProps({
            maxWeight: maxWeightProps
        });
        this.setState({
            weightsTexture,
            maxWeightsTexture,
            maxWeightTransform,
            zoom: null,
            triPositionBuffer: device.createBuffer({
                byteLength: 48
            }),
            triTexCoordBuffer: device.createBuffer({
                byteLength: 48
            })
        });
    }
    // overwrite super class method to update transform model
    updateShaders(shaderOptions) {
        // shader params (modules, injects) changed, update model object
        this._createWeightsTransform({
            vs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$weights$2d$vs$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
            fs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$weights$2d$fs$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
            ...shaderOptions
        });
    }
    _updateMaxWeightValue() {
        const { maxWeightTransform } = this.state;
        maxWeightTransform.run({
            parameters: {
                viewport: [
                    0,
                    0,
                    1,
                    1
                ]
            },
            clearColor: [
                0,
                0,
                0,
                0
            ]
        });
    }
    // Computes world bounds area that needs to be processed for generate heatmap
    _updateBounds(forceUpdate = false) {
        const { viewport } = this.context;
        // Unproject all 4 corners of the current screen coordinates into world coordinates (lng/lat)
        // Takes care of viewport has non zero bearing/pitch (i.e axis not aligned with world coordiante system)
        const viewportCorners = [
            viewport.unproject([
                0,
                0
            ]),
            viewport.unproject([
                viewport.width,
                0
            ]),
            viewport.unproject([
                0,
                viewport.height
            ]),
            viewport.unproject([
                viewport.width,
                viewport.height
            ])
        ].map((p)=>p.map(Math.fround));
        // #1: get world bounds for current viewport extends
        const visibleWorldBounds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$heatmap$2d$layer$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBounds"])(viewportCorners); // TODO: Change to visible bounds
        const newState = {
            visibleWorldBounds,
            viewportCorners
        };
        let boundsChanged = false;
        if (forceUpdate || !this.state.worldBounds || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$heatmap$2d$layer$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boundsContain"])(this.state.worldBounds, visibleWorldBounds)) {
            // #2 : convert world bounds to common (Flat) bounds
            // #3 : extend common bounds to match aspect ratio with viewport
            const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);
            // #4 :convert aligned common bounds to world bounds
            const worldBounds = this._commonToWorldBounds(scaledCommonBounds);
            // Clip webmercator projection limits
            if (this.props.coordinateSystem === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COORDINATE_SYSTEM"].LNGLAT) {
                worldBounds[1] = Math.max(worldBounds[1], -85.051129);
                worldBounds[3] = Math.min(worldBounds[3], 85.051129);
                worldBounds[0] = Math.max(worldBounds[0], -360);
                worldBounds[2] = Math.min(worldBounds[2], 360);
            }
            // #5: now convert world bounds to common using Layer's coordiante system and origin
            const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);
            newState.worldBounds = worldBounds;
            newState.normalizedCommonBounds = normalizedCommonBounds;
            boundsChanged = true;
        }
        this.setState(newState);
        return boundsChanged;
    }
    _updateTextureRenderingBounds() {
        // Just render visible portion of the texture
        const { triPositionBuffer, triTexCoordBuffer, normalizedCommonBounds, viewportCorners } = this.state;
        const { viewport } = this.context;
        triPositionBuffer.write((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$heatmap$2d$layer$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["packVertices"])(viewportCorners, 3));
        const textureBounds = viewportCorners.map((p)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$heatmap$2d$layer$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTextureCoordinates"])(viewport.projectPosition(p), normalizedCommonBounds));
        triTexCoordBuffer.write((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$heatmap$2d$layer$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["packVertices"])(textureBounds, 2));
    }
    _updateColorTexture(opts) {
        const { colorRange } = opts.props;
        let { colorTexture } = this.state;
        const colors = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colorRangeToFlatArray"])(colorRange, false, Uint8Array);
        if (colorTexture && colorTexture?.width === colorRange.length) {
            // TODO(v9): Unclear whether `setSubImageData` is a public API, or what to use if not.
            colorTexture.setTexture2DData({
                data: colors
            });
        } else {
            colorTexture?.destroy();
            // @ts-expect-error TODO(ib) - texture API change
            colorTexture = this.context.device.createTexture({
                ...TEXTURE_PROPS,
                data: colors,
                width: colorRange.length,
                height: 1
            });
        }
        this.setState({
            colorTexture
        });
    }
    _updateWeightmap() {
        const { radiusPixels, colorDomain, aggregation } = this.props;
        const { worldBounds, textureSize, weightsScale, weightsTexture } = this.state;
        const weightsTransform = this.state.weightsTransform;
        this.state.isWeightMapDirty = false;
        // convert world bounds to common using Layer's coordiante system and origin
        const commonBounds = this._worldToCommonBounds(worldBounds, {
            useLayerCoordinateSystem: true
        });
        if (colorDomain && aggregation === 'SUM') {
            // scale color domain to weight per pixel
            const { viewport } = this.context;
            const metersPerPixel = viewport.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0]) / textureSize;
            this.state.colorDomain = colorDomain.map((x)=>x * metersPerPixel * weightsScale);
        } else {
            this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;
        }
        const attributeManager = this.getAttributeManager();
        const attributes = attributeManager.getAttributes();
        const moduleSettings = this.getModuleSettings();
        this._setModelAttributes(weightsTransform.model, attributes);
        weightsTransform.model.setVertexCount(this.getNumInstances());
        const weightProps = {
            radiusPixels,
            commonBounds,
            textureWidth: textureSize,
            weightsScale,
            weightsTexture: weightsTexture
        };
        const { viewport, devicePixelRatio, coordinateSystem, coordinateOrigin } = moduleSettings;
        const { modelMatrix } = this.props;
        weightsTransform.model.shaderInputs.setProps({
            project: {
                viewport,
                devicePixelRatio,
                modelMatrix,
                coordinateSystem,
                coordinateOrigin
            },
            weight: weightProps
        });
        weightsTransform.run({
            parameters: {
                viewport: [
                    0,
                    0,
                    textureSize,
                    textureSize
                ]
            },
            clearColor: [
                0,
                0,
                0,
                0
            ]
        });
        this._updateMaxWeightValue();
    }
    _debouncedUpdateWeightmap(fromTimer = false) {
        let { updateTimer } = this.state;
        const { debounceTimeout } = this.props;
        if (fromTimer) {
            updateTimer = null;
            // update
            this._updateBounds(true);
            this._updateTextureRenderingBounds();
            this.setState({
                isWeightMapDirty: true
            });
        } else {
            this.setState({
                isWeightMapDirty: false
            });
            clearTimeout(updateTimer);
            updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);
        }
        this.setState({
            updateTimer
        });
    }
    // input: worldBounds: [minLong, minLat, maxLong, maxLat]
    // input: opts.useLayerCoordinateSystem : layers coordiante system is used
    // optput: commonBounds: [minX, minY, maxX, maxY] scaled to fit the current texture
    _worldToCommonBounds(worldBounds, opts = {}) {
        const { useLayerCoordinateSystem = false } = opts;
        const [minLong, minLat, maxLong, maxLat] = worldBounds;
        const { viewport } = this.context;
        const { textureSize } = this.state;
        const { coordinateSystem } = this.props;
        const offsetMode = useLayerCoordinateSystem && (coordinateSystem === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COORDINATE_SYSTEM"].LNGLAT_OFFSETS || coordinateSystem === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COORDINATE_SYSTEM"].METER_OFFSETS);
        const offsetOriginCommon = offsetMode ? viewport.projectPosition(this.props.coordinateOrigin) : [
            0,
            0
        ];
        const size = textureSize * RESOLUTION / viewport.scale;
        let bottomLeftCommon;
        let topRightCommon;
        // Y-axis is flipped between World and Common bounds
        if (useLayerCoordinateSystem && !offsetMode) {
            bottomLeftCommon = this.projectPosition([
                minLong,
                minLat,
                0
            ]);
            topRightCommon = this.projectPosition([
                maxLong,
                maxLat,
                0
            ]);
        } else {
            bottomLeftCommon = viewport.projectPosition([
                minLong,
                minLat,
                0
            ]);
            topRightCommon = viewport.projectPosition([
                maxLong,
                maxLat,
                0
            ]);
        }
        // Ignore z component
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$heatmap$2d$layer$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scaleToAspectRatio"])([
            bottomLeftCommon[0] - offsetOriginCommon[0],
            bottomLeftCommon[1] - offsetOriginCommon[1],
            topRightCommon[0] - offsetOriginCommon[0],
            topRightCommon[1] - offsetOriginCommon[1]
        ], size, size);
    }
    // input commonBounds: [xMin, yMin, xMax, yMax]
    // output worldBounds: [minLong, minLat, maxLong, maxLat]
    _commonToWorldBounds(commonBounds) {
        const [xMin, yMin, xMax, yMax] = commonBounds;
        const { viewport } = this.context;
        const bottomLeftWorld = viewport.unprojectPosition([
            xMin,
            yMin
        ]);
        const topRightWorld = viewport.unprojectPosition([
            xMax,
            yMax
        ]);
        return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));
    }
}
HeatmapLayer.layerName = 'HeatmapLayer';
HeatmapLayer.defaultProps = defaultProps;
const __TURBOPACK__default__export__ = HeatmapLayer;
 //# sourceMappingURL=heatmap-layer.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/heatmap-layer.js [app-client] (ecmascript) <export default as HeatmapLayer>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "HeatmapLayer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$heatmap$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$heatmap$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/heatmap-layer.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/cpu-aggregator/sort-bins.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** Group data points into bins */ __turbopack_esm__({
    "packBinIds": (()=>packBinIds),
    "sortBins": (()=>sortBins)
});
function sortBins({ pointCount, getBinId }) {
    const binsById = new Map();
    for(let i = 0; i < pointCount; i++){
        const id = getBinId(i);
        if (id === null) {
            continue;
        }
        let bin = binsById.get(String(id));
        if (bin) {
            bin.points.push(i);
        } else {
            bin = {
                id,
                index: binsById.size,
                points: [
                    i
                ]
            };
            binsById.set(String(id), bin);
        }
    }
    return Array.from(binsById.values());
}
function packBinIds({ bins, dimensions, target }) {
    const targetLength = bins.length * dimensions;
    if (!target || target.length < targetLength) {
        target = new Float32Array(targetLength);
    }
    for(let i = 0; i < bins.length; i++){
        const { id } = bins[i];
        if (Array.isArray(id)) {
            target.set(id, i * dimensions);
        } else {
            target[i] = id;
        }
    }
    return target;
} //# sourceMappingURL=sort-bins.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/cpu-aggregator/vertex-accessor.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** Evaluate a VertexAccessor with a set of attributes */ __turbopack_esm__({
    "evaluateVertexAccessor": (()=>evaluateVertexAccessor)
});
function evaluateVertexAccessor(accessor, attributes, options) {
    const vertexReaders = {};
    for (const id of accessor.sources || []){
        const attribute = attributes[id];
        if (attribute) {
            vertexReaders[id] = getVertexReader(attribute);
        } else {
            throw new Error(`Cannot find attribute ${id}`);
        }
    }
    const data = {};
    return (vertexIndex)=>{
        for(const id in vertexReaders){
            data[id] = vertexReaders[id](vertexIndex);
        }
        return accessor.getValue(data, vertexIndex, options);
    };
}
/** Read value out of a deck.gl Attribute by vertex */ function getVertexReader(attribute) {
    const value = attribute.value;
    const { offset = 0, stride, size } = attribute.getAccessor();
    const bytesPerElement = value.BYTES_PER_ELEMENT;
    const elementOffset = offset / bytesPerElement;
    const elementStride = stride ? stride / bytesPerElement : size;
    if (size === 1) {
        // Size 1, returns (i: number) => number
        if (attribute.isConstant) {
            return ()=>value[0];
        }
        return (vertexIndex)=>{
            const i = elementOffset + elementStride * vertexIndex;
            return value[i];
        };
    }
    // Size >1, returns (i: number) => number[]
    let result;
    if (attribute.isConstant) {
        result = Array.from(value);
        return ()=>result;
    }
    result = new Array(size);
    return (vertexIndex)=>{
        const i = elementOffset + elementStride * vertexIndex;
        for(let j = 0; j < size; j++){
            result[j] = value[i + j];
        }
        return result;
    };
} //# sourceMappingURL=vertex-accessor.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/cpu-aggregator/aggregate.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "BUILT_IN_OPERATIONS": (()=>BUILT_IN_OPERATIONS),
    "aggregate": (()=>aggregate)
});
const count = (pointIndices)=>{
    return pointIndices.length;
};
const sum = (pointIndices, getValue)=>{
    let result = 0;
    for (const i of pointIndices){
        result += getValue(i);
    }
    return result;
};
const mean = (pointIndices, getValue)=>{
    if (pointIndices.length === 0) {
        return NaN;
    }
    return sum(pointIndices, getValue) / pointIndices.length;
};
const min = (pointIndices, getValue)=>{
    let result = Infinity;
    for (const i of pointIndices){
        const value = getValue(i);
        if (value < result) {
            result = value;
        }
    }
    return result;
};
const max = (pointIndices, getValue)=>{
    let result = -Infinity;
    for (const i of pointIndices){
        const value = getValue(i);
        if (value > result) {
            result = value;
        }
    }
    return result;
};
const BUILT_IN_OPERATIONS = {
    COUNT: count,
    SUM: sum,
    MEAN: mean,
    MIN: min,
    MAX: max
};
function aggregate({ bins, getValue, operation, target }) {
    if (!target || target.length < bins.length) {
        target = new Float32Array(bins.length);
    }
    let min = Infinity;
    let max = -Infinity;
    for(let j = 0; j < bins.length; j++){
        const { points } = bins[j];
        target[j] = operation(points, getValue);
        if (target[j] < min) min = target[j];
        if (target[j] > max) max = target[j];
    }
    return {
        value: target,
        domain: [
            min,
            max
        ]
    };
} //# sourceMappingURL=aggregate.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/cpu-aggregator/cpu-aggregator.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "CPUAggregator": (()=>CPUAggregator)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__deepEqual__as__$5f$deepEqual$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/utils/deep-equal.js [app-client] (ecmascript) <export deepEqual as _deepEqual>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$sort$2d$bins$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/cpu-aggregator/sort-bins.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$vertex$2d$accessor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/cpu-aggregator/vertex-accessor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$aggregate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/cpu-aggregator/aggregate.js [app-client] (ecmascript)");
;
;
;
;
class CPUAggregator {
    constructor(props){
        this.bins = [];
        this.binIds = null;
        this.results = [];
        this.dimensions = props.dimensions;
        this.channelCount = props.getValue.length;
        this.props = {
            ...props,
            binOptions: {},
            pointCount: 0,
            operations: [],
            customOperations: [],
            attributes: {}
        };
        this.needsUpdate = true;
        this.setProps(props);
    }
    destroy() {}
    get binCount() {
        return this.bins.length;
    }
    /** Update aggregation props */ setProps(props) {
        const oldProps = this.props;
        if (props.binOptions) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__deepEqual__as__$5f$deepEqual$3e$__["_deepEqual"])(props.binOptions, oldProps.binOptions, 2)) {
                this.setNeedsUpdate();
            }
        }
        if (props.operations) {
            for(let channel = 0; channel < this.channelCount; channel++){
                if (props.operations[channel] !== oldProps.operations[channel]) {
                    this.setNeedsUpdate(channel);
                }
            }
        }
        if (props.customOperations) {
            for(let channel = 0; channel < this.channelCount; channel++){
                if (Boolean(props.customOperations[channel]) !== Boolean(oldProps.customOperations[channel])) {
                    this.setNeedsUpdate(channel);
                }
            }
        }
        if (props.pointCount !== undefined && props.pointCount !== oldProps.pointCount) {
            this.setNeedsUpdate();
        }
        if (props.attributes) {
            props.attributes = {
                ...oldProps.attributes,
                ...props.attributes
            };
        }
        Object.assign(this.props, props);
    }
    /** Flags a channel to need update
     * This is called internally by setProps() if certain props change
     * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed
     * the underlying buffers could have been updated and require rerunning the aggregation
     * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.
     */ setNeedsUpdate(channel) {
        if (channel === undefined) {
            this.needsUpdate = true;
        } else if (this.needsUpdate !== true) {
            this.needsUpdate = this.needsUpdate || [];
            this.needsUpdate[channel] = true;
        }
    }
    /** Run aggregation */ update() {
        if (this.needsUpdate === true) {
            this.bins = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$sort$2d$bins$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sortBins"])({
                pointCount: this.props.pointCount,
                getBinId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$vertex$2d$accessor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["evaluateVertexAccessor"])(this.props.getBin, this.props.attributes, this.props.binOptions)
            });
            const value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$sort$2d$bins$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["packBinIds"])({
                bins: this.bins,
                dimensions: this.dimensions,
                // Reuse allocated typed array
                target: this.binIds?.value
            });
            this.binIds = {
                value,
                type: 'float32',
                size: this.dimensions
            };
        }
        for(let channel = 0; channel < this.channelCount; channel++){
            if (this.needsUpdate === true || this.needsUpdate[channel]) {
                const operation = this.props.customOperations[channel] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$aggregate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BUILT_IN_OPERATIONS"][this.props.operations[channel]];
                const { value, domain } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$aggregate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aggregate"])({
                    bins: this.bins,
                    getValue: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$vertex$2d$accessor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["evaluateVertexAccessor"])(this.props.getValue[channel], this.props.attributes, undefined),
                    operation,
                    // Reuse allocated typed array
                    target: this.results[channel]?.value
                });
                this.results[channel] = {
                    value,
                    domain,
                    type: 'float32',
                    size: 1
                };
                this.props.onUpdate?.({
                    channel
                });
            }
        }
        this.needsUpdate = false;
    }
    preDraw() {}
    /** Returns an accessor to the bins. */ getBins() {
        return this.binIds;
    }
    /** Returns an accessor to the output for a given channel. */ getResult(channel) {
        return this.results[channel];
    }
    /** Returns the [min, max] of aggregated values for a given channel. */ getResultDomain(channel) {
        return this.results[channel]?.domain ?? [
            Infinity,
            -Infinity
        ];
    }
    /** Returns the information for a given bin. */ getBin(index) {
        const bin = this.bins[index];
        if (!bin) {
            return null;
        }
        const value = new Array(this.channelCount);
        for(let i = 0; i < value.length; i++){
            const result = this.results[i];
            value[i] = result?.value[index];
        }
        return {
            id: bin.id,
            value,
            count: bin.points.length,
            pointIndices: bin.points
        };
    }
} //# sourceMappingURL=cpu-aggregator.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 * Create a float texture to store aggregation result
 */ __turbopack_esm__({
    "createRenderTarget": (()=>createRenderTarget)
});
function createRenderTarget(device, width, height) {
    return device.createFramebuffer({
        width,
        height,
        colorAttachments: [
            device.createTexture({
                width,
                height,
                format: 'rgba32float',
                mipmaps: false,
                sampler: {
                    minFilter: 'nearest',
                    magFilter: 'nearest'
                }
            })
        ]
    });
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/bin-sorter-uniforms.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "binSorterUniforms": (()=>binSorterUniforms)
});
const uniformBlock = /* glsl */ `\
uniform binSorterUniforms {
  ivec4 binIdRange;
  ivec2 targetSize;
} binSorter;
`;
const binSorterUniforms = {
    name: 'binSorter',
    vs: uniformBlock,
    uniformTypes: {
        binIdRange: 'vec4<i32>',
        targetSize: 'vec2<i32>'
    }
}; //# sourceMappingURL=bin-sorter-uniforms.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/webgl-bin-sorter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "TEXTURE_WIDTH": (()=>TEXTURE_WIDTH),
    "WebGLBinSorter": (()=>WebGLBinSorter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/model/model.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$bin$2d$sorter$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/bin-sorter-uniforms.js [app-client] (ecmascript)");
;
;
;
const COLOR_CHANNELS = [
    0x1,
    0x2,
    0x4,
    0x8
]; // GPU color mask RED, GREEN, BLUE, ALPHA
const MAX_FLOAT32 = 3e38;
const EMPTY_MASKS = {
    SUM: 0,
    MEAN: 0,
    MIN: 0,
    MAX: 0,
    COUNT: 0
};
const TEXTURE_WIDTH = 1024;
class WebGLBinSorter {
    constructor(device, props){
        /**
         * A packed texture in which each pixel represents a bin.
         * The index of the pixel in the memory layout is the bin index.
         * Alpha value is the count of data points that fall into this bin
         * R,G,B values are the aggregated values of each channel:
         *   - Sum of all data points if operation is 'SUM', or 'MEAN'
         *   - Min of all data points if operation is 'MIN'
         *   - Max of all data points if operation is 'MAX'
         */ this.binsFBO = null;
        this.device = device;
        this.model = createModel(device, props);
    }
    get texture() {
        return this.binsFBO ? this.binsFBO.colorAttachments[0].texture : null;
    }
    destroy() {
        this.model.destroy();
        this.binsFBO?.colorAttachments[0].texture.destroy();
        this.binsFBO?.destroy();
    }
    getBinValues(index) {
        if (!this.binsFBO) {
            return null;
        }
        const x = index % TEXTURE_WIDTH;
        const y = Math.floor(index / TEXTURE_WIDTH);
        const buffer = this.device.readPixelsToArrayWebGL(this.binsFBO, {
            sourceX: x,
            sourceY: y,
            sourceWidth: 1,
            sourceHeight: 1
        }).buffer;
        return new Float32Array(buffer);
    }
    setDimensions(binCount, binIdRange) {
        const width = TEXTURE_WIDTH;
        const height = Math.ceil(binCount / width);
        // Only destroy existing texture if it is not large enough
        if (!this.binsFBO) {
            this.binsFBO = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createRenderTarget"])(this.device, width, height);
        } else if (this.binsFBO.height < height) {
            this.binsFBO.resize({
                width,
                height
            });
        }
        const binSorterProps = {
            binIdRange: [
                binIdRange[0][0],
                binIdRange[0][1],
                binIdRange[1]?.[0] || 0,
                binIdRange[1]?.[1] || 0
            ],
            targetSize: [
                this.binsFBO.width,
                this.binsFBO.height
            ]
        };
        this.model.shaderInputs.setProps({
            binSorter: binSorterProps
        });
    }
    setModelProps(props) {
        const model = this.model;
        if (props.attributes) {
            model.setAttributes(props.attributes);
        }
        if (props.constantAttributes) {
            model.setConstantAttributes(props.constantAttributes);
        }
        if (props.vertexCount !== undefined) {
            model.setVertexCount(props.vertexCount);
        }
        if (props.shaderModuleProps) {
            model.shaderInputs.setProps(props.shaderModuleProps);
        }
    }
    /** Update aggregation */ update(/** The aggregation operation for each channel. Use null to skip update. */ operations) {
        if (!this.binsFBO) {
            return;
        }
        const masks = getMaskByOperation(operations);
        this._updateBins('SUM', masks.SUM + masks.MEAN);
        this._updateBins('MIN', masks.MIN);
        this._updateBins('MAX', masks.MAX);
    }
    /** Recalculate aggregation on the given channels using the given operation */ _updateBins(operation, /** GPU bit mask of one or more channels that should be updated */ colorMask) {
        if (colorMask === 0) {
            return;
        }
        colorMask |= COLOR_CHANNELS[3]; // Also renders to the alpha channel (point count)
        const model = this.model;
        const target = this.binsFBO;
        const initialValue = operation === 'MAX' ? -MAX_FLOAT32 : operation === 'MIN' ? MAX_FLOAT32 : 0;
        const renderPass = this.device.beginRenderPass({
            id: `gpu-aggregation-${operation}`,
            framebuffer: target,
            parameters: {
                viewport: [
                    0,
                    0,
                    target.width,
                    target.height
                ],
                colorMask
            },
            clearColor: [
                initialValue,
                initialValue,
                initialValue,
                0
            ],
            clearDepth: false,
            clearStencil: false
        });
        model.setParameters({
            blend: true,
            blendColorSrcFactor: 'one',
            blendColorDstFactor: 'one',
            blendAlphaSrcFactor: 'one',
            blendAlphaDstFactor: 'one',
            blendColorOperation: operation === 'MAX' ? 'max' : operation === 'MIN' ? 'min' : 'add',
            blendAlphaOperation: 'add'
        });
        model.draw(renderPass);
        renderPass.end();
    }
}
/** Convert a [channel -> operation] map to a [operation -> GPU color mask] map */ function getMaskByOperation(operations) {
    const result = {
        ...EMPTY_MASKS
    };
    for(let channel = 0; channel < operations.length; channel++){
        const op = operations[channel];
        if (op) {
            result[op] += COLOR_CHANNELS[channel];
        }
    }
    return result;
}
function createModel(device, props) {
    let userVs = props.vs;
    if (props.dimensions === 2) {
        // If user provides 2d bin IDs, convert them to 1d indices for data packing
        userVs += /* glsl */ `
void getBin(out int binId) {
  ivec2 binId2;
  getBin(binId2);
  if (binId2.x < binSorter.binIdRange.x || binId2.x >= binSorter.binIdRange.y) {
    binId = -1;
  } else {
    binId = (binId2.y - binSorter.binIdRange.z) * (binSorter.binIdRange.y - binSorter.binIdRange.x) + binId2.x;
  }
}
`;
    }
    const vs = `\
#version 300 es
#define SHADER_NAME gpu-aggregation-sort-bins-vertex

${userVs}

out vec3 v_Value;

void main() {
  int binIndex;
  getBin(binIndex);
  binIndex = binIndex - binSorter.binIdRange.x;
  if (binIndex < 0) {
    gl_Position = vec4(0.);
    return;
  }
  int row = binIndex / binSorter.targetSize.x;
  int col = binIndex - row * binSorter.targetSize.x;
  vec2 position = (vec2(col, row) + 0.5) / vec2(binSorter.targetSize) * 2.0 - 1.0;
  gl_Position = vec4(position, 0.0, 1.0);
  gl_PointSize = 1.0;

#if NUM_CHANNELS == 3
  getValue(v_Value);
#elif NUM_CHANNELS == 2
  getValue(v_Value.xy);
#else
  getValue(v_Value.x);
#endif
}
`;
    const fs = /* glsl */ `\
#version 300 es
#define SHADER_NAME gpu-aggregation-sort-bins-fragment

precision highp float;

in vec3 v_Value;
out vec4 fragColor;

void main() {
  fragColor.xyz = v_Value;

  #ifdef MODULE_GEOMETRY
  geometry.uv = vec2(0.);
  DECKGL_FILTER_COLOR(fragColor, geometry);
  #endif

  fragColor.w = 1.0;
}
`;
    const model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Model"](device, {
        bufferLayout: props.bufferLayout,
        modules: [
            ...props.modules || [],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$bin$2d$sorter$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["binSorterUniforms"]
        ],
        defines: {
            ...props.defines,
            NON_INSTANCED_MODEL: 1,
            NUM_CHANNELS: props.channelCount
        },
        isInstanced: false,
        vs,
        fs,
        topology: 'point-list',
        disableWarnings: true
    });
    return model;
} //# sourceMappingURL=webgl-bin-sorter.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/aggregation-transform-uniforms.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "aggregatorTransformUniforms": (()=>aggregatorTransformUniforms)
});
const uniformBlock = /* glsl */ `\
uniform aggregatorTransformUniforms {
  ivec4 binIdRange;
  bvec3 isCount;
  bvec3 isMean;
  float naN;
} aggregatorTransform;
`;
const aggregatorTransformUniforms = {
    name: 'aggregatorTransform',
    vs: uniformBlock,
    uniformTypes: {
        binIdRange: 'vec4<i32>',
        isCount: 'vec3<f32>',
        isMean: 'vec3<f32>'
    }
}; //# sourceMappingURL=aggregation-transform-uniforms.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/webgl-aggregation-transform.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "WebGLAggregationTransform": (()=>WebGLAggregationTransform)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$compute$2f$buffer$2d$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/compute/buffer-transform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$aggregation$2d$transform$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/aggregation-transform-uniforms.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$bin$2d$sorter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/webgl-bin-sorter.js [app-client] (ecmascript)");
;
;
;
;
const MAX_FLOAT32 = 3e38;
class WebGLAggregationTransform {
    constructor(device, props){
        /** Packed from bin ids */ this.binBuffer = null;
        /** Packed values from each channel of each bin
         * Stride is number of channels * 4 bytes (float32)
         */ this.valueBuffer = null;
        /** Aggregated [min, max] for each channel */ this._domains = null;
        this.device = device;
        this.channelCount = props.channelCount;
        this.transform = createTransform(device, props);
        this.domainFBO = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createRenderTarget"])(device, 2, 1);
    }
    destroy() {
        this.transform.destroy();
        this.binBuffer?.destroy();
        this.valueBuffer?.destroy();
        this.domainFBO.colorAttachments[0].texture.destroy();
        this.domainFBO.destroy();
    }
    get domains() {
        if (!this._domains) {
            // Domain model has run, but result has not been read to CPU
            const buffer = this.device.readPixelsToArrayWebGL(this.domainFBO).buffer;
            const domain = new Float32Array(buffer);
            this._domains = [
                [
                    -domain[4],
                    domain[0]
                ],
                [
                    -domain[5],
                    domain[1]
                ],
                [
                    -domain[6],
                    domain[2]
                ]
            ].slice(0, this.channelCount);
        }
        return this._domains;
    }
    setDimensions(binCount, binIdRange) {
        const { model, transformFeedback } = this.transform;
        model.setVertexCount(binCount);
        const aggregatorTransformProps = {
            binIdRange: [
                binIdRange[0][0],
                binIdRange[0][1],
                binIdRange[1]?.[0] || 0,
                binIdRange[1]?.[1] || 0
            ]
        };
        model.shaderInputs.setProps({
            aggregatorTransform: aggregatorTransformProps
        });
        // Only destroy existing buffer if it is not large enough
        const binBufferByteLength = binCount * binIdRange.length * 4;
        if (!this.binBuffer || this.binBuffer.byteLength < binBufferByteLength) {
            this.binBuffer?.destroy();
            this.binBuffer = this.device.createBuffer({
                byteLength: binBufferByteLength
            });
            transformFeedback.setBuffer('binIds', this.binBuffer);
        }
        const valueBufferByteLength = binCount * this.channelCount * 4;
        if (!this.valueBuffer || this.valueBuffer.byteLength < valueBufferByteLength) {
            this.valueBuffer?.destroy();
            this.valueBuffer = this.device.createBuffer({
                byteLength: valueBufferByteLength
            });
            transformFeedback.setBuffer('values', this.valueBuffer);
        }
    }
    update(bins, operations) {
        if (!bins) {
            return;
        }
        const transform = this.transform;
        const target = this.domainFBO;
        const isCount = [
            0,
            1,
            2
        ].map((i)=>operations[i] === 'COUNT' ? 1 : 0);
        const isMean = [
            0,
            1,
            2
        ].map((i)=>operations[i] === 'MEAN' ? 1 : 0);
        const aggregatorTransformProps = {
            isCount: isCount,
            isMean: isMean,
            bins
        };
        transform.model.shaderInputs.setProps({
            aggregatorTransform: aggregatorTransformProps
        });
        transform.run({
            id: 'gpu-aggregation-domain',
            framebuffer: target,
            parameters: {
                viewport: [
                    0,
                    0,
                    2,
                    1
                ]
            },
            clearColor: [
                -MAX_FLOAT32,
                -MAX_FLOAT32,
                -MAX_FLOAT32,
                0
            ],
            clearDepth: false,
            clearStencil: false
        });
        // Clear the last read results. This will be lazy-populated if used.
        this._domains = null;
    }
}
function createTransform(device, props) {
    const vs = /* glsl */ `\
#version 300 es
#define SHADER_NAME gpu-aggregation-domain-vertex

uniform sampler2D bins;

#if NUM_DIMS == 1
out float binIds;
#else
out vec2 binIds;
#endif

#if NUM_CHANNELS == 1
flat out float values;
#elif NUM_CHANNELS == 2
flat out vec2 values;
#else
flat out vec3 values;
#endif

const float NAN = intBitsToFloat(-1);

void main() {
  int row = gl_VertexID / SAMPLER_WIDTH;
  int col = gl_VertexID - row * SAMPLER_WIDTH;
  vec4 weights = texelFetch(bins, ivec2(col, row), 0);
  vec3 value3 = mix(
    mix(weights.rgb, vec3(weights.a), aggregatorTransform.isCount),
    weights.rgb / max(weights.a, 1.0),
    aggregatorTransform.isMean
  );
  if (weights.a == 0.0) {
    value3 = vec3(NAN);
  }

#if NUM_DIMS == 1
  binIds = float(gl_VertexID + aggregatorTransform.binIdRange.x);
#else
  int y = gl_VertexID / (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);
  int x = gl_VertexID - y * (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);
  binIds.y = float(y + aggregatorTransform.binIdRange.z);
  binIds.x = float(x + aggregatorTransform.binIdRange.x);
#endif

#if NUM_CHANNELS == 3
  values = value3;
#elif NUM_CHANNELS == 2
  values = value3.xy;
#else
  values = value3.x;
#endif

  gl_Position = vec4(0., 0., 0., 1.);
  // This model renders into a 2x1 texture to obtain min and max simultaneously.
  // See comments in fragment shader
  gl_PointSize = 2.0;
}
`;
    const fs = /* glsl */ `\
#version 300 es
#define SHADER_NAME gpu-aggregation-domain-fragment

precision highp float;

#if NUM_CHANNELS == 1
flat in float values;
#elif NUM_CHANNELS == 2
flat in vec2 values;
#else
flat in vec3 values;
#endif

out vec4 fragColor;

void main() {
  vec3 value3;
#if NUM_CHANNELS == 3
  value3 = values;
#elif NUM_CHANNELS == 2
  value3.xy = values;
#else
  value3.x = values;
#endif
  if (isnan(value3.x)) discard;
  // This shader renders into a 2x1 texture with blending=max
  // The left pixel yields the max value of each channel
  // The right pixel yields the min value of each channel
  if (gl_FragCoord.x < 1.0) {
    fragColor = vec4(value3, 1.0);
  } else {
    fragColor = vec4(-value3, 1.0);
  }
}
`;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$compute$2f$buffer$2d$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferTransform"](device, {
        vs,
        fs,
        topology: 'point-list',
        modules: [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$aggregation$2d$transform$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aggregatorTransformUniforms"]
        ],
        parameters: {
            blend: true,
            blendColorSrcFactor: 'one',
            blendColorDstFactor: 'one',
            blendColorOperation: 'max',
            blendAlphaSrcFactor: 'one',
            blendAlphaDstFactor: 'one',
            blendAlphaOperation: 'max'
        },
        defines: {
            NUM_DIMS: props.dimensions,
            NUM_CHANNELS: props.channelCount,
            SAMPLER_WIDTH: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$bin$2d$sorter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TEXTURE_WIDTH"]
        },
        varyings: [
            'binIds',
            'values'
        ],
        disableWarnings: true
    });
} //# sourceMappingURL=webgl-aggregation-transform.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/webgl-aggregator.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "WebGLAggregator": (()=>WebGLAggregator)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$bin$2d$sorter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/webgl-bin-sorter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregation$2d$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/webgl-aggregation-transform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__deepEqual__as__$5f$deepEqual$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/utils/deep-equal.js [app-client] (ecmascript) <export deepEqual as _deepEqual>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__log$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/utils/log.js [app-client] (ecmascript) <export default as log>");
;
;
;
class WebGLAggregator {
    /** Checks if the current device supports GPU aggregation */ static isSupported(device) {
        return device.features.has('float32-renderable-webgl') && device.features.has('texture-blend-float-webgl');
    }
    constructor(device, props){
        this.binCount = 0;
        /** Cached outputs */ this.binIds = null;
        this.results = [];
        this.device = device;
        this.dimensions = props.dimensions;
        this.channelCount = props.channelCount;
        this.props = {
            ...props,
            pointCount: 0,
            binIdRange: [
                [
                    0,
                    0
                ]
            ],
            operations: [],
            attributes: {},
            binOptions: {}
        };
        this.needsUpdate = new Array(this.channelCount).fill(true);
        this.binSorter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$bin$2d$sorter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLBinSorter"](device, props);
        this.aggregationTransform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregation$2d$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLAggregationTransform"](device, props);
        this.setProps(props);
    }
    getBins() {
        const buffer = this.aggregationTransform.binBuffer;
        if (!buffer) {
            return null;
        }
        if (this.binIds?.buffer !== buffer) {
            // deck.gl Attribute.setBinaryValue uses shallow comparison to determine if attribute value has changed
            // For performance, only create a new binary attribute descriptor when Buffer changes
            this.binIds = {
                buffer,
                type: 'float32',
                size: this.dimensions
            };
        }
        return this.binIds;
    }
    /** Returns an accessor to the output for a given channel. */ getResult(channel) {
        const buffer = this.aggregationTransform.valueBuffer;
        if (!buffer || channel >= this.channelCount) {
            return null;
        }
        if (this.results[channel]?.buffer !== buffer) {
            this.results[channel] = {
                buffer,
                type: 'float32',
                size: 1,
                stride: this.channelCount * 4,
                offset: channel * 4
            };
        }
        return this.results[channel];
    }
    /** Returns the [min, max] of aggregated values for a given channel. */ getResultDomain(channel) {
        return this.aggregationTransform.domains[channel];
    }
    /** Returns the information for a given bin. */ getBin(index) {
        if (index < 0 || index >= this.binCount) {
            return null;
        }
        const { binIdRange } = this.props;
        let id;
        if (this.dimensions === 1) {
            id = [
                index + binIdRange[0][0]
            ];
        } else {
            const [[x0, x1], [y0]] = binIdRange;
            const width = x1 - x0;
            id = [
                index % width + x0,
                Math.floor(index / width) + y0
            ];
        }
        const pixel = this.binSorter.getBinValues(index);
        if (!pixel) {
            return null;
        }
        const count = pixel[3];
        const value = [];
        for(let channel = 0; channel < this.channelCount; channel++){
            const operation = this.props.operations[channel];
            if (operation === 'COUNT') {
                value[channel] = count;
            } else if (count === 0) {
                value[channel] = NaN;
            } else {
                value[channel] = operation === 'MEAN' ? pixel[channel] / count : pixel[channel];
            }
        }
        return {
            id,
            value,
            count
        };
    }
    /** Release GPU resources */ destroy() {
        this.binSorter.destroy();
        this.aggregationTransform.destroy();
    }
    /** Update aggregation props. Normalize prop values and set change flags. */ setProps(props) {
        const oldProps = this.props;
        // Update local settings. These will set the flag this._needsUpdate
        if ('binIdRange' in props && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__deepEqual__as__$5f$deepEqual$3e$__["_deepEqual"])(props.binIdRange, oldProps.binIdRange, 2)) {
            const binIdRange = props.binIdRange;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__log$3e$__["log"].assert(binIdRange.length === this.dimensions);
            if (this.dimensions === 1) {
                const [[x0, x1]] = binIdRange;
                this.binCount = x1 - x0;
            } else {
                const [[x0, x1], [y0, y1]] = binIdRange;
                this.binCount = (x1 - x0) * (y1 - y0);
            }
            this.binSorter.setDimensions(this.binCount, binIdRange);
            this.aggregationTransform.setDimensions(this.binCount, binIdRange);
            this.setNeedsUpdate();
        }
        if (props.operations) {
            for(let channel = 0; channel < this.channelCount; channel++){
                if (props.operations[channel] !== oldProps.operations[channel]) {
                    this.setNeedsUpdate(channel);
                }
            }
        }
        if (props.pointCount !== undefined && props.pointCount !== oldProps.pointCount) {
            this.binSorter.setModelProps({
                vertexCount: props.pointCount
            });
            this.setNeedsUpdate();
        }
        if (props.binOptions) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__deepEqual__as__$5f$deepEqual$3e$__["_deepEqual"])(props.binOptions, oldProps.binOptions, 2)) {
                this.setNeedsUpdate();
            }
            this.binSorter.model.shaderInputs.setProps({
                binOptions: props.binOptions
            });
        }
        if (props.attributes) {
            const attributeBuffers = {};
            const constantAttributes = {};
            for (const attribute of Object.values(props.attributes)){
                for (const [attributeName, value] of Object.entries(attribute.getValue())){
                    if (ArrayBuffer.isView(value)) {
                        constantAttributes[attributeName] = value;
                    } else if (value) {
                        attributeBuffers[attributeName] = value;
                    }
                }
            }
            this.binSorter.setModelProps({
                attributes: attributeBuffers,
                constantAttributes
            });
        }
        if (props.shaderModuleProps) {
            this.binSorter.setModelProps({
                shaderModuleProps: props.shaderModuleProps
            });
        }
        Object.assign(this.props, props);
    }
    /** Flags a channel to need update.
     * This is called internally by setProps() if certain props change
     * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed
     * the underlying buffers could have been updated and require rerunning the aggregation
     * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.
     */ setNeedsUpdate(channel) {
        if (channel === undefined) {
            this.needsUpdate.fill(true);
        } else {
            this.needsUpdate[channel] = true;
        }
    }
    update() {}
    /** Run aggregation */ preDraw() {
        if (!this.needsUpdate.some(Boolean)) {
            return;
        }
        const { operations } = this.props;
        const operationsToUpdate = this.needsUpdate.map((needsUpdate, i)=>needsUpdate ? operations[i] : null);
        // Render data to bins
        this.binSorter.update(operationsToUpdate);
        // Read to buffer and calculate domain
        this.aggregationTransform.update(this.binSorter.texture, operations);
        for(let i = 0; i < this.channelCount; i++){
            if (this.needsUpdate[i]) {
                this.needsUpdate[i] = false;
                this.props.onUpdate?.({
                    channel: i
                });
            }
        }
    // Uncomment to debug
    // console.log('binsFBO', new Float32Array(this.device.readPixelsToArrayWebGL(this.binSorter.texture!).buffer));
    // console.log('binsBuffer', new Float32Array(this.aggregationTransform.binBuffer?.readSyncWebGL().buffer!));
    // console.log('resultBuffer', new Float32Array(this.aggregationTransform.valueBuffer?.readSyncWebGL().buffer!));
    }
} //# sourceMappingURL=webgl-aggregator.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/contour-layer/bin-options-uniforms.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "binOptionsUniforms": (()=>binOptionsUniforms)
});
const uniformBlock = /* glsl */ `\
uniform binOptionsUniforms {
  vec2 cellOriginCommon;
  vec2 cellSizeCommon;
} binOptions;
`;
const binOptionsUniforms = {
    name: 'binOptions',
    vs: uniformBlock,
    uniformTypes: {
        cellOriginCommon: 'vec2<f32>',
        cellSizeCommon: 'vec2<f32>'
    }
}; //# sourceMappingURL=bin-options-uniforms.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/common/utils/bounds-utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** Utility to estimate binIdRange as expected by AggregatorProps */ __turbopack_esm__({
    "getBinIdRange": (()=>getBinIdRange)
});
function getBinIdRange({ dataBounds, getBinId, padding = 0 }) {
    const corners = [
        dataBounds[0],
        dataBounds[1],
        [
            dataBounds[0][0],
            dataBounds[1][1]
        ],
        [
            dataBounds[1][0],
            dataBounds[0][1]
        ]
    ].map((p)=>getBinId(p));
    const minX = Math.min(...corners.map((p)=>p[0])) - padding;
    const minY = Math.min(...corners.map((p)=>p[1])) - padding;
    const maxX = Math.max(...corners.map((p)=>p[0])) + padding + 1;
    const maxY = Math.max(...corners.map((p)=>p[1])) + padding + 1;
    return [
        [
            minX,
            maxX
        ],
        [
            minY,
            maxY
        ]
    ];
} //# sourceMappingURL=bounds-utils.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/contour-layer/value-reader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "getAggregatorValueReader": (()=>getAggregatorValueReader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/webgl-aggregator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$cpu$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/cpu-aggregator/cpu-aggregator.js [app-client] (ecmascript)");
;
function getAggregatorValueReader(opts) {
    const { aggregator, binIdRange, channel } = opts;
    if (aggregator instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLAggregator"]) {
        const buffer = aggregator.getResult(channel)?.buffer;
        if (buffer) {
            const values = new Float32Array(buffer.readSyncWebGL().buffer);
            return getWebGLAggregatorValueReader(values, binIdRange);
        }
    }
    if (aggregator instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$cpu$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CPUAggregator"]) {
        const values = aggregator.getResult(channel)?.value;
        const ids = aggregator.getBins()?.value;
        if (ids && values) {
            return getCPUAggregatorValueReader(values, ids, aggregator.binCount);
        }
    }
    return null;
}
function getWebGLAggregatorValueReader(values, binIdRange) {
    const [[minX, maxX], [minY, maxY]] = binIdRange;
    const width = maxX - minX;
    const height = maxY - minY;
    return (x, y)=>{
        x -= minX;
        y -= minY;
        if (x < 0 || x >= width || y < 0 || y >= height) {
            return NaN;
        }
        return values[y * width + x];
    };
}
function getCPUAggregatorValueReader(values, ids, count) {
    const idMap = {};
    for(let i = 0; i < count; i++){
        const x = ids[i * 2];
        const y = ids[i * 2 + 1];
        idMap[x] = idMap[x] || {};
        idMap[x][y] = values[i];
    }
    return (x, y)=>idMap[x]?.[y] ?? NaN;
} //# sourceMappingURL=value-reader.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/contour-layer/marching-squares-codes.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Code to Offsets Map needed to implement Marching Squares algorithm
// Ref: https://en.wikipedia.org/wiki/Marching_squares
// Table to map code to the intersection offsets
// All offsets are relative to the center of marching cell (which is top right corner of grid-cell, and center of marching-square)
__turbopack_esm__({
    "ISOBANDS_CODE_OFFSET_MAP": (()=>ISOBANDS_CODE_OFFSET_MAP),
    "ISOLINES_CODE_OFFSET_MAP": (()=>ISOLINES_CODE_OFFSET_MAP)
});
const HALF = 0.5;
const ONE6TH = 1 / 6;
const OFFSET = {
    N: [
        0,
        HALF
    ],
    E: [
        HALF,
        0
    ],
    S: [
        0,
        -HALF
    ],
    W: [
        -HALF,
        0
    ],
    // CORNERS
    NE: [
        HALF,
        HALF
    ],
    NW: [
        -HALF,
        HALF
    ],
    SE: [
        HALF,
        -HALF
    ],
    SW: [
        -HALF,
        -HALF
    ]
};
// NOTE: vertices are ordered in CCW direction, starting from NW corner
// Triangles
const SW_TRIANGLE = [
    OFFSET.W,
    OFFSET.SW,
    OFFSET.S
];
const SE_TRIANGLE = [
    OFFSET.S,
    OFFSET.SE,
    OFFSET.E
];
const NE_TRIANGLE = [
    OFFSET.E,
    OFFSET.NE,
    OFFSET.N
];
const NW_TRIANGLE = [
    OFFSET.NW,
    OFFSET.W,
    OFFSET.N
];
// Trapezoids
const SW_TRAPEZOID = [
    [
        -HALF,
        ONE6TH
    ],
    [
        -HALF,
        -ONE6TH
    ],
    [
        -ONE6TH,
        -HALF
    ],
    [
        ONE6TH,
        -HALF
    ]
];
const SE_TRAPEZOID = [
    [
        -ONE6TH,
        -HALF
    ],
    [
        ONE6TH,
        -HALF
    ],
    [
        HALF,
        -ONE6TH
    ],
    [
        HALF,
        ONE6TH
    ]
];
const NE_TRAPEZOID = [
    [
        HALF,
        -ONE6TH
    ],
    [
        HALF,
        ONE6TH
    ],
    [
        ONE6TH,
        HALF
    ],
    [
        -ONE6TH,
        HALF
    ]
];
const NW_TRAPEZOID = [
    [
        -HALF,
        ONE6TH
    ],
    [
        -HALF,
        -ONE6TH
    ],
    [
        ONE6TH,
        HALF
    ],
    [
        -ONE6TH,
        HALF
    ]
];
// Rectangles
const S_RECTANGLE = [
    OFFSET.W,
    OFFSET.SW,
    OFFSET.SE,
    OFFSET.E
];
const E_RECTANGLE = [
    OFFSET.S,
    OFFSET.SE,
    OFFSET.NE,
    OFFSET.N
];
const N_RECTANGLE = [
    OFFSET.NW,
    OFFSET.W,
    OFFSET.E,
    OFFSET.NE
];
const W_RECTANGLE = [
    OFFSET.NW,
    OFFSET.SW,
    OFFSET.S,
    OFFSET.N
];
const EW_RECTANGEL = [
    [
        -HALF,
        ONE6TH
    ],
    [
        -HALF,
        -ONE6TH
    ],
    [
        HALF,
        -ONE6TH
    ],
    [
        HALF,
        ONE6TH
    ]
];
const SN_RECTANGEL = [
    [
        -ONE6TH,
        -HALF
    ],
    [
        ONE6TH,
        -HALF
    ],
    [
        ONE6TH,
        HALF
    ],
    [
        -ONE6TH,
        HALF
    ]
];
// Square
const SQUARE = [
    OFFSET.NW,
    OFFSET.SW,
    OFFSET.SE,
    OFFSET.NE
];
// Pentagons
const SW_PENTAGON = [
    OFFSET.NW,
    OFFSET.SW,
    OFFSET.SE,
    OFFSET.E,
    OFFSET.N
];
const SE_PENTAGON = [
    OFFSET.W,
    OFFSET.SW,
    OFFSET.SE,
    OFFSET.NE,
    OFFSET.N
];
const NE_PENTAGON = [
    OFFSET.NW,
    OFFSET.W,
    OFFSET.S,
    OFFSET.SE,
    OFFSET.NE
];
const NW_PENTAGON = [
    OFFSET.NW,
    OFFSET.SW,
    OFFSET.S,
    OFFSET.E,
    OFFSET.NE
];
const NW_N_PENTAGON = [
    OFFSET.NW,
    OFFSET.W,
    [
        HALF,
        -ONE6TH
    ],
    [
        HALF,
        ONE6TH
    ],
    OFFSET.N
];
const NE_E_PENTAGON = [
    [
        -ONE6TH,
        -HALF
    ],
    [
        ONE6TH,
        -HALF
    ],
    OFFSET.E,
    OFFSET.NE,
    OFFSET.N
];
const SE_S_PENTAGON = [
    [
        -HALF,
        ONE6TH
    ],
    [
        -HALF,
        -ONE6TH
    ],
    OFFSET.S,
    OFFSET.SE,
    OFFSET.E
];
const SW_W_PENTAGON = [
    OFFSET.W,
    OFFSET.SW,
    OFFSET.S,
    [
        ONE6TH,
        HALF
    ],
    [
        -ONE6TH,
        HALF
    ]
];
const NW_W_PENTAGON = [
    OFFSET.NW,
    OFFSET.W,
    [
        -ONE6TH,
        -HALF
    ],
    [
        ONE6TH,
        -HALF
    ],
    OFFSET.N
];
const NE_N_PENTAGON = [
    [
        -HALF,
        ONE6TH
    ],
    [
        -HALF,
        -ONE6TH
    ],
    OFFSET.E,
    OFFSET.NE,
    OFFSET.N
];
const SE_E_PENTAGON = [
    OFFSET.S,
    OFFSET.SE,
    OFFSET.E,
    [
        ONE6TH,
        HALF
    ],
    [
        -ONE6TH,
        HALF
    ]
];
const SW_S_PENTAGON = [
    OFFSET.W,
    OFFSET.SW,
    OFFSET.S,
    [
        HALF,
        -ONE6TH
    ],
    [
        HALF,
        ONE6TH
    ]
];
// Hexagon
const S_HEXAGON = [
    OFFSET.W,
    OFFSET.SW,
    OFFSET.SE,
    OFFSET.E,
    [
        ONE6TH,
        HALF
    ],
    [
        -ONE6TH,
        HALF
    ]
];
const E_HEXAGON = [
    [
        -HALF,
        ONE6TH
    ],
    [
        -HALF,
        -ONE6TH
    ],
    OFFSET.S,
    OFFSET.SE,
    OFFSET.NE,
    OFFSET.N
];
const N_HEXAGON = [
    OFFSET.NW,
    OFFSET.W,
    [
        -ONE6TH,
        -HALF
    ],
    [
        ONE6TH,
        -HALF
    ],
    OFFSET.E,
    OFFSET.NE
];
const W_HEXAGON = [
    OFFSET.NW,
    OFFSET.SW,
    OFFSET.S,
    [
        HALF,
        -ONE6TH
    ],
    [
        HALF,
        ONE6TH
    ],
    OFFSET.N
];
const SW_NE_HEXAGON = [
    OFFSET.W,
    OFFSET.SW,
    OFFSET.S,
    OFFSET.E,
    OFFSET.NE,
    OFFSET.N
];
const NW_SE_HEXAGON = [
    OFFSET.NW,
    OFFSET.W,
    OFFSET.S,
    OFFSET.SE,
    OFFSET.E,
    OFFSET.N
];
// Heptagon (7-sided)
const NE_HEPTAGON = [
    [
        -HALF,
        ONE6TH
    ],
    [
        -HALF,
        -ONE6TH
    ],
    [
        -ONE6TH,
        -HALF
    ],
    [
        ONE6TH,
        -HALF
    ],
    OFFSET.E,
    OFFSET.NE,
    OFFSET.N
];
const SW_HEPTAGON = [
    OFFSET.W,
    OFFSET.SW,
    OFFSET.S,
    [
        HALF,
        -ONE6TH
    ],
    [
        HALF,
        ONE6TH
    ],
    [
        ONE6TH,
        HALF
    ],
    [
        -ONE6TH,
        HALF
    ]
];
const NW_HEPTAGON = [
    OFFSET.NW,
    OFFSET.W,
    [
        -ONE6TH,
        -HALF
    ],
    [
        ONE6TH,
        -HALF
    ],
    [
        HALF,
        -ONE6TH
    ],
    [
        HALF,
        ONE6TH
    ],
    OFFSET.N
];
const SE_HEPTAGON = [
    [
        -HALF,
        ONE6TH
    ],
    [
        -HALF,
        -ONE6TH
    ],
    OFFSET.S,
    OFFSET.SE,
    OFFSET.E,
    [
        ONE6TH,
        HALF
    ],
    [
        -ONE6TH,
        HALF
    ]
];
// Octagon
const OCTAGON = [
    [
        -HALF,
        ONE6TH
    ],
    [
        -HALF,
        -ONE6TH
    ],
    [
        -ONE6TH,
        -HALF
    ],
    [
        ONE6TH,
        -HALF
    ],
    [
        HALF,
        -ONE6TH
    ],
    [
        HALF,
        ONE6TH
    ],
    [
        ONE6TH,
        HALF
    ],
    [
        -ONE6TH,
        HALF
    ]
];
const ISOLINES_CODE_OFFSET_MAP = {
    // key is equal to the code of 4 vertices (invert the code specified in wiki)
    // value can be an array or an Object
    // Array : [line] or [line, line], where each line is [start-point, end-point], and each point is [x, y]
    // Object : to handle saddle cases, whos output depends on mean value of all 4 corners
    //  key: code of mean value (0 or 1)
    //  value: Array , as above defines one or two line segments
    0: [],
    1: [
        [
            OFFSET.W,
            OFFSET.S
        ]
    ],
    2: [
        [
            OFFSET.S,
            OFFSET.E
        ]
    ],
    3: [
        [
            OFFSET.W,
            OFFSET.E
        ]
    ],
    4: [
        [
            OFFSET.N,
            OFFSET.E
        ]
    ],
    5: {
        0: [
            [
                OFFSET.W,
                OFFSET.S
            ],
            [
                OFFSET.N,
                OFFSET.E
            ]
        ],
        1: [
            [
                OFFSET.W,
                OFFSET.N
            ],
            [
                OFFSET.S,
                OFFSET.E
            ]
        ]
    },
    6: [
        [
            OFFSET.N,
            OFFSET.S
        ]
    ],
    7: [
        [
            OFFSET.W,
            OFFSET.N
        ]
    ],
    8: [
        [
            OFFSET.W,
            OFFSET.N
        ]
    ],
    9: [
        [
            OFFSET.N,
            OFFSET.S
        ]
    ],
    10: {
        0: [
            [
                OFFSET.W,
                OFFSET.N
            ],
            [
                OFFSET.S,
                OFFSET.E
            ]
        ],
        1: [
            [
                OFFSET.W,
                OFFSET.S
            ],
            [
                OFFSET.N,
                OFFSET.E
            ]
        ]
    },
    11: [
        [
            OFFSET.N,
            OFFSET.E
        ]
    ],
    12: [
        [
            OFFSET.W,
            OFFSET.E
        ]
    ],
    13: [
        [
            OFFSET.S,
            OFFSET.E
        ]
    ],
    14: [
        [
            OFFSET.W,
            OFFSET.S
        ]
    ],
    15: []
};
function ternaryToIndex(ternary) {
    return parseInt(ternary, 4);
}
const ISOBANDS_CODE_OFFSET_MAP = {
    // Below list of cases, follow the same order as in above mentioned wiki page.
    // Each case has its code on first commented line // T,TR,R,C
    // where T: Top, TR: Top-right, R: Right and C: current, each will be either 0, 1 or 2
    // final code is binary representation of above code , where takes 2 digits
    // for example:  code 2-2-2-1 => 10-10-10-01 => 10101001 => 169
    // no contours
    [ternaryToIndex('0000')]: [],
    [ternaryToIndex('2222')]: [],
    // single triangle
    [ternaryToIndex('2221')]: [
        SW_TRIANGLE
    ],
    [ternaryToIndex('2212')]: [
        SE_TRIANGLE
    ],
    [ternaryToIndex('2122')]: [
        NE_TRIANGLE
    ],
    [ternaryToIndex('1222')]: [
        NW_TRIANGLE
    ],
    [ternaryToIndex('0001')]: [
        SW_TRIANGLE
    ],
    [ternaryToIndex('0010')]: [
        SE_TRIANGLE
    ],
    [ternaryToIndex('0100')]: [
        NE_TRIANGLE
    ],
    [ternaryToIndex('1000')]: [
        NW_TRIANGLE
    ],
    // single trapezoid
    [ternaryToIndex('2220')]: [
        SW_TRAPEZOID
    ],
    [ternaryToIndex('2202')]: [
        SE_TRAPEZOID
    ],
    [ternaryToIndex('2022')]: [
        NE_TRAPEZOID
    ],
    [ternaryToIndex('0222')]: [
        NW_TRAPEZOID
    ],
    [ternaryToIndex('0002')]: [
        SW_TRAPEZOID
    ],
    [ternaryToIndex('0020')]: [
        SE_TRAPEZOID
    ],
    [ternaryToIndex('0200')]: [
        NE_TRAPEZOID
    ],
    [ternaryToIndex('2000')]: [
        NW_TRAPEZOID
    ],
    // single rectangle
    [ternaryToIndex('0011')]: [
        S_RECTANGLE
    ],
    [ternaryToIndex('0110')]: [
        E_RECTANGLE
    ],
    [ternaryToIndex('1100')]: [
        N_RECTANGLE
    ],
    [ternaryToIndex('1001')]: [
        W_RECTANGLE
    ],
    [ternaryToIndex('2211')]: [
        S_RECTANGLE
    ],
    [ternaryToIndex('2112')]: [
        E_RECTANGLE
    ],
    [ternaryToIndex('1122')]: [
        N_RECTANGLE
    ],
    [ternaryToIndex('1221')]: [
        W_RECTANGLE
    ],
    [ternaryToIndex('2200')]: [
        EW_RECTANGEL
    ],
    [ternaryToIndex('2002')]: [
        SN_RECTANGEL
    ],
    [ternaryToIndex('0022')]: [
        EW_RECTANGEL
    ],
    [ternaryToIndex('0220')]: [
        SN_RECTANGEL
    ],
    // single square
    // 1111
    [ternaryToIndex('1111')]: [
        SQUARE
    ],
    // single pentagon
    [ternaryToIndex('1211')]: [
        SW_PENTAGON
    ],
    [ternaryToIndex('2111')]: [
        SE_PENTAGON
    ],
    [ternaryToIndex('1112')]: [
        NE_PENTAGON
    ],
    [ternaryToIndex('1121')]: [
        NW_PENTAGON
    ],
    [ternaryToIndex('1011')]: [
        SW_PENTAGON
    ],
    [ternaryToIndex('0111')]: [
        SE_PENTAGON
    ],
    [ternaryToIndex('1110')]: [
        NE_PENTAGON
    ],
    [ternaryToIndex('1101')]: [
        NW_PENTAGON
    ],
    [ternaryToIndex('1200')]: [
        NW_N_PENTAGON
    ],
    [ternaryToIndex('0120')]: [
        NE_E_PENTAGON
    ],
    [ternaryToIndex('0012')]: [
        SE_S_PENTAGON
    ],
    [ternaryToIndex('2001')]: [
        SW_W_PENTAGON
    ],
    [ternaryToIndex('1022')]: [
        NW_N_PENTAGON
    ],
    [ternaryToIndex('2102')]: [
        NE_E_PENTAGON
    ],
    [ternaryToIndex('2210')]: [
        SE_S_PENTAGON
    ],
    [ternaryToIndex('0221')]: [
        SW_W_PENTAGON
    ],
    [ternaryToIndex('1002')]: [
        NW_W_PENTAGON
    ],
    [ternaryToIndex('2100')]: [
        NE_N_PENTAGON
    ],
    [ternaryToIndex('0210')]: [
        SE_E_PENTAGON
    ],
    [ternaryToIndex('0021')]: [
        SW_S_PENTAGON
    ],
    [ternaryToIndex('1220')]: [
        NW_W_PENTAGON
    ],
    [ternaryToIndex('0122')]: [
        NE_N_PENTAGON
    ],
    [ternaryToIndex('2012')]: [
        SE_E_PENTAGON
    ],
    [ternaryToIndex('2201')]: [
        SW_S_PENTAGON
    ],
    // single hexagon
    [ternaryToIndex('0211')]: [
        S_HEXAGON
    ],
    [ternaryToIndex('2110')]: [
        E_HEXAGON
    ],
    [ternaryToIndex('1102')]: [
        N_HEXAGON
    ],
    [ternaryToIndex('1021')]: [
        W_HEXAGON
    ],
    [ternaryToIndex('2011')]: [
        S_HEXAGON
    ],
    [ternaryToIndex('0112')]: [
        E_HEXAGON
    ],
    [ternaryToIndex('1120')]: [
        N_HEXAGON
    ],
    [ternaryToIndex('1201')]: [
        W_HEXAGON
    ],
    [ternaryToIndex('2101')]: [
        SW_NE_HEXAGON
    ],
    [ternaryToIndex('0121')]: [
        SW_NE_HEXAGON
    ],
    [ternaryToIndex('1012')]: [
        NW_SE_HEXAGON
    ],
    [ternaryToIndex('1210')]: [
        NW_SE_HEXAGON
    ],
    // 6-sided polygons based on mean weight
    // NOTE: merges mean value codes for extreme changes (as per above Wiki doc)
    [ternaryToIndex('0101')]: {
        0: [
            SW_TRIANGLE,
            NE_TRIANGLE
        ],
        1: [
            SW_NE_HEXAGON
        ],
        2: [
            SW_NE_HEXAGON
        ]
    },
    [ternaryToIndex('1010')]: {
        0: [
            NW_TRIANGLE,
            SE_TRIANGLE
        ],
        1: [
            NW_SE_HEXAGON
        ],
        2: [
            NW_SE_HEXAGON
        ]
    },
    [ternaryToIndex('2121')]: {
        0: [
            SW_NE_HEXAGON
        ],
        1: [
            SW_NE_HEXAGON
        ],
        2: [
            SW_TRIANGLE,
            NE_TRIANGLE
        ]
    },
    [ternaryToIndex('1212')]: {
        0: [
            NW_SE_HEXAGON
        ],
        1: [
            NW_SE_HEXAGON
        ],
        2: [
            NW_TRIANGLE,
            SE_TRIANGLE
        ]
    },
    // 7-sided polygons based on mean weight
    [ternaryToIndex('2120')]: {
        0: [
            NE_HEPTAGON
        ],
        1: [
            NE_HEPTAGON
        ],
        2: [
            SW_TRAPEZOID,
            NE_TRIANGLE
        ]
    },
    [ternaryToIndex('2021')]: {
        0: [
            SW_HEPTAGON
        ],
        1: [
            SW_HEPTAGON
        ],
        2: [
            SW_TRIANGLE,
            NE_TRAPEZOID
        ]
    },
    [ternaryToIndex('1202')]: {
        0: [
            NW_HEPTAGON
        ],
        1: [
            NW_HEPTAGON
        ],
        2: [
            NW_TRIANGLE,
            SE_TRAPEZOID
        ]
    },
    [ternaryToIndex('0212')]: {
        0: [
            SE_HEPTAGON
        ],
        1: [
            SE_HEPTAGON
        ],
        2: [
            SE_TRIANGLE,
            NW_TRAPEZOID
        ]
    },
    [ternaryToIndex('0102')]: {
        0: [
            SW_TRAPEZOID,
            NE_TRIANGLE
        ],
        1: [
            NE_HEPTAGON
        ],
        2: [
            NE_HEPTAGON
        ]
    },
    [ternaryToIndex('0201')]: {
        0: [
            SW_TRIANGLE,
            NE_TRAPEZOID
        ],
        1: [
            SW_HEPTAGON
        ],
        2: [
            SW_HEPTAGON
        ]
    },
    [ternaryToIndex('1020')]: {
        0: [
            NW_TRIANGLE,
            SE_TRAPEZOID
        ],
        1: [
            NW_HEPTAGON
        ],
        2: [
            NW_HEPTAGON
        ]
    },
    [ternaryToIndex('2010')]: {
        0: [
            SE_TRIANGLE,
            NW_TRAPEZOID
        ],
        1: [
            SE_HEPTAGON
        ],
        2: [
            SE_HEPTAGON
        ]
    },
    // 8-sided polygons based on mean weight
    [ternaryToIndex('2020')]: {
        0: [
            NW_TRAPEZOID,
            SE_TRAPEZOID
        ],
        1: [
            OCTAGON
        ],
        2: [
            SW_TRAPEZOID,
            NE_TRAPEZOID
        ]
    },
    [ternaryToIndex('0202')]: {
        0: [
            NE_TRAPEZOID,
            SW_TRAPEZOID
        ],
        1: [
            OCTAGON
        ],
        2: [
            NW_TRAPEZOID,
            SE_TRAPEZOID
        ]
    }
}; //# sourceMappingURL=marching-squares-codes.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/contour-layer/marching-squares.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// All utility methods needed to implement Marching Squares algorithm
// Ref: https://en.wikipedia.org/wiki/Marching_squares
__turbopack_esm__({
    "getCode": (()=>getCode),
    "getLines": (()=>getLines),
    "getPolygons": (()=>getPolygons)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$contour$2d$layer$2f$marching$2d$squares$2d$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/contour-layer/marching-squares-codes.js [app-client] (ecmascript)");
;
// Utility methods
function getVertexCode(weight, threshold) {
    // threshold must be a single value or a range (array of size 2)
    if (Number.isNaN(weight)) {
        return 0;
    }
    // Iso-bands
    if (Array.isArray(threshold)) {
        if (weight < threshold[0]) {
            return 0;
        }
        return weight < threshold[1] ? 1 : 2;
    }
    // Iso-lines
    return weight >= threshold ? 1 : 0;
}
function getCode(opts) {
    // Assumptions
    // Origin is on bottom-left , and X increase to right, Y to top
    // When processing one cell, we process 4 cells, by extending row to top and on column to right
    // to create a 2X2 cell grid
    const { x, y, xRange, yRange, getValue, threshold } = opts;
    const isLeftBoundary = x < xRange[0];
    const isRightBoundary = x >= xRange[1] - 1;
    const isBottomBoundary = y < yRange[0];
    const isTopBoundary = y >= yRange[1] - 1;
    const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;
    let weights = 0;
    let current;
    let right;
    let top;
    let topRight;
    // TOP
    if (isLeftBoundary || isTopBoundary) {
        top = 0;
    } else {
        const w = getValue(x, y + 1);
        top = getVertexCode(w, threshold);
        weights += w;
    }
    // TOP-RIGHT
    if (isRightBoundary || isTopBoundary) {
        topRight = 0;
    } else {
        const w = getValue(x + 1, y + 1);
        topRight = getVertexCode(w, threshold);
        weights += w;
    }
    // RIGHT
    if (isRightBoundary || isBottomBoundary) {
        right = 0;
    } else {
        const w = getValue(x + 1, y);
        right = getVertexCode(w, threshold);
        weights += w;
    }
    // CURRENT
    if (isLeftBoundary || isBottomBoundary) {
        current = 0;
    } else {
        const w = getValue(x, y);
        current = getVertexCode(w, threshold);
        weights += w;
    }
    let code = -1;
    if (Number.isFinite(threshold)) {
        code = top << 3 | topRight << 2 | right << 1 | current;
    }
    if (Array.isArray(threshold)) {
        code = top << 6 | topRight << 4 | right << 2 | current;
    }
    let meanCode = 0;
    // meanCode is only needed for saddle cases, and they should
    // only occur when we are not processing a cell on boundary
    // because when on a boundary either, bottom-row, top-row, left-column or right-column will have both 0 codes
    if (!isBoundary) {
        meanCode = getVertexCode(weights / 4, threshold);
    }
    return {
        code,
        meanCode
    };
}
function getPolygons(opts) {
    const { x, y, z, code, meanCode } = opts;
    let offsets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$contour$2d$layer$2f$marching$2d$squares$2d$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ISOBANDS_CODE_OFFSET_MAP"][code];
    // handle saddle cases
    if (!Array.isArray(offsets)) {
        offsets = offsets[meanCode];
    }
    // Reference vertex is at top-right move to top-right corner
    const rX = x + 1;
    const rY = y + 1;
    // offsets format
    // [[1A, 1B, 1C, ...], [2A, 2B, 2C, ...]],
    // vertices format
    // [
    //   [[x1A, y1A], [x1B, y1B], [x1C, y1C] ... ],
    //        ...
    // ]
    const polygons = [];
    offsets.forEach((polygonOffsets)=>{
        const polygon = [];
        polygonOffsets.forEach((xyOffset)=>{
            const vX = rX + xyOffset[0];
            const vY = rY + xyOffset[1];
            polygon.push([
                vX,
                vY,
                z
            ]);
        });
        polygons.push(polygon);
    });
    return polygons;
}
function getLines(opts) {
    const { x, y, z, code, meanCode } = opts;
    let offsets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$contour$2d$layer$2f$marching$2d$squares$2d$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ISOLINES_CODE_OFFSET_MAP"][code];
    // handle saddle cases
    if (!Array.isArray(offsets)) {
        offsets = offsets[meanCode];
    }
    // Reference vertex is at top-right move to top-right corner
    const rX = x + 1;
    const rY = y + 1;
    // offsets format
    // [[1A, 1B], [2A, 2B]],
    // vertices format
    // [[x1A, y1A], [x1B, y1B], [x2A, x2B], ...],
    const lines = [];
    offsets.forEach((xyOffsets)=>{
        xyOffsets.forEach((offset)=>{
            const vX = rX + offset[0];
            const vY = rY + offset[1];
            lines.push([
                vX,
                vY,
                z
            ]);
        });
    });
    return lines;
} //# sourceMappingURL=marching-squares.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/contour-layer/contour-utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "generateContours": (()=>generateContours)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$contour$2d$layer$2f$marching$2d$squares$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/contour-layer/marching-squares.js [app-client] (ecmascript)");
;
function generateContours({ contours, getValue, xRange, yRange }) {
    const contourLines = [];
    const contourPolygons = [];
    let segmentIndex = 0;
    let polygonIndex = 0;
    for(let i = 0; i < contours.length; i++){
        const contour = contours[i];
        const z = contour.zIndex ?? i;
        const { threshold } = contour;
        for(let x = xRange[0] - 1; x < xRange[1]; x++){
            for(let y = yRange[0] - 1; y < yRange[1]; y++){
                // Get the MarchingSquares code based on neighbor cell weights.
                const { code, meanCode } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$contour$2d$layer$2f$marching$2d$squares$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCode"])({
                    getValue,
                    threshold,
                    x,
                    y,
                    xRange,
                    yRange
                });
                const opts = {
                    x,
                    y,
                    z,
                    code,
                    meanCode
                };
                if (Array.isArray(threshold)) {
                    // ISO bands
                    const polygons = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$contour$2d$layer$2f$marching$2d$squares$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPolygons"])(opts);
                    for (const polygon of polygons){
                        contourPolygons[polygonIndex++] = {
                            vertices: polygon,
                            contour
                        };
                    }
                } else {
                    // ISO lines
                    const path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$contour$2d$layer$2f$marching$2d$squares$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLines"])(opts);
                    if (path.length > 0) {
                        contourLines[segmentIndex++] = {
                            vertices: path,
                            contour
                        };
                    }
                }
            }
        }
    }
    return {
        lines: contourLines,
        polygons: contourPolygons
    };
} /* eslint-enable max-depth */  //# sourceMappingURL=contour-utils.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregation-layer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$attribute$2f$attribute$2d$manager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__AttributeManager$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/lib/attribute/attribute-manager.js [app-client] (ecmascript) <export default as AttributeManager>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$composite$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__CompositeLayer$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/lib/composite-layer.js [app-client] (ecmascript) <export default as CompositeLayer>");
;
class AggregationLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$composite$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__CompositeLayer$3e$__["CompositeLayer"] {
    /** Allow this layer to participates in the draw cycle */ get isDrawable() {
        return true;
    }
    initializeState() {
        this.getAttributeManager().remove([
            'instancePickingColors'
        ]);
    }
    // Extend Layer.updateState to update the Aggregator instance
    // returns true if aggregator is changed
    updateState(params) {
        super.updateState(params);
        const aggregatorType = this.getAggregatorType();
        if (params.changeFlags.extensionsChanged || this.state.aggregatorType !== aggregatorType) {
            this.state.aggregator?.destroy();
            const aggregator = this.createAggregator(aggregatorType);
            aggregator.setProps({
                attributes: this.getAttributeManager()?.attributes
            });
            this.setState({
                aggregator,
                aggregatorType
            });
            return true;
        }
        return false;
    }
    // Override Layer.finalizeState to dispose the Aggregator instance
    finalizeState(context) {
        super.finalizeState(context);
        this.state.aggregator.destroy();
    }
    // Override Layer.updateAttributes to update the aggregator
    updateAttributes(changedAttributes) {
        const { aggregator } = this.state;
        aggregator.setProps({
            attributes: changedAttributes
        });
        for(const id in changedAttributes){
            this.onAttributeChange(id);
        }
        // In aggregator.update() the aggregator allocates the buffers to store its output
        // These buffers will be exposed by aggregator.getResults() and passed to the sublayers
        // Therefore update() must be called before renderLayers()
        // CPUAggregator's output is populated right here in update()
        // GPUAggregator's output is pre-allocated and populated in preDraw(), see comments below
        aggregator.update();
    }
    draw({ shaderModuleProps }) {
        // GPU aggregation needs `shaderModuleProps` for projection/filter uniforms which are only accessible at draw time
        // GPUAggregator's Buffers are pre-allocated during `update()` and passed down to the sublayer attributes in renderLayers()
        // Although the Buffers have been bound to the sublayer's Model, their content are not populated yet
        // GPUAggregator.preDraw() is called in the draw cycle here right before Buffers are used by sublayer.draw()
        const { aggregator } = this.state;
        // @ts-expect-error only used by GPU aggregators
        aggregator.setProps({
            shaderModuleProps
        });
        aggregator.preDraw();
    }
    // override CompositeLayer._getAttributeManager to create AttributeManager instance
    _getAttributeManager() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$attribute$2f$attribute$2d$manager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__AttributeManager$3e$__["AttributeManager"](this.context.device, {
            id: this.props.id,
            stats: this.context.stats
        });
    }
}
AggregationLayer.layerName = 'AggregationLayer';
const __TURBOPACK__default__export__ = AggregationLayer;
 //# sourceMappingURL=aggregation-layer.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/contour-layer/contour-layer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/webgl-aggregator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$shaderlib$2f$project32$2f$project32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__project32$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js [app-client] (ecmascript) <export default as project32>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$contour$2d$layer$2f$bin$2d$options$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/contour-layer/bin-options-uniforms.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$cpu$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/cpu-aggregator/cpu-aggregator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__deepEqual__as__$5f$deepEqual$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/utils/deep-equal.js [app-client] (ecmascript) <export deepEqual as _deepEqual>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$viewports$2f$viewport$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Viewport$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/viewports/viewport.js [app-client] (ecmascript) <export default as Viewport>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$bounds$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/utils/bounds-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$contour$2d$layer$2f$value$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/contour-layer/value-reader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$contour$2d$layer$2f$contour$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/contour-layer/contour-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$path$2d$layer$2f$path$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__PathLayer$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/layers/dist/path-layer/path-layer.js [app-client] (ecmascript) <export default as PathLayer>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$solid$2d$polygon$2d$layer$2f$solid$2d$polygon$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SolidPolygonLayer$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer.js [app-client] (ecmascript) <export default as SolidPolygonLayer>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@math.gl/core/dist/classes/matrix4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/lib/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregation$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregation-layer.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
const DEFAULT_COLOR = [
    255,
    255,
    255,
    255
];
const DEFAULT_STROKE_WIDTH = 1;
const defaultProps = {
    // grid aggregation
    cellSize: {
        type: 'number',
        min: 1,
        value: 1000
    },
    gridOrigin: {
        type: 'array',
        compare: true,
        value: [
            0,
            0
        ]
    },
    getPosition: {
        type: 'accessor',
        value: (x)=>x.position
    },
    getWeight: {
        type: 'accessor',
        value: 1
    },
    gpuAggregation: true,
    aggregation: 'SUM',
    // contour lines
    contours: {
        type: 'object',
        value: [
            {
                threshold: 1
            }
        ],
        optional: true,
        compare: 3
    },
    zOffset: 0.005
};
/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */ class GridLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregation$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    getAggregatorType() {
        return this.props.gpuAggregation && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLAggregator"].isSupported(this.context.device) ? 'gpu' : 'cpu';
    }
    createAggregator(type) {
        if (type === 'cpu') {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$cpu$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CPUAggregator"]({
                dimensions: 2,
                getBin: {
                    sources: [
                        'positions'
                    ],
                    getValue: ({ positions }, index, opts)=>{
                        const viewport = this.state.aggregatorViewport;
                        // project to common space
                        const p = viewport.projectPosition(positions);
                        const { cellSizeCommon, cellOriginCommon } = opts;
                        return [
                            Math.floor((p[0] - cellOriginCommon[0]) / cellSizeCommon[0]),
                            Math.floor((p[1] - cellOriginCommon[1]) / cellSizeCommon[1])
                        ];
                    }
                },
                getValue: [
                    {
                        sources: [
                            'counts'
                        ],
                        getValue: ({ counts })=>counts
                    }
                ],
                onUpdate: this._onAggregationUpdate.bind(this)
            });
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLAggregator"](this.context.device, {
            dimensions: 2,
            channelCount: 1,
            bufferLayout: this.getAttributeManager().getBufferLayouts({
                isInstanced: false
            }),
            ...super.getShaders({
                modules: [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$shaderlib$2f$project32$2f$project32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__project32$3e$__["project32"],
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$contour$2d$layer$2f$bin$2d$options$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["binOptionsUniforms"]
                ],
                vs: /* glsl */ `
  in vec3 positions;
  in vec3 positions64Low;
  in float counts;

  void getBin(out ivec2 binId) {
    vec3 positionCommon = project_position(positions, positions64Low);
    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);
    binId = ivec2(gridCoords);
  }
  void getValue(out float value) {
    value = counts;
  }
  `
            }),
            onUpdate: this._onAggregationUpdate.bind(this)
        });
    }
    initializeState() {
        super.initializeState();
        const attributeManager = this.getAttributeManager();
        attributeManager.add({
            positions: {
                size: 3,
                accessor: 'getPosition',
                type: 'float64',
                fp64: this.use64bitPositions()
            },
            counts: {
                size: 1,
                accessor: 'getWeight'
            }
        });
    }
    updateState(params) {
        const aggregatorChanged = super.updateState(params);
        const { props, oldProps, changeFlags } = params;
        const { aggregator } = this.state;
        if (aggregatorChanged || changeFlags.dataChanged || props.cellSize !== oldProps.cellSize || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__deepEqual__as__$5f$deepEqual$3e$__["_deepEqual"])(props.gridOrigin, oldProps.gridOrigin, 1) || props.aggregation !== oldProps.aggregation) {
            this._updateBinOptions();
            const { cellSizeCommon, cellOriginCommon, binIdRange } = this.state;
            aggregator.setProps({
                // @ts-expect-error only used by GPUAggregator
                binIdRange,
                pointCount: this.getNumInstances(),
                operations: [
                    props.aggregation
                ],
                binOptions: {
                    cellSizeCommon,
                    cellOriginCommon
                }
            });
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__deepEqual__as__$5f$deepEqual$3e$__["_deepEqual"])(oldProps.contours, props.contours, 2)) {
            // Recalculate contours
            this.setState({
                contourData: null
            });
        }
        return aggregatorChanged;
    }
    _updateBinOptions() {
        const bounds = this.getBounds();
        const cellSizeCommon = [
            1,
            1
        ];
        let cellOriginCommon = [
            0,
            0
        ];
        let binIdRange = [
            [
                0,
                1
            ],
            [
                0,
                1
            ]
        ];
        let viewport = this.context.viewport;
        if (bounds && Number.isFinite(bounds[0][0])) {
            let centroid = [
                (bounds[0][0] + bounds[1][0]) / 2,
                (bounds[0][1] + bounds[1][1]) / 2
            ];
            const { cellSize, gridOrigin } = this.props;
            const { unitsPerMeter } = viewport.getDistanceScales(centroid);
            cellSizeCommon[0] = unitsPerMeter[0] * cellSize;
            cellSizeCommon[1] = unitsPerMeter[1] * cellSize;
            // Offset common space to center at the origin of the grid cell where the data center is in
            // This improves precision without affecting the cell positions
            const centroidCommon = viewport.projectFlat(centroid);
            cellOriginCommon = [
                Math.floor((centroidCommon[0] - gridOrigin[0]) / cellSizeCommon[0]) * cellSizeCommon[0] + gridOrigin[0],
                Math.floor((centroidCommon[1] - gridOrigin[1]) / cellSizeCommon[1]) * cellSizeCommon[1] + gridOrigin[1]
            ];
            centroid = viewport.unprojectFlat(cellOriginCommon);
            const ViewportType = viewport.constructor;
            // We construct a viewport for the GPU aggregator's project module
            // This viewport is determined by data
            // removes arbitrary precision variance that depends on initial view state
            viewport = viewport.isGeospatial ? new ViewportType({
                longitude: centroid[0],
                latitude: centroid[1],
                zoom: 12
            }) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$viewports$2f$viewport$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Viewport$3e$__["Viewport"]({
                position: [
                    centroid[0],
                    centroid[1],
                    0
                ],
                zoom: 12
            });
            // Round to the nearest 32-bit float to match CPU and GPU results
            cellOriginCommon = [
                Math.fround(viewport.center[0]),
                Math.fround(viewport.center[1])
            ];
            binIdRange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$bounds$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBinIdRange"])({
                dataBounds: bounds,
                getBinId: (p)=>{
                    const positionCommon = viewport.projectFlat(p);
                    return [
                        Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]),
                        Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])
                    ];
                }
            });
        }
        this.setState({
            cellSizeCommon,
            cellOriginCommon,
            binIdRange,
            aggregatorViewport: viewport
        });
    }
    draw(opts) {
        // Replaces render time viewport with our own
        if (opts.shaderModuleProps.project) {
            opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;
        }
        super.draw(opts);
    }
    _onAggregationUpdate() {
        const { aggregator, binIdRange } = this.state;
        this.setState({
            aggregatedValueReader: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$contour$2d$layer$2f$value$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAggregatorValueReader"])({
                aggregator,
                binIdRange,
                channel: 0
            }),
            contourData: null
        });
    }
    _getContours() {
        const { aggregatedValueReader } = this.state;
        if (!aggregatedValueReader) {
            return null;
        }
        if (!this.state.contourData) {
            const { binIdRange } = this.state;
            const { contours } = this.props;
            const contourData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$contour$2d$layer$2f$contour$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["generateContours"])({
                contours,
                getValue: aggregatedValueReader,
                xRange: binIdRange[0],
                yRange: binIdRange[1]
            });
            this.state.contourData = contourData;
        }
        return this.state.contourData;
    }
    onAttributeChange(id) {
        const { aggregator } = this.state;
        switch(id){
            case 'positions':
                aggregator.setNeedsUpdate();
                this._updateBinOptions();
                const { cellSizeCommon, cellOriginCommon, binIdRange } = this.state;
                aggregator.setProps({
                    // @ts-expect-error only used by GPUAggregator
                    binIdRange,
                    binOptions: {
                        cellSizeCommon,
                        cellOriginCommon
                    }
                });
                break;
            case 'counts':
                aggregator.setNeedsUpdate(0);
                break;
            default:
        }
    }
    renderLayers() {
        const contourData = this._getContours();
        if (!contourData) {
            return null;
        }
        const { lines, polygons } = contourData;
        const { zOffset } = this.props;
        const { cellOriginCommon, cellSizeCommon } = this.state;
        const LinesSubLayerClass = this.getSubLayerClass('lines', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$path$2d$layer$2f$path$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__PathLayer$3e$__["PathLayer"]);
        const BandsSubLayerClass = this.getSubLayerClass('bands', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$solid$2d$polygon$2d$layer$2f$solid$2d$polygon$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SolidPolygonLayer$3e$__["SolidPolygonLayer"]);
        const modelMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]().translate([
            cellOriginCommon[0],
            cellOriginCommon[1],
            0
        ]).scale([
            cellSizeCommon[0],
            cellSizeCommon[1],
            zOffset
        ]);
        // Contour lines layer
        const lineLayer = lines && lines.length > 0 && new LinesSubLayerClass(this.getSubLayerProps({
            id: 'lines'
        }), {
            data: lines,
            coordinateSystem: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COORDINATE_SYSTEM"].CARTESIAN,
            modelMatrix,
            getPath: (d)=>d.vertices,
            getColor: (d)=>d.contour.color ?? DEFAULT_COLOR,
            getWidth: (d)=>d.contour.strokeWidth ?? DEFAULT_STROKE_WIDTH,
            widthUnits: 'pixels'
        });
        // Contour bands layer
        const bandsLayer = polygons && polygons.length > 0 && new BandsSubLayerClass(this.getSubLayerProps({
            id: 'bands'
        }), {
            data: polygons,
            coordinateSystem: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COORDINATE_SYSTEM"].CARTESIAN,
            modelMatrix,
            getPolygon: (d)=>d.vertices,
            getFillColor: (d)=>d.contour.color ?? DEFAULT_COLOR
        });
        return [
            lineLayer,
            bandsLayer
        ];
    }
    getPickingInfo(params) {
        const info = params.info;
        const { object } = info;
        if (object) {
            info.object = {
                contour: object.contour
            };
        }
        return info;
    }
}
GridLayer.layerName = 'ContourLayer';
GridLayer.defaultProps = defaultProps;
const __TURBOPACK__default__export__ = GridLayer;
 //# sourceMappingURL=contour-layer.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/grid-layer/bin-options-uniforms.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "binOptionsUniforms": (()=>binOptionsUniforms)
});
const uniformBlock = /* glsl */ `\
uniform binOptionsUniforms {
  vec2 cellOriginCommon;
  vec2 cellSizeCommon;
} binOptions;
`;
const binOptionsUniforms = {
    name: 'binOptions',
    vs: uniformBlock,
    uniformTypes: {
        cellOriginCommon: 'vec2<f32>',
        cellSizeCommon: 'vec2<f32>'
    }
}; //# sourceMappingURL=bin-options-uniforms.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/common/utils/scale-utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** Applies a scale to BinaryAttribute */ __turbopack_esm__({
    "AttributeWithScale": (()=>AttributeWithScale),
    "applyScaleOrdinal": (()=>applyScaleOrdinal),
    "applyScaleQuantile": (()=>applyScaleQuantile)
});
class AttributeWithScale {
    constructor(input, inputLength){
        this.props = {
            scaleType: 'linear',
            lowerPercentile: 0,
            upperPercentile: 100
        };
        /** [min, max] of attribute values, or null if unknown */ this.domain = null;
        /** Valid domain if lower/upper percentile are defined */ this.cutoff = null;
        this.input = input;
        this.inputLength = inputLength;
        // No processing is needed with the default scale
        this.attribute = input;
    }
    getScalePercentile() {
        if (!this._percentile) {
            const value = getAttributeValue(this.input, this.inputLength);
            this._percentile = applyScaleQuantile(value);
        }
        return this._percentile;
    }
    getScaleOrdinal() {
        if (!this._ordinal) {
            const value = getAttributeValue(this.input, this.inputLength);
            this._ordinal = applyScaleOrdinal(value);
        }
        return this._ordinal;
    }
    /** Returns the [lowerCutoff, upperCutoff] of scaled values, or null if not applicable */ getCutoff({ scaleType, lowerPercentile, upperPercentile }) {
        if (scaleType === 'quantile') {
            return [
                lowerPercentile,
                upperPercentile - 1
            ];
        }
        if (lowerPercentile > 0 || upperPercentile < 100) {
            const { domain: thresholds } = this.getScalePercentile();
            let lowValue = thresholds[Math.floor(lowerPercentile) - 1] ?? -Infinity;
            let highValue = thresholds[Math.floor(upperPercentile) - 1] ?? Infinity;
            if (scaleType === 'ordinal') {
                const { domain: sortedUniqueValues } = this.getScaleOrdinal();
                lowValue = sortedUniqueValues.findIndex((x)=>x >= lowValue);
                highValue = sortedUniqueValues.findIndex((x)=>x > highValue) - 1;
                if (highValue === -2) {
                    highValue = sortedUniqueValues.length - 1;
                }
            }
            return [
                lowValue,
                highValue
            ];
        }
        return null;
    }
    update(props) {
        const oldProps = this.props;
        if (props.scaleType !== oldProps.scaleType) {
            switch(props.scaleType){
                case 'quantile':
                    {
                        const { attribute } = this.getScalePercentile();
                        this.attribute = attribute;
                        this.domain = [
                            0,
                            99
                        ];
                        break;
                    }
                case 'ordinal':
                    {
                        const { attribute, domain } = this.getScaleOrdinal();
                        this.attribute = attribute;
                        this.domain = [
                            0,
                            domain.length - 1
                        ];
                        break;
                    }
                default:
                    this.attribute = this.input;
                    this.domain = null;
            }
        }
        if (props.scaleType !== oldProps.scaleType || props.lowerPercentile !== oldProps.lowerPercentile || props.upperPercentile !== oldProps.upperPercentile) {
            this.cutoff = this.getCutoff(props);
        }
        this.props = props;
        return this;
    }
}
function applyScaleOrdinal(values) {
    const uniqueValues = new Set();
    for (const x of values){
        if (Number.isFinite(x)) {
            uniqueValues.add(x);
        }
    }
    const sortedUniqueValues = Array.from(uniqueValues).sort();
    const domainMap = new Map();
    for(let i = 0; i < sortedUniqueValues.length; i++){
        domainMap.set(sortedUniqueValues[i], i);
    }
    return {
        attribute: {
            value: values.map((x)=>Number.isFinite(x) ? domainMap.get(x) : NaN),
            type: 'float32',
            size: 1
        },
        domain: sortedUniqueValues
    };
}
function applyScaleQuantile(values, rangeLength = 100) {
    const sortedValues = Array.from(values).filter(Number.isFinite).sort(ascending);
    let i = 0;
    const n = Math.max(1, rangeLength);
    const thresholds = new Array(n - 1);
    while(++i < n){
        thresholds[i - 1] = threshold(sortedValues, i / n);
    }
    return {
        attribute: {
            value: values.map((x)=>Number.isFinite(x) ? bisectRight(thresholds, x) : NaN),
            type: 'float32',
            size: 1
        },
        domain: thresholds
    };
}
function getAttributeValue(attribute, length) {
    const elementStride = (attribute.stride ?? 4) / 4;
    const elementOffset = (attribute.offset ?? 0) / 4;
    let value = attribute.value;
    if (!value) {
        const bytes = attribute.buffer?.readSyncWebGL(0, elementStride * 4 * length);
        if (bytes) {
            value = new Float32Array(bytes.buffer);
            attribute.value = value;
        }
    }
    if (elementStride === 1) {
        return value.subarray(0, length);
    }
    const result = new Float32Array(length);
    for(let i = 0; i < length; i++){
        result[i] = value[i * elementStride + elementOffset];
    }
    return result;
}
function ascending(a, b) {
    return a - b;
}
function threshold(domain, fraction) {
    const domainLength = domain.length;
    if (fraction <= 0 || domainLength < 2) {
        return domain[0];
    }
    if (fraction >= 1) {
        return domain[domainLength - 1];
    }
    const domainFraction = (domainLength - 1) * fraction;
    const lowIndex = Math.floor(domainFraction);
    const low = domain[lowIndex];
    const high = domain[lowIndex + 1];
    return low + (high - low) * (domainFraction - lowIndex);
}
function bisectRight(a, x) {
    let lo = 0;
    let hi = a.length;
    while(lo < hi){
        const mid = lo + hi >>> 1;
        if (a[mid] > x) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return lo;
} //# sourceMappingURL=scale-utils.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/grid-layer/grid-layer-uniforms.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "gridUniforms": (()=>gridUniforms)
});
const uniformBlock = /* glsl */ `\
uniform gridUniforms {
  vec4 colorDomain;
  vec4 elevationDomain;
  vec2 elevationRange;
  vec2 originCommon;
  vec2 sizeCommon;
} grid;
`;
const gridUniforms = {
    name: 'grid',
    vs: uniformBlock,
    uniformTypes: {
        colorDomain: 'vec4<f32>',
        elevationDomain: 'vec4<f32>',
        elevationRange: 'vec2<f32>',
        originCommon: 'vec2<f32>',
        sizeCommon: 'vec2<f32>'
    }
}; //# sourceMappingURL=grid-layer-uniforms.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/grid-layer/grid-cell-layer-vertex.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = /* glsl */ `#version 300 es
#define SHADER_NAME grid-cell-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec2 instancePositions;
in float instanceElevationValues;
in float instanceColorValues;
in vec3 instancePickingColors;
uniform sampler2D colorRange;
out vec4 vColor;
float interp(float value, vec2 domain, vec2 range) {
float r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);
return mix(range.x, range.y, r);
}
vec4 interp(float value, vec2 domain, sampler2D range) {
float r = (value - domain.x) / (domain.y - domain.x);
return texture(range, vec2(r, 0.5));
}
void main(void) {
geometry.pickingColor = instancePickingColors;
if (isnan(instanceColorValues) ||
instanceColorValues < grid.colorDomain.z ||
instanceColorValues > grid.colorDomain.w ||
instanceElevationValues < grid.elevationDomain.z ||
instanceElevationValues > grid.elevationDomain.w
) {
gl_Position = vec4(0.);
return;
}
vec2 commonPosition = (instancePositions + (positions.xy + 1.0) / 2.0 * column.coverage) * grid.sizeCommon + grid.originCommon - project.commonOrigin.xy;
geometry.position = vec4(commonPosition, 0.0, 1.0);
geometry.normal = project_normal(normals);
float elevation = 0.0;
if (column.extruded) {
elevation = interp(instanceElevationValues, grid.elevationDomain.xy, grid.elevationRange);
elevation = project_size(elevation);
geometry.position.z = (positions.z + 1.0) / 2.0 * elevation;
}
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vColor = interp(instanceColorValues, grid.colorDomain.xy, colorRange);
vColor.a *= layer.opacity;
if (column.extruded) {
vColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;
 //# sourceMappingURL=grid-cell-layer-vertex.glsl.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/grid-layer/grid-cell-layer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "GridCellLayer": (()=>GridCellLayer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$grid$2d$layer$2f$grid$2d$layer$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/grid-layer/grid-layer-uniforms.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$grid$2d$layer$2f$grid$2d$cell$2d$layer$2d$vertex$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/grid-layer/grid-cell-layer-vertex.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/utils/color-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$geometries$2f$cube$2d$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/geometries/cube-geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$column$2d$layer$2f$column$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ColumnLayer$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/layers/dist/column-layer/column-layer.js [app-client] (ecmascript) <export default as ColumnLayer>");
;
;
;
;
;
class GridCellLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$column$2d$layer$2f$column$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ColumnLayer$3e$__["ColumnLayer"] {
    getShaders() {
        const shaders = super.getShaders();
        shaders.modules.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$grid$2d$layer$2f$grid$2d$layer$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gridUniforms"]);
        return {
            ...shaders,
            vs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$grid$2d$layer$2f$grid$2d$cell$2d$layer$2d$vertex$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
        };
    }
    initializeState() {
        super.initializeState();
        const attributeManager = this.getAttributeManager();
        attributeManager.remove([
            'instanceElevations',
            'instanceFillColors',
            'instanceLineColors',
            'instanceStrokeWidths'
        ]);
        attributeManager.addInstanced({
            instancePositions: {
                size: 2,
                type: 'float32',
                accessor: 'getBin'
            },
            instanceColorValues: {
                size: 1,
                type: 'float32',
                accessor: 'getColorValue'
            },
            instanceElevationValues: {
                size: 1,
                type: 'float32',
                accessor: 'getElevationValue'
            }
        });
    }
    updateState(params) {
        super.updateState(params);
        const { props, oldProps } = params;
        const model = this.state.fillModel;
        if (oldProps.colorRange !== props.colorRange) {
            this.state.colorTexture?.destroy();
            this.state.colorTexture = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createColorRangeTexture"])(this.context.device, props.colorRange, props.colorScaleType);
            const gridProps = {
                colorRange: this.state.colorTexture
            };
            model.shaderInputs.setProps({
                grid: gridProps
            });
        } else if (oldProps.colorScaleType !== props.colorScaleType) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["updateColorRangeTexture"])(this.state.colorTexture, props.colorScaleType);
        }
    }
    finalizeState(context) {
        super.finalizeState(context);
        this.state.colorTexture?.destroy();
    }
    _updateGeometry() {
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$geometries$2f$cube$2d$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CubeGeometry"]();
        this.state.fillModel.setGeometry(geometry);
    }
    draw({ uniforms }) {
        const { cellOriginCommon, cellSizeCommon, elevationRange, elevationScale, extruded, coverage, colorDomain, elevationDomain } = this.props;
        const colorCutoff = this.props.colorCutoff || [
            -Infinity,
            Infinity
        ];
        const elevationCutoff = this.props.elevationCutoff || [
            -Infinity,
            Infinity
        ];
        const fillModel = this.state.fillModel;
        const gridProps = {
            colorDomain: [
                Math.max(colorDomain[0], colorCutoff[0]),
                Math.min(colorDomain[1], colorCutoff[1]),
                Math.max(colorDomain[0] - 1, colorCutoff[0]),
                Math.min(colorDomain[1] + 1, colorCutoff[1]) // hide cell if instanceColorValue is greater than this
            ],
            elevationDomain: [
                Math.max(elevationDomain[0], elevationCutoff[0]),
                Math.min(elevationDomain[1], elevationCutoff[1]),
                Math.max(elevationDomain[0] - 1, elevationCutoff[0]),
                Math.min(elevationDomain[1] + 1, elevationCutoff[1]) // hide cell if instanceElevationValue is greater than this
            ],
            elevationRange: [
                elevationRange[0] * elevationScale,
                elevationRange[1] * elevationScale
            ],
            originCommon: cellOriginCommon,
            sizeCommon: cellSizeCommon
        };
        fillModel.shaderInputs.setProps({
            column: {
                extruded,
                coverage
            },
            grid: gridProps
        });
        fillModel.draw(this.context.renderPass);
    }
}
GridCellLayer.layerName = 'GridCellLayer'; //# sourceMappingURL=grid-cell-layer.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/grid-layer/grid-layer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/utils/color-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/webgl-aggregator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__log$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/utils/log.js [app-client] (ecmascript) <export default as log>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$shaderlib$2f$project32$2f$project32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__project32$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js [app-client] (ecmascript) <export default as project32>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$grid$2d$layer$2f$bin$2d$options$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/grid-layer/bin-options-uniforms.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$cpu$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/cpu-aggregator/cpu-aggregator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$iterable$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/utils/iterable-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$viewports$2f$viewport$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Viewport$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/viewports/viewport.js [app-client] (ecmascript) <export default as Viewport>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$bounds$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/utils/bounds-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$scale$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/utils/scale-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$grid$2d$layer$2f$grid$2d$cell$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/grid-layer/grid-cell-layer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregation$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregation-layer.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
// eslint-disable-next-line @typescript-eslint/no-empty-function
function noop() {}
const defaultProps = {
    gpuAggregation: true,
    // color
    colorDomain: null,
    colorRange: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultColorRange"],
    getColorValue: {
        type: 'accessor',
        value: null
    },
    getColorWeight: {
        type: 'accessor',
        value: 1
    },
    colorAggregation: 'SUM',
    lowerPercentile: {
        type: 'number',
        min: 0,
        max: 100,
        value: 0
    },
    upperPercentile: {
        type: 'number',
        min: 0,
        max: 100,
        value: 100
    },
    colorScaleType: 'quantize',
    onSetColorDomain: noop,
    // elevation
    elevationDomain: null,
    elevationRange: [
        0,
        1000
    ],
    getElevationValue: {
        type: 'accessor',
        value: null
    },
    getElevationWeight: {
        type: 'accessor',
        value: 1
    },
    elevationAggregation: 'SUM',
    elevationScale: {
        type: 'number',
        min: 0,
        value: 1
    },
    elevationLowerPercentile: {
        type: 'number',
        min: 0,
        max: 100,
        value: 0
    },
    elevationUpperPercentile: {
        type: 'number',
        min: 0,
        max: 100,
        value: 100
    },
    elevationScaleType: 'linear',
    onSetElevationDomain: noop,
    // grid
    cellSize: {
        type: 'number',
        min: 0,
        value: 1000
    },
    coverage: {
        type: 'number',
        min: 0,
        max: 1,
        value: 1
    },
    getPosition: {
        type: 'accessor',
        value: (x)=>x.position
    },
    gridAggregator: {
        type: 'function',
        optional: true,
        value: null
    },
    extruded: false,
    // Optional material for 'lighting' shader module
    material: true
};
/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */ class GridLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregation$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    getAggregatorType() {
        const { gpuAggregation, gridAggregator, getColorValue, getElevationValue } = this.props;
        if (gpuAggregation && (gridAggregator || getColorValue || getElevationValue)) {
            // If these features are desired by the app, the user should explicitly use CPU aggregation
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__log$3e$__["log"].warn('Features not supported by GPU aggregation, falling back to CPU')();
            return 'cpu';
        }
        if (// GPU aggregation is requested
        gpuAggregation && // GPU aggregation is supported by the device
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLAggregator"].isSupported(this.context.device)) {
            return 'gpu';
        }
        return 'cpu';
    }
    createAggregator(type) {
        if (type === 'cpu') {
            const { gridAggregator, cellSize } = this.props;
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$cpu$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CPUAggregator"]({
                dimensions: 2,
                getBin: {
                    sources: [
                        'positions'
                    ],
                    getValue: ({ positions }, index, opts)=>{
                        if (gridAggregator) {
                            return gridAggregator(positions, cellSize);
                        }
                        const viewport = this.state.aggregatorViewport;
                        // project to common space
                        const p = viewport.projectPosition(positions);
                        const { cellSizeCommon, cellOriginCommon } = opts;
                        return [
                            Math.floor((p[0] - cellOriginCommon[0]) / cellSizeCommon[0]),
                            Math.floor((p[1] - cellOriginCommon[1]) / cellSizeCommon[1])
                        ];
                    }
                },
                getValue: [
                    {
                        sources: [
                            'colorWeights'
                        ],
                        getValue: ({ colorWeights })=>colorWeights
                    },
                    {
                        sources: [
                            'elevationWeights'
                        ],
                        getValue: ({ elevationWeights })=>elevationWeights
                    }
                ]
            });
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLAggregator"](this.context.device, {
            dimensions: 2,
            channelCount: 2,
            bufferLayout: this.getAttributeManager().getBufferLayouts({
                isInstanced: false
            }),
            ...super.getShaders({
                modules: [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$shaderlib$2f$project32$2f$project32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__project32$3e$__["project32"],
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$grid$2d$layer$2f$bin$2d$options$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["binOptionsUniforms"]
                ],
                vs: /* glsl */ `
  in vec3 positions;
  in vec3 positions64Low;
  in float colorWeights;
  in float elevationWeights;

  void getBin(out ivec2 binId) {
    vec3 positionCommon = project_position(positions, positions64Low);
    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);
    binId = ivec2(gridCoords);
  }
  void getValue(out vec2 value) {
    value = vec2(colorWeights, elevationWeights);
  }
  `
            })
        });
    }
    initializeState() {
        super.initializeState();
        const attributeManager = this.getAttributeManager();
        attributeManager.add({
            positions: {
                size: 3,
                accessor: 'getPosition',
                type: 'float64',
                fp64: this.use64bitPositions()
            },
            colorWeights: {
                size: 1,
                accessor: 'getColorWeight'
            },
            elevationWeights: {
                size: 1,
                accessor: 'getElevationWeight'
            }
        });
    }
    updateState(params) {
        const aggregatorChanged = super.updateState(params);
        const { props, oldProps, changeFlags } = params;
        const { aggregator } = this.state;
        if ((changeFlags.dataChanged || !this.state.dataAsArray) && (props.getColorValue || props.getElevationValue)) {
            // Convert data to array
            this.state.dataAsArray = Array.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$iterable$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createIterable"])(props.data).iterable);
        }
        if (aggregatorChanged || changeFlags.dataChanged || props.cellSize !== oldProps.cellSize || props.getColorValue !== oldProps.getColorValue || props.getElevationValue !== oldProps.getElevationValue || props.colorAggregation !== oldProps.colorAggregation || props.elevationAggregation !== oldProps.elevationAggregation) {
            this._updateBinOptions();
            const { cellSizeCommon, cellOriginCommon, binIdRange, dataAsArray } = this.state;
            aggregator.setProps({
                // @ts-expect-error only used by GPUAggregator
                binIdRange,
                pointCount: this.getNumInstances(),
                operations: [
                    props.colorAggregation,
                    props.elevationAggregation
                ],
                binOptions: {
                    cellSizeCommon,
                    cellOriginCommon
                },
                onUpdate: this._onAggregationUpdate.bind(this)
            });
            if (dataAsArray) {
                const { getColorValue, getElevationValue } = this.props;
                aggregator.setProps({
                    // @ts-expect-error only used by CPUAggregator
                    customOperations: [
                        getColorValue && ((indices)=>getColorValue(indices.map((i)=>dataAsArray[i]), {
                                indices,
                                data: props.data
                            })),
                        getElevationValue && ((indices)=>getElevationValue(indices.map((i)=>dataAsArray[i]), {
                                indices,
                                data: props.data
                            }))
                    ]
                });
            }
        }
        if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {
            aggregator.setNeedsUpdate(0);
        }
        if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {
            aggregator.setNeedsUpdate(1);
        }
        return aggregatorChanged;
    }
    _updateBinOptions() {
        const bounds = this.getBounds();
        const cellSizeCommon = [
            1,
            1
        ];
        let cellOriginCommon = [
            0,
            0
        ];
        let binIdRange = [
            [
                0,
                1
            ],
            [
                0,
                1
            ]
        ];
        let viewport = this.context.viewport;
        if (bounds && Number.isFinite(bounds[0][0])) {
            let centroid = [
                (bounds[0][0] + bounds[1][0]) / 2,
                (bounds[0][1] + bounds[1][1]) / 2
            ];
            const { cellSize } = this.props;
            const { unitsPerMeter } = viewport.getDistanceScales(centroid);
            cellSizeCommon[0] = unitsPerMeter[0] * cellSize;
            cellSizeCommon[1] = unitsPerMeter[1] * cellSize;
            // Offset common space to center at the origin of the grid cell where the data center is in
            // This improves precision without affecting the cell positions
            const centroidCommon = viewport.projectFlat(centroid);
            cellOriginCommon = [
                Math.floor(centroidCommon[0] / cellSizeCommon[0]) * cellSizeCommon[0],
                Math.floor(centroidCommon[1] / cellSizeCommon[1]) * cellSizeCommon[1]
            ];
            centroid = viewport.unprojectFlat(cellOriginCommon);
            const ViewportType = viewport.constructor;
            // We construct a viewport for the GPU aggregator's project module
            // This viewport is determined by data
            // removes arbitrary precision variance that depends on initial view state
            viewport = viewport.isGeospatial ? new ViewportType({
                longitude: centroid[0],
                latitude: centroid[1],
                zoom: 12
            }) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$viewports$2f$viewport$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Viewport$3e$__["Viewport"]({
                position: [
                    centroid[0],
                    centroid[1],
                    0
                ],
                zoom: 12
            });
            // Round to the nearest 32-bit float to match CPU and GPU results
            cellOriginCommon = [
                Math.fround(viewport.center[0]),
                Math.fround(viewport.center[1])
            ];
            binIdRange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$bounds$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBinIdRange"])({
                dataBounds: bounds,
                getBinId: (p)=>{
                    const positionCommon = viewport.projectFlat(p);
                    return [
                        Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]),
                        Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])
                    ];
                }
            });
        }
        this.setState({
            cellSizeCommon,
            cellOriginCommon,
            binIdRange,
            aggregatorViewport: viewport
        });
    }
    draw(opts) {
        // Replaces render time viewport with our own
        if (opts.shaderModuleProps.project) {
            opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;
        }
        super.draw(opts);
    }
    _onAggregationUpdate({ channel }) {
        const props = this.getCurrentLayer().props;
        const { aggregator } = this.state;
        if (channel === 0) {
            const result = aggregator.getResult(0);
            this.setState({
                colors: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$scale$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AttributeWithScale"](result, aggregator.binCount)
            });
            props.onSetColorDomain(aggregator.getResultDomain(0));
        } else if (channel === 1) {
            const result = aggregator.getResult(1);
            this.setState({
                elevations: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$scale$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AttributeWithScale"](result, aggregator.binCount)
            });
            props.onSetElevationDomain(aggregator.getResultDomain(1));
        }
    }
    onAttributeChange(id) {
        const { aggregator } = this.state;
        switch(id){
            case 'positions':
                aggregator.setNeedsUpdate();
                this._updateBinOptions();
                const { cellSizeCommon, cellOriginCommon, binIdRange } = this.state;
                aggregator.setProps({
                    // @ts-expect-error only used by GPUAggregator
                    binIdRange,
                    binOptions: {
                        cellSizeCommon,
                        cellOriginCommon
                    }
                });
                break;
            case 'colorWeights':
                aggregator.setNeedsUpdate(0);
                break;
            case 'elevationWeights':
                aggregator.setNeedsUpdate(1);
                break;
            default:
        }
    }
    renderLayers() {
        const { aggregator, cellOriginCommon, cellSizeCommon } = this.state;
        const { elevationScale, colorRange, elevationRange, extruded, coverage, material, transitions, colorScaleType, lowerPercentile, upperPercentile, colorDomain, elevationScaleType, elevationLowerPercentile, elevationUpperPercentile, elevationDomain } = this.props;
        const CellLayerClass = this.getSubLayerClass('cells', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$grid$2d$layer$2f$grid$2d$cell$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GridCellLayer"]);
        const binAttribute = aggregator.getBins();
        const colors = this.state.colors?.update({
            scaleType: colorScaleType,
            lowerPercentile,
            upperPercentile
        });
        const elevations = this.state.elevations?.update({
            scaleType: elevationScaleType,
            lowerPercentile: elevationLowerPercentile,
            upperPercentile: elevationUpperPercentile
        });
        if (!colors || !elevations) {
            return null;
        }
        return new CellLayerClass(this.getSubLayerProps({
            id: 'cells'
        }), {
            data: {
                length: aggregator.binCount,
                attributes: {
                    getBin: binAttribute,
                    getColorValue: colors.attribute,
                    getElevationValue: elevations.attribute
                }
            },
            // Data has changed shallowly, but we likely don't need to update the attributes
            dataComparator: (data, oldData)=>data.length === oldData.length,
            updateTriggers: {
                getBin: [
                    binAttribute
                ],
                getColorValue: [
                    colors.attribute
                ],
                getElevationValue: [
                    elevations.attribute
                ]
            },
            cellOriginCommon,
            cellSizeCommon,
            elevationScale,
            colorRange,
            colorScaleType,
            elevationRange,
            extruded,
            coverage,
            material,
            colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),
            elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),
            colorCutoff: colors.cutoff,
            elevationCutoff: elevations.cutoff,
            transitions: transitions && {
                getFillColor: transitions.getColorValue || transitions.getColorWeight,
                getElevation: transitions.getElevationValue || transitions.getElevationWeight
            },
            // Extensions are already handled by the GPUAggregator, do not pass it down
            extensions: []
        });
    }
    getPickingInfo(params) {
        const info = params.info;
        const { index } = info;
        if (index >= 0) {
            const bin = this.state.aggregator.getBin(index);
            let object;
            if (bin) {
                object = {
                    col: bin.id[0],
                    row: bin.id[1],
                    colorValue: bin.value[0],
                    elevationValue: bin.value[1],
                    count: bin.count
                };
                if (bin.pointIndices) {
                    object.pointIndices = bin.pointIndices;
                    object.points = Array.isArray(this.props.data) ? bin.pointIndices.map((i)=>this.props.data[i]) : [];
                }
            }
            info.object = object;
        }
        return info;
    }
}
GridLayer.layerName = 'GridLayer';
GridLayer.defaultProps = defaultProps;
const __TURBOPACK__default__export__ = GridLayer;
 //# sourceMappingURL=grid-layer.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/bin-options-uniforms.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "binOptionsUniforms": (()=>binOptionsUniforms)
});
const uniformBlock = /* glsl */ `\
uniform binOptionsUniforms {
  vec2 hexOriginCommon;
  float radiusCommon;
} binOptions;
`;
const binOptionsUniforms = {
    name: 'binOptions',
    vs: uniformBlock,
    uniformTypes: {
        hexOriginCommon: 'vec2<f32>',
        radiusCommon: 'f32'
    }
}; //# sourceMappingURL=bin-options-uniforms.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/hexbin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "HexbinVertices": (()=>HexbinVertices),
    "getHexbinCentroid": (()=>getHexbinCentroid),
    "getHexbinCentroidGLSL": (()=>getHexbinCentroidGLSL),
    "pointToHexbin": (()=>pointToHexbin),
    "pointToHexbinGLSL": (()=>pointToHexbinGLSL)
});
const THIRD_PI = Math.PI / 3;
const DIST_X = 2 * Math.sin(THIRD_PI);
const DIST_Y = 1.5;
const HexbinVertices = Array.from({
    length: 6
}, (_, i)=>{
    const angle = i * THIRD_PI;
    return [
        Math.sin(angle),
        -Math.cos(angle)
    ];
});
function pointToHexbin([px, py], radius) {
    let pj = Math.round(py = py / radius / DIST_Y);
    let pi = Math.round(px = px / radius / DIST_X - (pj & 1) / 2);
    const py1 = py - pj;
    if (Math.abs(py1) * 3 > 1) {
        const px1 = px - pi;
        const pi2 = pi + (px < pi ? -1 : 1) / 2;
        const pj2 = pj + (py < pj ? -1 : 1);
        const px2 = px - pi2;
        const py2 = py - pj2;
        if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) {
            pi = pi2 + (pj & 1 ? 1 : -1) / 2;
            pj = pj2;
        }
    }
    return [
        pi,
        pj
    ];
}
const pointToHexbinGLSL = /* glsl */ `
const vec2 DIST = vec2(${DIST_X}, ${DIST_Y});

ivec2 pointToHexbin(vec2 p, float radius) {
  p /= radius * DIST;
  float pj = round(p.y);
  float pjm2 = mod(pj, 2.0);
  p.x -= pjm2 * 0.5;
  float pi = round(p.x);
  vec2 d1 = p - vec2(pi, pj);

  if (abs(d1.y) * 3. > 1.) {
    vec2 v2 = step(0.0, d1) - 0.5;
    v2.y *= 2.0;
    vec2 d2 = d1 - v2;
    if (dot(d1, d1) > dot(d2, d2)) {
      pi += v2.x + pjm2 - 0.5;
      pj += v2.y;
    }
  }
  return ivec2(pi, pj);
}
`;
function getHexbinCentroid([i, j], radius) {
    return [
        (i + (j & 1) / 2) * radius * DIST_X,
        j * radius * DIST_Y
    ];
}
const getHexbinCentroidGLSL = `
const vec2 DIST = vec2(${DIST_X}, ${DIST_Y});

vec2 hexbinCentroid(vec2 binId, float radius) {
  binId.x += fract(binId.y * 0.5);
  return binId * DIST * radius;
}
`; //# sourceMappingURL=hexbin.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/hexagon-layer-uniforms.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "hexagonUniforms": (()=>hexagonUniforms)
});
const uniformBlock = /* glsl */ `\
uniform hexagonUniforms {
  vec4 colorDomain;
  vec4 elevationDomain;
  vec2 elevationRange;
  vec2 originCommon;
} hexagon;
`;
const hexagonUniforms = {
    name: 'hexagon',
    vs: uniformBlock,
    uniformTypes: {
        colorDomain: 'vec4<f32>',
        elevationDomain: 'vec4<f32>',
        elevationRange: 'vec2<f32>',
        originCommon: 'vec2<f32>'
    }
}; //# sourceMappingURL=hexagon-layer-uniforms.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/hexagon-cell-layer-vertex.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexbin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/hexbin.js [app-client] (ecmascript)");
;
const __TURBOPACK__default__export__ = /* glsl */ `\
#version 300 es
#define SHADER_NAME hexagon-cell-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec2 instancePositions;
in float instanceElevationValues;
in float instanceColorValues;
in vec3 instancePickingColors;
uniform sampler2D colorRange;
out vec4 vColor;
${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexbin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getHexbinCentroidGLSL"]}
float interp(float value, vec2 domain, vec2 range) {
float r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);
return mix(range.x, range.y, r);
}
vec4 interp(float value, vec2 domain, sampler2D range) {
float r = (value - domain.x) / (domain.y - domain.x);
return texture(range, vec2(r, 0.5));
}
void main(void) {
geometry.pickingColor = instancePickingColors;
if (isnan(instanceColorValues) ||
instanceColorValues < hexagon.colorDomain.z ||
instanceColorValues > hexagon.colorDomain.w ||
instanceElevationValues < hexagon.elevationDomain.z ||
instanceElevationValues > hexagon.elevationDomain.w
) {
gl_Position = vec4(0.);
return;
}
vec2 commonPosition = hexbinCentroid(instancePositions, column.radius) + (hexagon.originCommon - project.commonOrigin.xy);
commonPosition += positions.xy * column.radius * column.coverage;
geometry.position = vec4(commonPosition, 0.0, 1.0);
geometry.normal = project_normal(normals);
float elevation = 0.0;
if (column.extruded) {
elevation = interp(instanceElevationValues, hexagon.elevationDomain.xy, hexagon.elevationRange);
elevation = project_size(elevation);
geometry.position.z = (positions.z + 1.0) / 2.0 * elevation;
}
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vColor = interp(instanceColorValues, hexagon.colorDomain.xy, colorRange);
vColor.a *= layer.opacity;
if (column.extruded) {
vColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;
 //# sourceMappingURL=hexagon-cell-layer-vertex.glsl.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/hexagon-cell-layer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexagon$2d$layer$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/hexagon-layer-uniforms.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexagon$2d$cell$2d$layer$2d$vertex$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/hexagon-cell-layer-vertex.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/utils/color-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$column$2d$layer$2f$column$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ColumnLayer$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/layers/dist/column-layer/column-layer.js [app-client] (ecmascript) <export default as ColumnLayer>");
;
;
;
;
class HexagonCellLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$column$2d$layer$2f$column$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ColumnLayer$3e$__["ColumnLayer"] {
    getShaders() {
        const shaders = super.getShaders();
        shaders.modules.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexagon$2d$layer$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hexagonUniforms"]);
        return {
            ...shaders,
            vs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexagon$2d$cell$2d$layer$2d$vertex$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
        };
    }
    initializeState() {
        super.initializeState();
        const attributeManager = this.getAttributeManager();
        attributeManager.remove([
            'instanceElevations',
            'instanceFillColors',
            'instanceLineColors',
            'instanceStrokeWidths'
        ]);
        attributeManager.addInstanced({
            instancePositions: {
                size: 2,
                type: 'float32',
                accessor: 'getBin'
            },
            instanceColorValues: {
                size: 1,
                type: 'float32',
                accessor: 'getColorValue'
            },
            instanceElevationValues: {
                size: 1,
                type: 'float32',
                accessor: 'getElevationValue'
            }
        });
    }
    updateState(params) {
        super.updateState(params);
        const { props, oldProps } = params;
        const model = this.state.fillModel;
        if (oldProps.colorRange !== props.colorRange) {
            this.state.colorTexture?.destroy();
            this.state.colorTexture = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createColorRangeTexture"])(this.context.device, props.colorRange, props.colorScaleType);
            const hexagonProps = {
                colorRange: this.state.colorTexture
            };
            model.shaderInputs.setProps({
                hexagon: hexagonProps
            });
        } else if (oldProps.colorScaleType !== props.colorScaleType) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["updateColorRangeTexture"])(this.state.colorTexture, props.colorScaleType);
        }
    }
    finalizeState(context) {
        super.finalizeState(context);
        this.state.colorTexture?.destroy();
    }
    draw({ uniforms }) {
        const { radius, hexOriginCommon, elevationRange, elevationScale, extruded, coverage, colorDomain, elevationDomain } = this.props;
        const colorCutoff = this.props.colorCutoff || [
            -Infinity,
            Infinity
        ];
        const elevationCutoff = this.props.elevationCutoff || [
            -Infinity,
            Infinity
        ];
        const fillModel = this.state.fillModel;
        if (fillModel.vertexArray.indexBuffer) {
            // indices are for drawing wireframe, disable them
            // TODO - this should be handled in ColumnLayer?
            fillModel.setIndexBuffer(null);
        }
        fillModel.setVertexCount(this.state.fillVertexCount);
        const hexagonProps = {
            colorDomain: [
                Math.max(colorDomain[0], colorCutoff[0]),
                Math.min(colorDomain[1], colorCutoff[1]),
                Math.max(colorDomain[0] - 1, colorCutoff[0]),
                Math.min(colorDomain[1] + 1, colorCutoff[1]) // hide cell if instanceColorValue is greater than this
            ],
            elevationDomain: [
                Math.max(elevationDomain[0], elevationCutoff[0]),
                Math.min(elevationDomain[1], elevationCutoff[1]),
                Math.max(elevationDomain[0] - 1, elevationCutoff[0]),
                Math.min(elevationDomain[1] + 1, elevationCutoff[1]) // hide cell if instanceElevationValue is greater than this
            ],
            elevationRange: [
                elevationRange[0] * elevationScale,
                elevationRange[1] * elevationScale
            ],
            originCommon: hexOriginCommon
        };
        fillModel.shaderInputs.setProps({
            column: {
                extruded,
                coverage,
                radius
            },
            hexagon: hexagonProps
        });
        fillModel.draw(this.context.renderPass);
    }
}
HexagonCellLayer.layerName = 'HexagonCellLayer';
const __TURBOPACK__default__export__ = HexagonCellLayer;
 //# sourceMappingURL=hexagon-cell-layer.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/hexagon-layer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/utils/color-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/webgl-aggregator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__log$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/utils/log.js [app-client] (ecmascript) <export default as log>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$shaderlib$2f$project32$2f$project32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__project32$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js [app-client] (ecmascript) <export default as project32>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$bin$2d$options$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/bin-options-uniforms.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexbin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/hexbin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$cpu$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/cpu-aggregator/cpu-aggregator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$iterable$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/utils/iterable-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$viewports$2f$viewport$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Viewport$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/viewports/viewport.js [app-client] (ecmascript) <export default as Viewport>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$bounds$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/utils/bounds-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$scale$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/utils/scale-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexagon$2d$cell$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/hexagon-cell-layer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregation$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregation-layer.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
// eslint-disable-next-line @typescript-eslint/no-empty-function
function noop() {}
const defaultProps = {
    gpuAggregation: true,
    // color
    colorDomain: null,
    colorRange: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultColorRange"],
    getColorValue: {
        type: 'accessor',
        value: null
    },
    getColorWeight: {
        type: 'accessor',
        value: 1
    },
    colorAggregation: 'SUM',
    lowerPercentile: {
        type: 'number',
        min: 0,
        max: 100,
        value: 0
    },
    upperPercentile: {
        type: 'number',
        min: 0,
        max: 100,
        value: 100
    },
    colorScaleType: 'quantize',
    onSetColorDomain: noop,
    // elevation
    elevationDomain: null,
    elevationRange: [
        0,
        1000
    ],
    getElevationValue: {
        type: 'accessor',
        value: null
    },
    getElevationWeight: {
        type: 'accessor',
        value: 1
    },
    elevationAggregation: 'SUM',
    elevationScale: {
        type: 'number',
        min: 0,
        value: 1
    },
    elevationLowerPercentile: {
        type: 'number',
        min: 0,
        max: 100,
        value: 0
    },
    elevationUpperPercentile: {
        type: 'number',
        min: 0,
        max: 100,
        value: 100
    },
    elevationScaleType: 'linear',
    onSetElevationDomain: noop,
    // hexbin
    radius: {
        type: 'number',
        min: 1,
        value: 1000
    },
    coverage: {
        type: 'number',
        min: 0,
        max: 1,
        value: 1
    },
    getPosition: {
        type: 'accessor',
        value: (x)=>x.position
    },
    hexagonAggregator: {
        type: 'function',
        optional: true,
        value: null
    },
    extruded: false,
    // Optional material for 'lighting' shader module
    material: true
};
/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */ class HexagonLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregation$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    getAggregatorType() {
        const { gpuAggregation, hexagonAggregator, getColorValue, getElevationValue } = this.props;
        if (gpuAggregation && (hexagonAggregator || getColorValue || getElevationValue)) {
            // If these features are desired by the app, the user should explicitly use CPU aggregation
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__log$3e$__["log"].warn('Features not supported by GPU aggregation, falling back to CPU')();
            return 'cpu';
        }
        if (// GPU aggregation is requested
        gpuAggregation && // GPU aggregation is supported by the device
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLAggregator"].isSupported(this.context.device)) {
            return 'gpu';
        }
        return 'cpu';
    }
    createAggregator(type) {
        if (type === 'cpu') {
            const { hexagonAggregator, radius } = this.props;
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$cpu$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CPUAggregator"]({
                dimensions: 2,
                getBin: {
                    sources: [
                        'positions'
                    ],
                    getValue: ({ positions }, index, opts)=>{
                        if (hexagonAggregator) {
                            return hexagonAggregator(positions, radius);
                        }
                        const viewport = this.state.aggregatorViewport;
                        // project to common space
                        const p = viewport.projectPosition(positions);
                        const { radiusCommon, hexOriginCommon } = opts;
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexbin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pointToHexbin"])([
                            p[0] - hexOriginCommon[0],
                            p[1] - hexOriginCommon[1]
                        ], radiusCommon);
                    }
                },
                getValue: [
                    {
                        sources: [
                            'colorWeights'
                        ],
                        getValue: ({ colorWeights })=>colorWeights
                    },
                    {
                        sources: [
                            'elevationWeights'
                        ],
                        getValue: ({ elevationWeights })=>elevationWeights
                    }
                ]
            });
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLAggregator"](this.context.device, {
            dimensions: 2,
            channelCount: 2,
            bufferLayout: this.getAttributeManager().getBufferLayouts({
                isInstanced: false
            }),
            ...super.getShaders({
                modules: [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$shaderlib$2f$project32$2f$project32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__project32$3e$__["project32"],
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$bin$2d$options$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["binOptionsUniforms"]
                ],
                vs: /* glsl */ `
  in vec3 positions;
  in vec3 positions64Low;
  in float colorWeights;
  in float elevationWeights;
  
  ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexbin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pointToHexbinGLSL"]}

  void getBin(out ivec2 binId) {
    vec3 positionCommon = project_position(positions, positions64Low);
    binId = pointToHexbin(positionCommon.xy, binOptions.radiusCommon);
  }
  void getValue(out vec2 value) {
    value = vec2(colorWeights, elevationWeights);
  }
  `
            })
        });
    }
    initializeState() {
        super.initializeState();
        const attributeManager = this.getAttributeManager();
        attributeManager.add({
            positions: {
                size: 3,
                accessor: 'getPosition',
                type: 'float64',
                fp64: this.use64bitPositions()
            },
            colorWeights: {
                size: 1,
                accessor: 'getColorWeight'
            },
            elevationWeights: {
                size: 1,
                accessor: 'getElevationWeight'
            }
        });
    }
    updateState(params) {
        const aggregatorChanged = super.updateState(params);
        const { props, oldProps, changeFlags } = params;
        const { aggregator } = this.state;
        if ((changeFlags.dataChanged || !this.state.dataAsArray) && (props.getColorValue || props.getElevationValue)) {
            // Convert data to array
            this.state.dataAsArray = Array.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$iterable$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createIterable"])(props.data).iterable);
        }
        if (aggregatorChanged || changeFlags.dataChanged || props.radius !== oldProps.radius || props.getColorValue !== oldProps.getColorValue || props.getElevationValue !== oldProps.getElevationValue || props.colorAggregation !== oldProps.colorAggregation || props.elevationAggregation !== oldProps.elevationAggregation) {
            this._updateBinOptions();
            const { radiusCommon, hexOriginCommon, binIdRange, dataAsArray } = this.state;
            aggregator.setProps({
                // @ts-expect-error only used by GPUAggregator
                binIdRange,
                pointCount: this.getNumInstances(),
                operations: [
                    props.colorAggregation,
                    props.elevationAggregation
                ],
                binOptions: {
                    radiusCommon,
                    hexOriginCommon
                },
                onUpdate: this._onAggregationUpdate.bind(this)
            });
            if (dataAsArray) {
                const { getColorValue, getElevationValue } = this.props;
                aggregator.setProps({
                    // @ts-expect-error only used by CPUAggregator
                    customOperations: [
                        getColorValue && ((indices)=>getColorValue(indices.map((i)=>dataAsArray[i]), {
                                indices,
                                data: props.data
                            })),
                        getElevationValue && ((indices)=>getElevationValue(indices.map((i)=>dataAsArray[i]), {
                                indices,
                                data: props.data
                            }))
                    ]
                });
            }
        }
        if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {
            aggregator.setNeedsUpdate(0);
        }
        if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {
            aggregator.setNeedsUpdate(1);
        }
        return aggregatorChanged;
    }
    _updateBinOptions() {
        const bounds = this.getBounds();
        let radiusCommon = 1;
        let hexOriginCommon = [
            0,
            0
        ];
        let binIdRange = [
            [
                0,
                1
            ],
            [
                0,
                1
            ]
        ];
        let viewport = this.context.viewport;
        if (bounds && Number.isFinite(bounds[0][0])) {
            let centroid = [
                (bounds[0][0] + bounds[1][0]) / 2,
                (bounds[0][1] + bounds[1][1]) / 2
            ];
            const { radius } = this.props;
            const { unitsPerMeter } = viewport.getDistanceScales(centroid);
            radiusCommon = unitsPerMeter[0] * radius;
            // Use the centroid of the hex at the center of the data
            // This offsets the common space without changing the bins
            const centerHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexbin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pointToHexbin"])(viewport.projectFlat(centroid), radiusCommon);
            centroid = viewport.unprojectFlat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexbin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getHexbinCentroid"])(centerHex, radiusCommon));
            const ViewportType = viewport.constructor;
            // We construct a viewport for the GPU aggregator's project module
            // This viewport is determined by data
            // removes arbitrary precision variance that depends on initial view state
            viewport = viewport.isGeospatial ? new ViewportType({
                longitude: centroid[0],
                latitude: centroid[1],
                zoom: 12
            }) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$viewports$2f$viewport$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Viewport$3e$__["Viewport"]({
                position: [
                    centroid[0],
                    centroid[1],
                    0
                ],
                zoom: 12
            });
            hexOriginCommon = [
                Math.fround(viewport.center[0]),
                Math.fround(viewport.center[1])
            ];
            binIdRange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$bounds$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBinIdRange"])({
                dataBounds: bounds,
                getBinId: (p)=>{
                    const positionCommon = viewport.projectFlat(p);
                    positionCommon[0] -= hexOriginCommon[0];
                    positionCommon[1] -= hexOriginCommon[1];
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexbin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pointToHexbin"])(positionCommon, radiusCommon);
                },
                padding: 1
            });
        }
        this.setState({
            radiusCommon,
            hexOriginCommon,
            binIdRange,
            aggregatorViewport: viewport
        });
    }
    draw(opts) {
        // Replaces render time viewport with our own
        if (opts.shaderModuleProps.project) {
            opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;
        }
        super.draw(opts);
    }
    _onAggregationUpdate({ channel }) {
        const props = this.getCurrentLayer().props;
        const { aggregator } = this.state;
        if (channel === 0) {
            const result = aggregator.getResult(0);
            this.setState({
                colors: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$scale$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AttributeWithScale"](result, aggregator.binCount)
            });
            props.onSetColorDomain(aggregator.getResultDomain(0));
        } else if (channel === 1) {
            const result = aggregator.getResult(1);
            this.setState({
                elevations: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$scale$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AttributeWithScale"](result, aggregator.binCount)
            });
            props.onSetElevationDomain(aggregator.getResultDomain(1));
        }
    }
    onAttributeChange(id) {
        const { aggregator } = this.state;
        switch(id){
            case 'positions':
                aggregator.setNeedsUpdate();
                this._updateBinOptions();
                const { radiusCommon, hexOriginCommon, binIdRange } = this.state;
                aggregator.setProps({
                    // @ts-expect-error only used by GPUAggregator
                    binIdRange,
                    binOptions: {
                        radiusCommon,
                        hexOriginCommon
                    }
                });
                break;
            case 'colorWeights':
                aggregator.setNeedsUpdate(0);
                break;
            case 'elevationWeights':
                aggregator.setNeedsUpdate(1);
                break;
            default:
        }
    }
    renderLayers() {
        const { aggregator, radiusCommon, hexOriginCommon } = this.state;
        const { elevationScale, colorRange, elevationRange, extruded, coverage, material, transitions, colorScaleType, lowerPercentile, upperPercentile, colorDomain, elevationScaleType, elevationLowerPercentile, elevationUpperPercentile, elevationDomain } = this.props;
        const CellLayerClass = this.getSubLayerClass('cells', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexagon$2d$cell$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
        const binAttribute = aggregator.getBins();
        const colors = this.state.colors?.update({
            scaleType: colorScaleType,
            lowerPercentile,
            upperPercentile
        });
        const elevations = this.state.elevations?.update({
            scaleType: elevationScaleType,
            lowerPercentile: elevationLowerPercentile,
            upperPercentile: elevationUpperPercentile
        });
        if (!colors || !elevations) {
            return null;
        }
        return new CellLayerClass(this.getSubLayerProps({
            id: 'cells'
        }), {
            data: {
                length: aggregator.binCount,
                attributes: {
                    getBin: binAttribute,
                    getColorValue: colors.attribute,
                    getElevationValue: elevations.attribute
                }
            },
            // Data has changed shallowly, but we likely don't need to update the attributes
            dataComparator: (data, oldData)=>data.length === oldData.length,
            updateTriggers: {
                getBin: [
                    binAttribute
                ],
                getColorValue: [
                    colors.attribute
                ],
                getElevationValue: [
                    elevations.attribute
                ]
            },
            diskResolution: 6,
            vertices: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexbin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HexbinVertices"],
            radius: radiusCommon,
            hexOriginCommon,
            elevationScale,
            colorRange,
            colorScaleType,
            elevationRange,
            extruded,
            coverage,
            material,
            colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),
            elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),
            colorCutoff: colors.cutoff,
            elevationCutoff: elevations.cutoff,
            transitions: transitions && {
                getFillColor: transitions.getColorValue || transitions.getColorWeight,
                getElevation: transitions.getElevationValue || transitions.getElevationWeight
            },
            // Extensions are already handled by the GPUAggregator, do not pass it down
            extensions: []
        });
    }
    getPickingInfo(params) {
        const info = params.info;
        const { index } = info;
        if (index >= 0) {
            const bin = this.state.aggregator.getBin(index);
            let object;
            if (bin) {
                const centroidCommon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexbin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getHexbinCentroid"])(bin.id, this.state.radiusCommon);
                const centroid = this.context.viewport.unprojectFlat(centroidCommon);
                object = {
                    col: bin.id[0],
                    row: bin.id[1],
                    position: centroid,
                    colorValue: bin.value[0],
                    elevationValue: bin.value[1],
                    count: bin.count
                };
                if (bin.pointIndices) {
                    object.pointIndices = bin.pointIndices;
                    object.points = Array.isArray(this.props.data) ? bin.pointIndices.map((i)=>this.props.data[i]) : [];
                }
            }
            info.object = object;
        }
        return info;
    }
}
HexagonLayer.layerName = 'HexagonLayer';
HexagonLayer.defaultProps = defaultProps;
const __TURBOPACK__default__export__ = HexagonLayer;
 //# sourceMappingURL=hexagon-layer.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/screen-grid-layer/bin-options-uniforms.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "binOptionsUniforms": (()=>binOptionsUniforms)
});
const uniformBlock = /* glsl */ `\
uniform binOptionsUniforms {
  float cellSizePixels;
} binOptions;
`;
const binOptionsUniforms = {
    name: 'binOptions',
    vs: uniformBlock,
    uniformTypes: {
        cellSizePixels: 'f32'
    }
}; //# sourceMappingURL=bin-options-uniforms.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/screen-grid-layer/screen-grid-layer-vertex.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = /* glsl */ `\
#version 300 es
#define SHADER_NAME screen-grid-layer-vertex-shader
#define RANGE_COUNT 6
in vec2 positions;
in vec2 instancePositions;
in float instanceWeights;
in vec3 instancePickingColors;
uniform sampler2D colorRange;
out vec4 vColor;
vec4 interp(float value, vec2 domain, sampler2D range) {
float r = (value - domain.x) / (domain.y - domain.x);
return texture(range, vec2(r, 0.5));
}
void main(void) {
if (isnan(instanceWeights)) {
gl_Position = vec4(0.);
return;
}
vec2 pos = instancePositions * screenGrid.gridSizeClipspace + positions * screenGrid.cellSizeClipspace;
pos.x = pos.x - 1.0;
pos.y = 1.0 - pos.y;
gl_Position = vec4(pos, 0., 1.);
vColor = interp(instanceWeights, screenGrid.colorDomain, colorRange);
vColor.a *= layer.opacity;
picking_setPickingColor(instancePickingColors);
}
`;
 //# sourceMappingURL=screen-grid-layer-vertex.glsl.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/screen-grid-layer/screen-grid-layer-fragment.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* fragment shader for the grid-layer */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = /* glsl */ `\
#version 300 es
#define SHADER_NAME screen-grid-layer-fragment-shader
precision highp float;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
 //# sourceMappingURL=screen-grid-layer-fragment.glsl.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/screen-grid-layer/screen-grid-layer-uniforms.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "screenGridUniforms": (()=>screenGridUniforms)
});
const uniformBlock = /* glsl */ `\
uniform screenGridUniforms {
  vec2 cellSizeClipspace;
  vec2 gridSizeClipspace;
  vec2 colorDomain;
} screenGrid;
`;
const screenGridUniforms = {
    name: 'screenGrid',
    vs: uniformBlock,
    uniformTypes: {
        cellSizeClipspace: 'vec2<f32>',
        gridSizeClipspace: 'vec2<f32>',
        colorDomain: 'vec2<f32>'
    }
}; //# sourceMappingURL=screen-grid-layer-uniforms.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/screen-grid-layer/screen-grid-cell-layer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$screen$2d$grid$2d$layer$2f$screen$2d$grid$2d$layer$2d$vertex$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/screen-grid-layer/screen-grid-layer-vertex.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$screen$2d$grid$2d$layer$2f$screen$2d$grid$2d$layer$2d$fragment$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/screen-grid-layer/screen-grid-layer-fragment.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$shaderlib$2f$picking$2f$picking$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__picking$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/shaderlib/picking/picking.js [app-client] (ecmascript) <export default as picking>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$screen$2d$grid$2d$layer$2f$screen$2d$grid$2d$layer$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/screen-grid-layer/screen-grid-layer-uniforms.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/utils/color-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/model/model.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$geometry$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/geometry/geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Layer$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/lib/layer.js [app-client] (ecmascript) <export default as Layer>");
;
;
;
;
;
;
class ScreenGridCellLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Layer$3e$__["Layer"] {
    getShaders() {
        return super.getShaders({
            vs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$screen$2d$grid$2d$layer$2f$screen$2d$grid$2d$layer$2d$vertex$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
            fs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$screen$2d$grid$2d$layer$2f$screen$2d$grid$2d$layer$2d$fragment$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
            modules: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$shaderlib$2f$picking$2f$picking$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__picking$3e$__["picking"],
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$screen$2d$grid$2d$layer$2f$screen$2d$grid$2d$layer$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["screenGridUniforms"]
            ]
        });
    }
    initializeState() {
        this.getAttributeManager().addInstanced({
            instancePositions: {
                size: 2,
                type: 'float32',
                accessor: 'getBin'
            },
            instanceWeights: {
                size: 1,
                type: 'float32',
                accessor: 'getWeight'
            }
        });
        this.state.model = this._getModel();
    }
    updateState(params) {
        super.updateState(params);
        const { props, oldProps, changeFlags } = params;
        const model = this.state.model;
        if (oldProps.colorRange !== props.colorRange) {
            this.state.colorTexture?.destroy();
            this.state.colorTexture = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createColorRangeTexture"])(this.context.device, props.colorRange, props.colorScaleType);
            const screenGridProps = {
                colorRange: this.state.colorTexture
            };
            model.shaderInputs.setProps({
                screenGrid: screenGridProps
            });
        } else if (oldProps.colorScaleType !== props.colorScaleType) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["updateColorRangeTexture"])(this.state.colorTexture, props.colorScaleType);
        }
        if (oldProps.cellMarginPixels !== props.cellMarginPixels || oldProps.cellSizePixels !== props.cellSizePixels || changeFlags.viewportChanged) {
            const { width, height } = this.context.viewport;
            const { cellSizePixels: gridSize, cellMarginPixels } = this.props;
            const cellSize = Math.max(gridSize - cellMarginPixels, 0);
            const screenGridProps = {
                gridSizeClipspace: [
                    gridSize / width * 2,
                    gridSize / height * 2
                ],
                cellSizeClipspace: [
                    cellSize / width * 2,
                    cellSize / height * 2
                ]
            };
            model.shaderInputs.setProps({
                screenGrid: screenGridProps
            });
        }
    }
    finalizeState(context) {
        super.finalizeState(context);
        this.state.colorTexture?.destroy();
    }
    draw({ uniforms }) {
        const colorDomain = this.props.colorDomain();
        const model = this.state.model;
        const screenGridProps = {
            colorDomain
        };
        model.shaderInputs.setProps({
            screenGrid: screenGridProps
        });
        model.draw(this.context.renderPass);
    }
    // Private Methods
    _getModel() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Model"](this.context.device, {
            ...this.getShaders(),
            id: this.props.id,
            bufferLayout: this.getAttributeManager().getBufferLayouts(),
            geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$geometry$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Geometry"]({
                topology: 'triangle-strip',
                attributes: {
                    positions: {
                        value: new Float32Array([
                            0,
                            0,
                            1,
                            0,
                            0,
                            1,
                            1,
                            1
                        ]),
                        size: 2
                    }
                }
            }),
            isInstanced: true
        });
    }
}
ScreenGridCellLayer.layerName = 'ScreenGridCellLayer';
const __TURBOPACK__default__export__ = ScreenGridCellLayer;
 //# sourceMappingURL=screen-grid-cell-layer.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/screen-grid-layer/screen-grid-layer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/utils/color-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/webgl-aggregator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$shaderlib$2f$project32$2f$project32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__project32$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js [app-client] (ecmascript) <export default as project32>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$screen$2d$grid$2d$layer$2f$bin$2d$options$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/screen-grid-layer/bin-options-uniforms.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$cpu$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/cpu-aggregator/cpu-aggregator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$screen$2d$grid$2d$layer$2f$screen$2d$grid$2d$cell$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/screen-grid-layer/screen-grid-cell-layer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregation$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregation-layer.js [app-client] (ecmascript)");
;
;
;
;
;
;
const defaultProps = {
    cellSizePixels: {
        type: 'number',
        value: 100,
        min: 1
    },
    cellMarginPixels: {
        type: 'number',
        value: 2,
        min: 0
    },
    colorRange: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$utils$2f$color$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultColorRange"],
    colorScaleType: 'linear',
    getPosition: {
        type: 'accessor',
        value: (d)=>d.position
    },
    getWeight: {
        type: 'accessor',
        value: 1
    },
    gpuAggregation: true,
    aggregation: 'SUM'
};
/** Aggregates data into histogram bins and renders them as a grid. */ class ScreenGridLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregation$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    getAggregatorType() {
        return this.props.gpuAggregation && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLAggregator"].isSupported(this.context.device) ? 'gpu' : 'cpu';
    }
    createAggregator(type) {
        if (type === 'cpu' || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLAggregator"].isSupported(this.context.device)) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$cpu$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CPUAggregator"]({
                dimensions: 2,
                getBin: {
                    sources: [
                        'positions'
                    ],
                    getValue: ({ positions }, index, opts)=>{
                        const viewport = this.context.viewport;
                        const p = viewport.project(positions);
                        const cellSizePixels = opts.cellSizePixels;
                        if (p[0] < 0 || p[0] >= viewport.width || p[1] < 0 || p[1] >= viewport.height) {
                            // Not on screen
                            return null;
                        }
                        return [
                            Math.floor(p[0] / cellSizePixels),
                            Math.floor(p[1] / cellSizePixels)
                        ];
                    }
                },
                getValue: [
                    {
                        sources: [
                            'counts'
                        ],
                        getValue: ({ counts })=>counts
                    }
                ]
            });
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLAggregator"](this.context.device, {
            dimensions: 2,
            channelCount: 1,
            bufferLayout: this.getAttributeManager().getBufferLayouts({
                isInstanced: false
            }),
            ...super.getShaders({
                modules: [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$shaderlib$2f$project32$2f$project32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__project32$3e$__["project32"],
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$screen$2d$grid$2d$layer$2f$bin$2d$options$2d$uniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["binOptionsUniforms"]
                ],
                vs: `
  in vec3 positions;
  in vec3 positions64Low;
  in float counts;
  
  void getBin(out ivec2 binId) {
    vec4 pos = project_position_to_clipspace(positions, positions64Low, vec3(0.0));
    vec2 screenCoords = vec2(pos.x / pos.w + 1.0, 1.0 - pos.y / pos.w) / 2.0 * project.viewportSize / project.devicePixelRatio;
    vec2 gridCoords = floor(screenCoords / binOptions.cellSizePixels);
    binId = ivec2(gridCoords);
  }
  void getValue(out float weight) {
    weight = counts;
  }
  `
            })
        });
    }
    initializeState() {
        super.initializeState();
        const attributeManager = this.getAttributeManager();
        attributeManager.add({
            positions: {
                size: 3,
                accessor: 'getPosition',
                type: 'float64',
                fp64: this.use64bitPositions()
            },
            // this attribute is used in gpu aggregation path only
            counts: {
                size: 1,
                accessor: 'getWeight'
            }
        });
    }
    shouldUpdateState({ changeFlags }) {
        return changeFlags.somethingChanged;
    }
    updateState(params) {
        const aggregatorChanged = super.updateState(params);
        const { props, oldProps, changeFlags } = params;
        const { cellSizePixels, aggregation } = props;
        if (aggregatorChanged || changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.viewportChanged || aggregation !== oldProps.aggregation || cellSizePixels !== oldProps.cellSizePixels) {
            const { width, height } = this.context.viewport;
            const { aggregator } = this.state;
            if (aggregator instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLAggregator"]) {
                aggregator.setProps({
                    binIdRange: [
                        [
                            0,
                            Math.ceil(width / cellSizePixels)
                        ],
                        [
                            0,
                            Math.ceil(height / cellSizePixels)
                        ]
                    ]
                });
            }
            aggregator.setProps({
                pointCount: this.getNumInstances(),
                operations: [
                    aggregation
                ],
                binOptions: {
                    cellSizePixels
                }
            });
        }
        if (changeFlags.viewportChanged) {
            // Rerun aggregation on viewport change
            this.state.aggregator.setNeedsUpdate();
        }
        return aggregatorChanged;
    }
    onAttributeChange(id) {
        const { aggregator } = this.state;
        switch(id){
            case 'positions':
                aggregator.setNeedsUpdate();
                break;
            case 'counts':
                aggregator.setNeedsUpdate(0);
                break;
            default:
        }
    }
    renderLayers() {
        const { aggregator } = this.state;
        const CellLayerClass = this.getSubLayerClass('cells', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$screen$2d$grid$2d$layer$2f$screen$2d$grid$2d$cell$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
        const binAttribute = aggregator.getBins();
        const weightAttribute = aggregator.getResult(0);
        return new CellLayerClass(this.props, this.getSubLayerProps({
            id: 'cell-layer'
        }), {
            data: {
                length: aggregator.binCount,
                attributes: {
                    getBin: binAttribute,
                    getWeight: weightAttribute
                }
            },
            // Data has changed shallowly, but we likely don't need to update the attributes
            dataComparator: (data, oldData)=>data.length === oldData.length,
            updateTriggers: {
                getBin: [
                    binAttribute
                ],
                getWeight: [
                    weightAttribute
                ]
            },
            parameters: {
                depthWriteEnabled: false,
                ...this.props.parameters
            },
            // Evaluate domain at draw() time
            colorDomain: ()=>this.props.colorDomain || aggregator.getResultDomain(0),
            // Extensions are already handled by the GPUAggregator, do not pass it down
            extensions: []
        });
    }
    getPickingInfo(params) {
        const info = params.info;
        const { index } = info;
        if (index >= 0) {
            const bin = this.state.aggregator.getBin(index);
            let object;
            if (bin) {
                object = {
                    col: bin.id[0],
                    row: bin.id[1],
                    value: bin.value[0],
                    count: bin.count
                };
                if (bin.pointIndices) {
                    object.pointIndices = bin.pointIndices;
                    object.points = Array.isArray(this.props.data) ? bin.pointIndices.map((i)=>this.props.data[i]) : [];
                }
            }
            info.object = object;
        }
        return info;
    }
}
ScreenGridLayer.layerName = 'ScreenGridLayer';
ScreenGridLayer.defaultProps = defaultProps;
const __TURBOPACK__default__export__ = ScreenGridLayer;
 //# sourceMappingURL=screen-grid-layer.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({});
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@deck.gl/aggregation-layers/dist/index.js [app-client] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CPUAggregator": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$cpu$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CPUAggregator"]),
    "ContourLayer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$contour$2d$layer$2f$contour$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]),
    "GridLayer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$grid$2d$layer$2f$grid$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]),
    "HeatmapLayer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$heatmap$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]),
    "HexagonLayer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexagon$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]),
    "ScreenGridLayer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$screen$2d$grid$2d$layer$2f$screen$2d$grid$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]),
    "WebGLAggregator": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLAggregator"]),
    "_AggregationLayer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregation$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$cpu$2d$aggregator$2f$cpu$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/cpu-aggregator/cpu-aggregator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$contour$2d$layer$2f$contour$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/contour-layer/contour-layer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$grid$2d$layer$2f$grid$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/grid-layer/grid-layer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$heatmap$2d$layer$2f$heatmap$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/heatmap-layer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$hexagon$2d$layer$2f$hexagon$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/hexagon-layer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$screen$2d$grid$2d$layer$2f$screen$2d$grid$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/screen-grid-layer/screen-grid-layer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregator$2f$gpu$2d$aggregator$2f$webgl$2d$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/webgl-aggregator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$common$2f$aggregation$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/common/aggregation-layer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$aggregation$2d$layers$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@deck.gl/aggregation-layers/dist/index.js [app-client] (ecmascript) <locals>");
}}),
}]);

//# sourceMappingURL=node_modules_%40deck_gl_aggregation-layers_dist_fa53df._.js.map