(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@luma_gl_13c49e._.js", {

"[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "uid": (()=>uid)
});
const uidCounters = {};
function uid(id = 'id') {
    uidCounters[id] = uidCounters[id] || 1;
    const count = uidCounters[id]++;
    return `${id}-${count}`;
} //# sourceMappingURL=uid.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/model/split-uniforms-and-bindings.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "isUniformValue": (()=>isUniformValue),
    "splitUniformsAndBindings": (()=>splitUniformsAndBindings)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$types$2f$dist$2f$is$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@math.gl/types/dist/is-array.js [app-client] (ecmascript)");
;
function isUniformValue(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$types$2f$dist$2f$is$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumericArray"])(value) || typeof value === 'number' || typeof value === 'boolean';
}
function splitUniformsAndBindings(uniforms) {
    const result = {
        bindings: {},
        uniforms: {}
    };
    Object.keys(uniforms).forEach((name)=>{
        const uniform = uniforms[name];
        if (isUniformValue(uniform)) {
            result.uniforms[name] = uniform;
        } else {
            result.bindings[name] = uniform;
        }
    });
    return result;
} //# sourceMappingURL=split-uniforms-and-bindings.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/shader-inputs.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "ShaderInputs": (()=>ShaderInputs)
});
// import type {ShaderUniformType, UniformValue, UniformFormat, UniformInfoDevice, Texture, Sampler} from '@luma.gl/core';
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2d$dependencies$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module-dependencies.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$split$2d$uniforms$2d$and$2d$bindings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/model/split-uniforms-and-bindings.js [app-client] (ecmascript)");
;
;
;
class ShaderInputs {
    options = {
        disableWarnings: false
    };
    /**
     * The map of modules
     * @todo should should this include the resolved dependencies?
     */ // @ts-ignore Fix typings
    modules;
    /** Stores the uniform values for each module */ moduleUniforms;
    /** Stores the uniform bindings for each module  */ moduleBindings;
    /** Tracks if uniforms have changed */ // moduleUniformsChanged: Record<keyof ShaderPropsT, false | string>;
    /**
     * Create a new UniformStore instance
     * @param modules
     */ constructor(// @ts-ignore Fix typings
    modules, options){
        Object.assign(this.options, options);
        // Extract modules with dependencies
        const resolvedModules = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2d$dependencies$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getShaderModuleDependencies"])(Object.values(modules).filter((module)=>module.dependencies));
        for (const resolvedModule of resolvedModules){
            // @ts-ignore
            modules[resolvedModule.name] = resolvedModule;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].log(1, 'Creating ShaderInputs with modules', Object.keys(modules))();
        // Store the module definitions and create storage for uniform values and binding values, per module
        // @ts-ignore Fix typings
        this.modules = modules;
        this.moduleUniforms = {};
        this.moduleBindings = {};
        // Initialize the modules
        for (const [name, module] of Object.entries(modules)){
            this._addModule(module);
            if (module.name && name !== module.name && !this.options.disableWarnings) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`Module name: ${name} vs ${module.name}`)();
            }
        }
    }
    /** Destroy */ destroy() {}
    /**
     * Set module props
     */ setProps(props) {
        for (const name of Object.keys(props)){
            const moduleName = name;
            const moduleProps = props[moduleName] || {};
            const module = this.modules[moduleName];
            if (!module) {
                // Ignore props for unregistered modules
                if (!this.options.disableWarnings) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`Module ${name} not found`)();
                }
                continue; // eslint-disable-line no-continue
            }
            const oldUniforms = this.moduleUniforms[moduleName];
            const oldBindings = this.moduleBindings[moduleName];
            const uniformsAndBindings = module.getUniforms?.(moduleProps, oldUniforms) || moduleProps;
            const { uniforms, bindings } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$split$2d$uniforms$2d$and$2d$bindings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["splitUniformsAndBindings"])(uniformsAndBindings);
            this.moduleUniforms[moduleName] = {
                ...oldUniforms,
                ...uniforms
            };
            this.moduleBindings[moduleName] = {
                ...oldBindings,
                ...bindings
            };
        // this.moduleUniformsChanged ||= moduleName;
        // console.log(`setProps(${String(moduleName)}`, moduleName, this.moduleUniforms[moduleName])
        }
    }
    /**
     * Return the map of modules
     * @todo should should this include the resolved dependencies?
     */ getModules() {
        return Object.values(this.modules);
    }
    /** Get all uniform values for all modules */ getUniformValues() {
        return this.moduleUniforms;
    }
    /** Merges all bindings for the shader (from the various modules) */ getBindingValues() {
        const bindings = {};
        for (const moduleBindings of Object.values(this.moduleBindings)){
            Object.assign(bindings, moduleBindings);
        }
        return bindings;
    }
    // INTERNAL
    /** Return a debug table that can be used for console.table() or log.table() */ getDebugTable() {
        const table = {};
        for (const [moduleName, module] of Object.entries(this.moduleUniforms)){
            for (const [key, value] of Object.entries(module)){
                table[`${moduleName}.${key}`] = {
                    type: this.modules[moduleName].uniformTypes?.[key],
                    value: String(value)
                };
            }
        }
        return table;
    }
    _addModule(module) {
        const moduleName = module.name;
        // Get default uniforms from module
        this.moduleUniforms[moduleName] = module.defaultUniforms || {};
        this.moduleBindings[moduleName] = {};
    }
} //# sourceMappingURL=shader-inputs.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/factories/pipeline-factory.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "PipelineFactory": (()=>PipelineFactory)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/render-pipeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$compute$2d$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/compute-pipeline.js [app-client] (ecmascript)");
;
class PipelineFactory {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RenderPipeline"].defaultProps
    };
    /** Get the singleton default pipeline factory for the specified device */ static getDefaultPipelineFactory(device) {
        device._lumaData.defaultPipelineFactory = device._lumaData.defaultPipelineFactory || new PipelineFactory(device);
        return device._lumaData.defaultPipelineFactory;
    }
    device;
    destroyPolicy;
    _hashCounter = 0;
    _hashes = {};
    _renderPipelineCache = {};
    _computePipelineCache = {};
    constructor(device){
        this.device = device;
        this.destroyPolicy = device.props._factoryDestroyPolicy;
    }
    /** Return a RenderPipeline matching props. Reuses a similar pipeline if already created. */ createRenderPipeline(props) {
        const allProps = {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RenderPipeline"].defaultProps,
            ...props
        };
        const hash = this._hashRenderPipeline(allProps);
        if (!this._renderPipelineCache[hash]) {
            const pipeline = this.device.createRenderPipeline({
                ...allProps,
                id: allProps.id ? `${allProps.id}-cached` : undefined
            });
            pipeline.hash = hash;
            this._renderPipelineCache[hash] = {
                pipeline,
                useCount: 0
            };
        }
        this._renderPipelineCache[hash].useCount++;
        return this._renderPipelineCache[hash].pipeline;
    }
    createComputePipeline(props) {
        const allProps = {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$compute$2d$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ComputePipeline"].defaultProps,
            ...props
        };
        const hash = this._hashComputePipeline(allProps);
        if (!this._computePipelineCache[hash]) {
            const pipeline = this.device.createComputePipeline({
                ...allProps,
                id: allProps.id ? `${allProps.id}-cached` : undefined
            });
            pipeline.hash = hash;
            this._computePipelineCache[hash] = {
                pipeline,
                useCount: 0
            };
        }
        this._computePipelineCache[hash].useCount++;
        return this._computePipelineCache[hash].pipeline;
    }
    release(pipeline) {
        const hash = pipeline.hash;
        const cache = pipeline instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$compute$2d$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ComputePipeline"] ? this._computePipelineCache : this._renderPipelineCache;
        cache[hash].useCount--;
        if (cache[hash].useCount === 0) {
            if (this.destroyPolicy === 'unused') {
                cache[hash].pipeline.destroy();
                delete cache[hash];
            }
        }
    }
    // PRIVATE
    _hashComputePipeline(props) {
        const shaderHash = this._getHash(props.shader.source);
        return `${shaderHash}`;
    }
    /** Calculate a hash based on all the inputs for a render pipeline */ _hashRenderPipeline(props) {
        const vsHash = props.vs ? this._getHash(props.vs.source) : 0;
        const fsHash = props.fs ? this._getHash(props.fs.source) : 0;
        // WebGL specific
        // const {varyings = [], bufferMode = {}} = props;
        // const varyingHashes = varyings.map((v) => this._getHash(v));
        const varyingHash = '-'; // `${varyingHashes.join('/')}B${bufferMode}`
        const bufferLayoutHash = this._getHash(JSON.stringify(props.bufferLayout));
        switch(this.device.type){
            case 'webgl':
                // WebGL is more dynamic
                return `${vsHash}/${fsHash}V${varyingHash}BL${bufferLayoutHash}`;
            default:
                // On WebGPU we need to rebuild the pipeline if topology, parameters or bufferLayout change
                const parameterHash = this._getHash(JSON.stringify(props.parameters));
                // TODO - Can json.stringify() generate different strings for equivalent objects if order of params is different?
                // create a deepHash() to deduplicate?
                return `${vsHash}/${fsHash}V${varyingHash}T${props.topology}P${parameterHash}BL${bufferLayoutHash}`;
        }
    }
    _getHash(key) {
        if (this._hashes[key] === undefined) {
            this._hashes[key] = this._hashCounter++;
        }
        return this._hashes[key];
    }
} //# sourceMappingURL=pipeline-factory.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/factories/shader-factory.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "ShaderFactory": (()=>ShaderFactory)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/shader.js [app-client] (ecmascript)");
;
class ShaderFactory {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Shader"].defaultProps
    };
    /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */ static getDefaultShaderFactory(device) {
        device._lumaData.defaultShaderFactory ||= new ShaderFactory(device);
        return device._lumaData.defaultShaderFactory;
    }
    device;
    destroyPolicy;
    _cache = {};
    /** @internal */ constructor(device){
        this.device = device;
        this.destroyPolicy = device.props._factoryDestroyPolicy;
    }
    /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */ createShader(props) {
        const key = this._hashShader(props);
        let cacheEntry = this._cache[key];
        if (!cacheEntry) {
            const shader = this.device.createShader({
                ...props,
                id: props.id ? `${props.id}-cached` : undefined
            });
            this._cache[key] = cacheEntry = {
                shader,
                useCount: 0
            };
        }
        cacheEntry.useCount++;
        return cacheEntry.shader;
    }
    /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */ release(shader) {
        const key = this._hashShader(shader);
        const cacheEntry = this._cache[key];
        if (cacheEntry) {
            cacheEntry.useCount--;
            if (cacheEntry.useCount === 0) {
                if (this.destroyPolicy === 'unused') {
                    delete this._cache[key];
                    cacheEntry.shader.destroy();
                }
            }
        }
    }
    // PRIVATE
    _hashShader(value) {
        return `${value.stage}:${value.source}`;
    }
} //# sourceMappingURL=shader-factory.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/geometry/gpu-geometry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "GPUGeometry": (()=>GPUGeometry),
    "getAttributeBuffersFromGeometry": (()=>getAttributeBuffersFromGeometry),
    "getIndexBufferFromGeometry": (()=>getIndexBufferFromGeometry),
    "makeGPUGeometry": (()=>makeGPUGeometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$vertex$2d$format$2d$from$2d$attribute$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/vertex-format-from-attribute.js [app-client] (ecmascript)");
;
;
class GPUGeometry {
    id;
    userData = {};
    /** Determines how vertices are read from the 'vertex' attributes */ topology;
    bufferLayout = [];
    vertexCount;
    indices;
    attributes;
    constructor(props){
        this.id = props.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])('geometry');
        this.topology = props.topology;
        this.indices = props.indices || null;
        this.attributes = props.attributes;
        this.vertexCount = props.vertexCount;
        this.bufferLayout = props.bufferLayout || [];
        if (this.indices) {
            if (!(this.indices.usage & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].INDEX)) {
                throw new Error('Index buffer must have INDEX usage');
            }
        }
    }
    destroy() {
        this.indices?.destroy();
        for (const attribute of Object.values(this.attributes)){
            attribute.destroy();
        }
    }
    getVertexCount() {
        return this.vertexCount;
    }
    getAttributes() {
        return this.attributes;
    }
    getIndexes() {
        return this.indices || null;
    }
    _calculateVertexCount(positions) {
        // Assume that positions is a fully packed float32x3 buffer
        const vertexCount = positions.byteLength / 12;
        return vertexCount;
    }
}
function makeGPUGeometry(device, geometry) {
    if (geometry instanceof GPUGeometry) {
        return geometry;
    }
    const indices = getIndexBufferFromGeometry(device, geometry);
    const { attributes, bufferLayout } = getAttributeBuffersFromGeometry(device, geometry);
    return new GPUGeometry({
        topology: geometry.topology || 'triangle-list',
        bufferLayout,
        vertexCount: geometry.vertexCount,
        indices,
        attributes
    });
}
function getIndexBufferFromGeometry(device, geometry) {
    if (!geometry.indices) {
        return undefined;
    }
    const data = geometry.indices.value;
    return device.createBuffer({
        usage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].INDEX,
        data
    });
}
function getAttributeBuffersFromGeometry(device, geometry) {
    const bufferLayout = [];
    const attributes = {};
    for (const [attributeName, attribute] of Object.entries(geometry.attributes)){
        let name = attributeName;
        // TODO Map some GLTF attribute names (is this still needed?)
        switch(attributeName){
            case 'POSITION':
                name = 'positions';
                break;
            case 'NORMAL':
                name = 'normals';
                break;
            case 'TEXCOORD_0':
                name = 'texCoords';
                break;
            case 'COLOR_0':
                name = 'colors';
                break;
        }
        if (attribute) {
            attributes[name] = device.createBuffer({
                data: attribute.value,
                id: `${attributeName}-buffer`
            });
            const { value, size, normalized } = attribute;
            // @ts-expect-error
            bufferLayout.push({
                name,
                format: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$vertex$2d$format$2d$from$2d$attribute$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getVertexFormatFromAttribute"])(value, size, normalized)
            });
        }
    }
    const vertexCount = geometry._calculateVertexCount(geometry.attributes, geometry.indices);
    return {
        attributes,
        bufferLayout,
        vertexCount
    };
} //# sourceMappingURL=gpu-geometry.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/utils/deep-equal.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 * Fast partial deep equal for prop.
 *
 * @param a Prop
 * @param b Prop to compare against `a`
 * @param depth Depth to which to recurse in nested Objects/Arrays. Use 0 (default) for shallow comparison, -1 for infinite depth
 */ /* eslint-disable complexity */ __turbopack_esm__({
    "deepEqual": (()=>deepEqual)
});
function deepEqual(a, b, depth) {
    if (a === b) {
        return true;
    }
    if (!depth || !a || !b) {
        return false;
    }
    if (Array.isArray(a)) {
        if (!Array.isArray(b) || a.length !== b.length) {
            return false;
        }
        for(let i = 0; i < a.length; i++){
            if (!deepEqual(a[i], b[i], depth - 1)) {
                return false;
            }
        }
        return true;
    }
    if (Array.isArray(b)) {
        return false;
    }
    if (typeof a === 'object' && typeof b === 'object') {
        const aKeys = Object.keys(a);
        const bKeys = Object.keys(b);
        if (aKeys.length !== bKeys.length) {
            return false;
        }
        for (const key of aKeys){
            if (!b.hasOwnProperty(key)) {
                return false;
            }
            if (!deepEqual(a[key], b[key], depth - 1)) {
                return false;
            }
        }
        return true;
    }
    return false;
} //# sourceMappingURL=deep-equal.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/application-utils/load-file.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "loadImage": (()=>loadImage),
    "loadImageBitmap": (()=>loadImageBitmap),
    "setPathPrefix": (()=>setPathPrefix)
});
let pathPrefix = '';
function setPathPrefix(prefix) {
    pathPrefix = prefix;
}
async function loadImageBitmap(url, opts) {
    const image = new Image();
    image.crossOrigin = opts?.crossOrigin || 'anonymous';
    image.src = url.startsWith('http') ? url : pathPrefix + url;
    await image.decode();
    return opts ? await createImageBitmap(image, opts) : await createImageBitmap(image);
}
async function loadImage(url, opts) {
    return await new Promise((resolve, reject)=>{
        try {
            const image = new Image();
            image.onload = ()=>resolve(image);
            image.onerror = ()=>reject(new Error(`Could not load image ${url}.`));
            image.crossOrigin = opts?.crossOrigin || 'anonymous';
            image.src = url.startsWith('http') ? url : pathPrefix + url;
        } catch (error) {
            reject(error);
        }
    });
} //# sourceMappingURL=load-file.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/async-texture/async-texture.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl, MIT license
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "AsyncTexture": (()=>AsyncTexture)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$application$2d$utils$2f$load$2d$file$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/application-utils/load-file.js [app-client] (ecmascript)");
;
;
class AsyncTexture {
    device;
    id;
    // TODO - should we type these as possibly `null`? It will make usage harder?
    // @ts-expect-error
    texture;
    // @ts-expect-error
    sampler;
    // @ts-expect-error
    view;
    ready;
    isReady = false;
    destroyed = false;
    resolveReady = ()=>{};
    rejectReady = ()=>{};
    get [Symbol.toStringTag]() {
        return 'AsyncTexture';
    }
    toString() {
        return `AsyncTexture:"${this.id}"(${this.isReady ? 'ready' : 'loading'})`;
    }
    constructor(device, props){
        this.device = device;
        this.id = props.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])('async-texture');
        // this.id = typeof props?.data === 'string' ? props.data.slice(-20) : uid('async-texture');
        // Signature: new AsyncTexture(device, {data: url})
        if (typeof props?.data === 'string' && props.dimension === '2d') {
            props = {
                ...props,
                data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$application$2d$utils$2f$load$2d$file$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["loadImageBitmap"])(props.data)
            };
        }
        this.ready = new Promise((resolve, reject)=>{
            this.resolveReady = ()=>{
                this.isReady = true;
                resolve();
            };
            this.rejectReady = reject;
        });
        this.initAsync(props);
    }
    async initAsync(props) {
        let resolveReady;
        let rejectReady;
        const asyncData = props.data;
        const data = await awaitAllPromises(asyncData).then(resolveReady, rejectReady);
        // Check that we haven't been destroyed while waiting for texture data to load
        if (this.destroyed) {
            return;
        }
        // Now we can actually create the texture
        // @ts-expect-error Discriminated union
        const syncProps = {
            ...props,
            data
        };
        this.texture = this.device.createTexture(syncProps);
        this.sampler = this.texture.sampler;
        this.view = this.texture.view;
        this.isReady = true;
    }
    destroy() {
        if (this.texture) {
            this.texture.destroy();
            // @ts-expect-error
            this.texture = null;
        }
        this.destroyed = true;
    }
    /**
     * Textures are immutable and cannot be resized after creation,
     * but we can create a similar texture with the same parameters but a new size.
     * @note Does not copy contents of the texture
     * @todo Abort pending promise and create a texture with the new size?
     */ resize(size) {
        if (!this.isReady) {
            throw new Error('Cannot resize texture before it is ready');
        }
        if (size.width === this.texture.width && size.height === this.texture.height) {
            return false;
        }
        if (this.texture) {
            const texture = this.texture;
            this.texture = texture.clone(size);
            texture.destroy();
        }
        return true;
    }
}
// HELPERS
/** Resolve all promises in a nested data structure */ async function awaitAllPromises(x) {
    x = await x;
    if (Array.isArray(x)) {
        return await Promise.all(x.map(awaitAllPromises));
    }
    if (x && typeof x === 'object' && x.constructor === Object) {
        const object = x;
        const values = await Promise.all(Object.values(object));
        const keys = Object.keys(object);
        const resolvedObject = {};
        for(let i = 0; i < keys.length; i++){
            resolvedObject[keys[i]] = values[i];
        }
        return resolvedObject;
    }
    return x;
} //# sourceMappingURL=async-texture.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/debug/debug-shader-layout.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 * Extracts a table suitable for `console.table()` from a shader layout to assist in debugging.
 * @param layout shader layout
 * @param name app should provide the most meaningful name, usually the model or pipeline name / id.
 * @returns
 */ __turbopack_esm__({
    "getDebugTableForShaderLayout": (()=>getDebugTableForShaderLayout)
});
function getDebugTableForShaderLayout(layout, name) {
    const table = {};
    const header = 'Values'; // '`Shader Layout for ${name}`;
    if (layout.attributes.length === 0 && !layout.varyings?.length) {
        return {
            'No attributes or varyings': {
                [header]: 'N/A'
            }
        };
    }
    for (const attributeDeclaration of layout.attributes){
        if (attributeDeclaration) {
            const glslDeclaration = `${attributeDeclaration.location} ${attributeDeclaration.name}: ${attributeDeclaration.type}`;
            table[`in ${glslDeclaration}`] = {
                [header]: attributeDeclaration.stepMode || 'vertex'
            };
        }
    }
    for (const varyingDeclaration of layout.varyings || []){
        const glslDeclaration = `${varyingDeclaration.location} ${varyingDeclaration.name}`;
        table[`out ${glslDeclaration}`] = {
            [header]: JSON.stringify(varyingDeclaration)
        };
    }
    return table;
} //# sourceMappingURL=debug-shader-layout.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/debug/debug-framebuffer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// import {copyTextureToImage} from '../debug/copy-texture-to-image';
/** Only works with 1st device? */ __turbopack_esm__({
    "debugFramebuffer": (()=>debugFramebuffer)
});
let canvas = null;
let ctx = null;
function debugFramebuffer(fbo, { id, minimap, opaque, top = '0', left = '0', rgbaScale = 1 }) {
    if (!canvas) {
        canvas = document.createElement('canvas');
        canvas.id = id;
        canvas.title = id;
        canvas.style.zIndex = '100';
        canvas.style.position = 'absolute';
        canvas.style.top = top; // ⚠️
        canvas.style.left = left; // ⚠️
        canvas.style.border = 'blue 5px solid';
        canvas.style.transform = 'scaleY(-1)';
        document.body.appendChild(canvas);
        ctx = canvas.getContext('2d');
    // targetImage = new Image();
    }
    // const canvasHeight = (minimap ? 2 : 1) * fbo.height;
    if (canvas.width !== fbo.width || canvas.height !== fbo.height) {
        canvas.width = fbo.width / 2;
        canvas.height = fbo.height / 2;
        canvas.style.width = '400px';
        canvas.style.height = '400px';
    }
    // const image = copyTextureToImage(fbo, {targetMaxHeight: 100, targetImage});
    // ctx.drawImage(image, 0, 0);
    const color = fbo.device.readPixelsToArrayWebGL(fbo);
    const imageData = ctx?.createImageData(fbo.width, fbo.height);
    if (imageData) {
        // Full map
        const offset = 0;
        // if (color.some((v) => v > 0)) {
        //   console.error('THERE IS NON-ZERO DATA IN THE FBO!');
        // }
        for(let i = 0; i < color.length; i += 4){
            imageData.data[offset + i + 0] = color[i + 0] * rgbaScale;
            imageData.data[offset + i + 1] = color[i + 1] * rgbaScale;
            imageData.data[offset + i + 2] = color[i + 2] * rgbaScale;
            imageData.data[offset + i + 3] = opaque ? 255 : color[i + 3] * rgbaScale;
        }
        ctx?.putImageData(imageData, 0, 0);
    }
} //# sourceMappingURL=debug-framebuffer.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/model/model.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "Model": (()=>Model),
    "getPlatformInfo": (()=>getPlatformInfo)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/render-pipeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$shader$2d$inputs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/shader-inputs.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$wgsl$2f$get$2d$shader$2d$layout$2d$wgsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/wgsl/get-shader-layout-wgsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$factories$2f$pipeline$2d$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/factories/pipeline-factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$factories$2f$shader$2d$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/factories/shader-factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$geometry$2f$gpu$2d$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/geometry/gpu-geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$buffer$2d$layout$2d$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__BufferLayoutHelper__as__$5f$BufferLayoutHelper$3e$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter-utils/buffer-layout-helper.js [app-client] (ecmascript) <export BufferLayoutHelper as _BufferLayoutHelper>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/utils/deep-equal.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$portable$2f$uniform$2d$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/portable/uniform-store.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$split$2d$uniforms$2d$and$2d$bindings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/model/split-uniforms-and-bindings.js [app-client] (ecmascript)");
// import type {AsyncTextureProps} from '../async-texture/async-texture';
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$async$2d$texture$2f$async$2d$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/async-texture/async-texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2d$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/texture-view.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/sampler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$get$2d$attribute$2d$from$2d$layouts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter-utils/get-attribute-from-layouts.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$debug$2f$debug$2d$shader$2d$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/debug/debug-shader-layout.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$debug$2f$debug$2d$framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/debug/debug-framebuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$vertex$2d$format$2d$from$2d$attribute$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/vertex-format-from-attribute.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
const LOG_DRAW_PRIORITY = 2;
const LOG_DRAW_TIMEOUT = 10000;
class Model {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RenderPipeline"].defaultProps,
        source: undefined,
        vs: null,
        fs: null,
        id: 'unnamed',
        handle: undefined,
        userData: {},
        defines: {},
        modules: [],
        moduleSettings: undefined,
        geometry: null,
        indexBuffer: null,
        attributes: {},
        constantAttributes: {},
        varyings: [],
        isInstanced: undefined,
        instanceCount: 0,
        vertexCount: 0,
        shaderInputs: undefined,
        pipelineFactory: undefined,
        shaderFactory: undefined,
        transformFeedback: undefined,
        shaderAssembler: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderAssembler"].getDefaultShaderAssembler(),
        debugShaders: undefined,
        disableWarnings: undefined
    };
    device;
    id;
    // @ts-expect-error assigned in function called from constructor
    source;
    // @ts-expect-error assigned in function called from constructor
    vs;
    // @ts-expect-error assigned in function called from constructor
    fs;
    pipelineFactory;
    shaderFactory;
    userData = {};
    // Fixed properties (change can trigger pipeline rebuild)
    /** The render pipeline GPU parameters, depth testing etc */ parameters;
    /** The primitive topology */ topology;
    /** Buffer layout */ bufferLayout;
    // Dynamic properties
    /** Use instanced rendering */ isInstanced = undefined;
    /** instance count. `undefined` means not instanced */ instanceCount = 0;
    /** Vertex count */ vertexCount;
    /** Index buffer */ indexBuffer = null;
    /** Buffer-valued attributes */ bufferAttributes = {};
    /** Constant-valued attributes */ constantAttributes = {};
    /** Bindings (textures, samplers, uniform buffers) */ bindings = {};
    /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/ uniforms = {};
    /**
     * VertexArray
     * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!
     * @todo - allow application to define multiple vertex arrays?
     * */ vertexArray;
    /** TransformFeedback, WebGL 2 only. */ transformFeedback = null;
    /** The underlying GPU "program". @note May be recreated if parameters change */ pipeline;
    /** ShaderInputs instance */ // @ts-expect-error Assigned in function called by constructor
    shaderInputs;
    // @ts-expect-error Assigned in function called by constructor
    _uniformStore;
    _attributeInfos = {};
    _gpuGeometry = null;
    _getModuleUniforms;
    props;
    _pipelineNeedsUpdate = 'newly created';
    _needsRedraw = 'initializing';
    _destroyed = false;
    /** "Time" of last draw. Monotonically increasing timestamp */ _lastDrawTimestamp = -1;
    get [Symbol.toStringTag]() {
        return 'Model';
    }
    toString() {
        return `Model(${this.id})`;
    }
    constructor(device, props){
        this.props = {
            ...Model.defaultProps,
            ...props
        };
        props = this.props;
        this.id = props.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])('model');
        this.device = device;
        Object.assign(this.userData, props.userData);
        // Setup shader module inputs
        const moduleMap = Object.fromEntries(this.props.modules?.map((module)=>[
                module.name,
                module
            ]) || []);
        const shaderInputs = props.shaderInputs || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$shader$2d$inputs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderInputs"](moduleMap, {
            disableWarnings: this.props.disableWarnings
        });
        // @ts-ignore
        this.setShaderInputs(shaderInputs);
        // Setup shader assembler
        const platformInfo = getPlatformInfo(device);
        // Extract modules from shader inputs if not supplied
        const modules = // @ts-ignore shaderInputs is assigned in setShaderInputs above.
        (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];
        const isWebGPU = this.device.type === 'webgpu';
        // WebGPU
        // TODO - hack to support unified WGSL shader
        // TODO - this is wrong, compile a single shader
        if (isWebGPU && this.props.source) {
            // WGSL
            this.props.shaderLayout ||= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$wgsl$2f$get$2d$shader$2d$layout$2d$wgsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getShaderLayoutFromWGSL"])(this.props.source);
            const { source, getUniforms } = this.props.shaderAssembler.assembleWGSLShader({
                platformInfo,
                ...this.props,
                modules
            });
            this.source = source;
            // @ts-expect-error
            this._getModuleUniforms = getUniforms;
        } else {
            // GLSL
            const { vs, fs, getUniforms } = this.props.shaderAssembler.assembleGLSLShaderPair({
                platformInfo,
                ...this.props,
                modules
            });
            this.vs = vs;
            this.fs = fs;
            // @ts-expect-error
            this._getModuleUniforms = getUniforms;
        }
        this.vertexCount = this.props.vertexCount;
        this.instanceCount = this.props.instanceCount;
        this.topology = this.props.topology;
        this.bufferLayout = this.props.bufferLayout;
        this.parameters = this.props.parameters;
        // Geometry, if provided, sets topology and vertex cound
        if (props.geometry) {
            this.setGeometry(props.geometry);
        }
        this.pipelineFactory = props.pipelineFactory || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$factories$2f$pipeline$2d$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PipelineFactory"].getDefaultPipelineFactory(this.device);
        this.shaderFactory = props.shaderFactory || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$factories$2f$shader$2d$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderFactory"].getDefaultShaderFactory(this.device);
        // Create the pipeline
        // @note order is important
        this.pipeline = this._updatePipeline();
        this.vertexArray = device.createVertexArray({
            renderPipeline: this.pipeline
        });
        // Now we can apply geometry attributes
        if (this._gpuGeometry) {
            this._setGeometryAttributes(this._gpuGeometry);
        }
        // Apply any dynamic settings that will not trigger pipeline change
        if ('isInstanced' in props) {
            this.isInstanced = props.isInstanced;
        }
        if (props.instanceCount) {
            this.setInstanceCount(props.instanceCount);
        }
        if (props.vertexCount) {
            this.setVertexCount(props.vertexCount);
        }
        if (props.indexBuffer) {
            this.setIndexBuffer(props.indexBuffer);
        }
        if (props.attributes) {
            this.setAttributes(props.attributes);
        }
        if (props.constantAttributes) {
            this.setConstantAttributes(props.constantAttributes);
        }
        if (props.bindings) {
            this.setBindings(props.bindings);
        }
        if (props.uniforms) {
            this.setUniformsWebGL(props.uniforms);
        }
        if (props.moduleSettings) {
            // log.warn('Model.props.moduleSettings is deprecated. Use Model.shaderInputs.setProps()')();
            this.updateModuleSettingsWebGL(props.moduleSettings);
        }
        if (props.transformFeedback) {
            this.transformFeedback = props.transformFeedback;
        }
        // Catch any access to non-standard props
        Object.seal(this);
    }
    destroy() {
        if (this._destroyed) return;
        this.pipelineFactory.release(this.pipeline);
        this.shaderFactory.release(this.pipeline.vs);
        if (this.pipeline.fs) {
            this.shaderFactory.release(this.pipeline.fs);
        }
        this._uniformStore.destroy();
        // TODO - mark resource as managed and destroyIfManaged() ?
        this._gpuGeometry?.destroy();
        this._destroyed = true;
    }
    // Draw call
    /** Query redraw status. Clears the status. */ needsRedraw() {
        // Catch any writes to already bound resources
        if (this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp) {
            this.setNeedsRedraw('contents of bound textures or buffers updated');
        }
        const needsRedraw = this._needsRedraw;
        this._needsRedraw = false;
        return needsRedraw;
    }
    /** Mark the model as needing a redraw */ setNeedsRedraw(reason) {
        this._needsRedraw ||= reason;
    }
    predraw() {
        // Update uniform buffers if needed
        this.updateShaderInputs();
        // Check if the pipeline is invalidated
        this.pipeline = this._updatePipeline();
    }
    draw(renderPass) {
        const loadingBinding = this._areBindingsLoading();
        if (loadingBinding) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].info(LOG_DRAW_PRIORITY, `>>> DRAWING ABORTED ${this.id}: ${loadingBinding} not loaded`)();
            return false;
        }
        try {
            renderPass.pushDebugGroup(`${this}.predraw(${renderPass})`);
            this.predraw();
        } finally{
            renderPass.popDebugGroup();
        }
        let drawSuccess;
        try {
            renderPass.pushDebugGroup(`${this}.draw(${renderPass})`);
            this._logDrawCallStart();
            // Update the pipeline if invalidated
            // TODO - inside RenderPass is likely the worst place to do this from performance perspective.
            // Application can call Model.predraw() to avoid this.
            this.pipeline = this._updatePipeline();
            // Set pipeline state, we may be sharing a pipeline so we need to set all state on every draw
            // Any caching needs to be done inside the pipeline functions
            // TODO this is a busy initialized check for all bindings every frame
            const syncBindings = this._getBindings();
            this.pipeline.setBindings(syncBindings, {
                disableWarnings: this.props.disableWarnings
            });
            if (!isObjectEmpty(this.uniforms)) {
                this.pipeline.setUniformsWebGL(this.uniforms);
            }
            const { indexBuffer } = this.vertexArray;
            const indexCount = indexBuffer ? indexBuffer.byteLength / (indexBuffer.indexType === 'uint32' ? 4 : 2) : undefined;
            drawSuccess = this.pipeline.draw({
                renderPass,
                vertexArray: this.vertexArray,
                isInstanced: this.isInstanced,
                vertexCount: this.vertexCount,
                instanceCount: this.instanceCount,
                indexCount,
                transformFeedback: this.transformFeedback || undefined,
                // WebGL shares underlying cached pipelines even for models that have different parameters and topology,
                // so we must provide our unique parameters to each draw
                // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)
                parameters: this.parameters,
                topology: this.topology
            });
        } finally{
            renderPass.popDebugGroup();
            this._logDrawCallEnd();
        }
        this._logFramebuffer(renderPass);
        // Update needsRedraw flag
        if (drawSuccess) {
            this._lastDrawTimestamp = this.device.timestamp;
            this._needsRedraw = false;
        } else {
            this._needsRedraw = 'waiting for resource initialization';
        }
        return drawSuccess;
    }
    // Update fixed fields (can trigger pipeline rebuild)
    /**
     * Updates the optional geometry
     * Geometry, set topology and bufferLayout
     * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
     */ setGeometry(geometry) {
        this._gpuGeometry?.destroy();
        const gpuGeometry = geometry && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$geometry$2f$gpu$2d$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makeGPUGeometry"])(this.device, geometry);
        if (gpuGeometry) {
            this.setTopology(gpuGeometry.topology || 'triangle-list');
            const bufferLayoutHelper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$buffer$2d$layout$2d$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__BufferLayoutHelper__as__$5f$BufferLayoutHelper$3e$__["_BufferLayoutHelper"](this.bufferLayout);
            this.bufferLayout = bufferLayoutHelper.mergeBufferLayouts(gpuGeometry.bufferLayout, this.bufferLayout);
            if (this.vertexArray) {
                this._setGeometryAttributes(gpuGeometry);
            }
        }
        this._gpuGeometry = gpuGeometry;
    }
    /**
     * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).
     * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU
     */ setTopology(topology) {
        if (topology !== this.topology) {
            this.topology = topology;
            this._setPipelineNeedsUpdate('topology');
        }
    }
    /**
     * Updates the buffer layout.
     * @note Triggers a pipeline rebuild / pipeline cache fetch
     */ setBufferLayout(bufferLayout) {
        const bufferLayoutHelper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$buffer$2d$layout$2d$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__BufferLayoutHelper__as__$5f$BufferLayoutHelper$3e$__["_BufferLayoutHelper"](this.bufferLayout);
        this.bufferLayout = this._gpuGeometry ? bufferLayoutHelper.mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout) : bufferLayout;
        this._setPipelineNeedsUpdate('bufferLayout');
        // Recreate the pipeline
        this.pipeline = this._updatePipeline();
        // vertex array needs to be updated if we update buffer layout,
        // but not if we update parameters
        this.vertexArray = this.device.createVertexArray({
            renderPipeline: this.pipeline
        });
        // Reapply geometry attributes to the new vertex array
        if (this._gpuGeometry) {
            this._setGeometryAttributes(this._gpuGeometry);
        }
    }
    /**
     * Set GPU parameters.
     * @note Can trigger a pipeline rebuild / pipeline cache fetch.
     * @param parameters
     */ setParameters(parameters) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(parameters, this.parameters, 2)) {
            this.parameters = parameters;
            this._setPipelineNeedsUpdate('parameters');
        }
    }
    // Update dynamic fields
    /**
     * Updates the instance count (used in draw calls)
     * @note Any attributes with stepMode=instance need to be at least this big
     */ setInstanceCount(instanceCount) {
        this.instanceCount = instanceCount;
        // luma.gl examples don't set props.isInstanced and rely on auto-detection
        // but deck.gl sets instanceCount even for models that are not instanced.
        if (this.isInstanced === undefined && instanceCount > 0) {
            this.isInstanced = true;
        }
        this.setNeedsRedraw('instanceCount');
    }
    /**
     * Updates the vertex count (used in draw calls)
     * @note Any attributes with stepMode=vertex need to be at least this big
     */ setVertexCount(vertexCount) {
        this.vertexCount = vertexCount;
        this.setNeedsRedraw('vertexCount');
    }
    /** Set the shader inputs */ setShaderInputs(shaderInputs) {
        this.shaderInputs = shaderInputs;
        this._uniformStore = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$portable$2f$uniform$2d$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UniformStore"](this.shaderInputs.modules);
        // Create uniform buffer bindings for all modules that actually have uniforms
        for (const [moduleName, module] of Object.entries(this.shaderInputs.modules)){
            if (shaderModuleHasUniforms(module)) {
                const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);
                this.bindings[`${moduleName}Uniforms`] = uniformBuffer;
            }
        }
        this.setNeedsRedraw('shaderInputs');
    }
    /** Update uniform buffers from the model's shader inputs */ updateShaderInputs() {
        this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());
        this.setBindings(this.shaderInputs.getBindingValues());
        // TODO - this is already tracked through buffer/texture update times?
        this.setNeedsRedraw('shaderInputs');
    }
    /**
     * Sets bindings (textures, samplers, uniform buffers)
     */ setBindings(bindings) {
        Object.assign(this.bindings, bindings);
        this.setNeedsRedraw('bindings');
    }
    /**
     * Updates optional transform feedback. WebGL only.
     */ setTransformFeedback(transformFeedback) {
        this.transformFeedback = transformFeedback;
        this.setNeedsRedraw('transformFeedback');
    }
    /**
     * Sets the index buffer
     * @todo - how to unset it if we change geometry?
     */ setIndexBuffer(indexBuffer) {
        this.vertexArray.setIndexBuffer(indexBuffer);
        this.setNeedsRedraw('indexBuffer');
    }
    /**
     * Sets attributes (buffers)
     * @note Overrides any attributes previously set with the same name
     */ setAttributes(buffers, options) {
        const disableWarnings = options?.disableWarnings ?? this.props.disableWarnings;
        if (buffers.indices) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
        }
        const bufferLayoutHelper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$buffer$2d$layout$2d$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__BufferLayoutHelper__as__$5f$BufferLayoutHelper$3e$__["_BufferLayoutHelper"](this.bufferLayout);
        // Check if all buffers have a layout
        for (const [bufferName, buffer] of Object.entries(buffers)){
            const bufferLayout = bufferLayoutHelper.getBufferLayout(bufferName);
            if (!bufferLayout) {
                if (!disableWarnings) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`Model(${this.id}): Missing layout for buffer "${bufferName}".`)();
                }
                continue; // eslint-disable-line no-continue
            }
            // For an interleaved attribute we may need to set multiple attributes
            const attributeNames = bufferLayoutHelper.getAttributeNamesForBuffer(bufferLayout);
            let set = false;
            for (const attributeName of attributeNames){
                const attributeInfo = this._attributeInfos[attributeName];
                if (attributeInfo) {
                    this.vertexArray.setBuffer(attributeInfo.location, buffer);
                    set = true;
                }
            }
            if (!set && !disableWarnings) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`Model(${this.id}): Ignoring buffer "${buffer.id}" for unknown attribute "${bufferName}"`)();
            }
        }
        this.setNeedsRedraw('attributes');
    }
    /**
     * Sets constant attributes
     * @note Overrides any attributes previously set with the same name
     * Constant attributes are only supported in WebGL, not in WebGPU
     * Any attribute that is disabled in the current vertex array object
     * is read from the context's global constant value for that attribute location.
     * @param constantAttributes
     */ setConstantAttributes(attributes, options) {
        for (const [attributeName, value] of Object.entries(attributes)){
            const attributeInfo = this._attributeInfos[attributeName];
            if (attributeInfo) {
                this.vertexArray.setConstantWebGL(attributeInfo.location, value);
            } else if (!(options?.disableWarnings ?? this.props.disableWarnings)) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${attributeName}"`)();
            }
        }
        this.setNeedsRedraw('constants');
    }
    // DEPRECATED METHODS
    /**
     * Sets individual uniforms
     * @deprecated WebGL only, use uniform buffers for portability
     * @param uniforms
     */ setUniforms(uniforms) {
        this.setUniformsWebGL(uniforms);
    }
    /**
     * Sets individual uniforms
     * @deprecated WebGL only, use uniform buffers for portability
     * @param uniforms
     */ setUniformsWebGL(uniforms) {
        if (!isObjectEmpty(uniforms)) {
            this.pipeline.setUniformsWebGL(uniforms);
            Object.assign(this.uniforms, uniforms);
        }
        this.setNeedsRedraw('uniforms');
    }
    /**
     * @deprecated Updates shader module settings (which results in uniforms being set)
     */ updateModuleSettingsWebGL(props) {
        // log.warn('Model.updateModuleSettings is deprecated. Use Model.shaderInputs.setProps()')();
        const { bindings, uniforms } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$split$2d$uniforms$2d$and$2d$bindings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["splitUniformsAndBindings"])(this._getModuleUniforms(props));
        Object.assign(this.bindings, bindings);
        Object.assign(this.uniforms, uniforms);
        this.setNeedsRedraw('moduleSettings');
    }
    // Internal methods
    /** Check that bindings are loaded. Returns id of first binding that is still loading. */ _areBindingsLoading() {
        for (const binding of Object.values(this.bindings)){
            if (binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$async$2d$texture$2f$async$2d$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AsyncTexture"] && !binding.isReady) {
                return binding.id;
            }
        }
        return false;
    }
    /** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */ _getBindings() {
        const validBindings = {};
        for (const [name, binding] of Object.entries(this.bindings)){
            if (binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$async$2d$texture$2f$async$2d$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AsyncTexture"]) {
                // Check that async textures are loaded
                if (binding.isReady) {
                    validBindings[name] = binding.texture;
                }
            } else {
                validBindings[name] = binding;
            }
        }
        return validBindings;
    }
    /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */ _getBindingsUpdateTimestamp() {
        let timestamp = 0;
        for (const binding of Object.values(this.bindings)){
            if (binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2d$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureView"]) {
                timestamp = Math.max(timestamp, binding.texture.updateTimestamp);
            } else if (binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] || binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"]) {
                timestamp = Math.max(timestamp, binding.updateTimestamp);
            } else if (binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$async$2d$texture$2f$async$2d$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AsyncTexture"]) {
                timestamp = binding.texture ? Math.max(timestamp, binding.texture.updateTimestamp) : Infinity;
            } else if (!(binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Sampler"])) {
                timestamp = Math.max(timestamp, binding.buffer.updateTimestamp);
            }
        }
        return timestamp;
    }
    /**
     * Updates the optional geometry attributes
     * Geometry, sets several attributes, indexBuffer, and also vertex count
     * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
     */ _setGeometryAttributes(gpuGeometry) {
        // Filter geometry attribute so that we don't issue warnings for unused attributes
        const attributes = {
            ...gpuGeometry.attributes
        };
        for (const [attributeName] of Object.entries(attributes)){
            if (!this.pipeline.shaderLayout.attributes.find((layout)=>layout.name === attributeName) && attributeName !== 'positions') {
                delete attributes[attributeName];
            }
        }
        // TODO - delete previous geometry?
        this.vertexCount = gpuGeometry.vertexCount;
        this.setIndexBuffer(gpuGeometry.indices || null);
        this.setAttributes(gpuGeometry.attributes, {
            disableWarnings: true
        });
        this.setAttributes(attributes, {
            disableWarnings: this.props.disableWarnings
        });
        this.setNeedsRedraw('geometry attributes');
    }
    /** Mark pipeline as needing update */ _setPipelineNeedsUpdate(reason) {
        this._pipelineNeedsUpdate ||= reason;
        this.setNeedsRedraw(reason);
    }
    /** Update pipeline if needed */ _updatePipeline() {
        if (this._pipelineNeedsUpdate) {
            let prevShaderVs = null;
            let prevShaderFs = null;
            if (this.pipeline) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)();
                prevShaderVs = this.pipeline.vs;
                prevShaderFs = this.pipeline.fs;
            }
            this._pipelineNeedsUpdate = false;
            const vs = this.shaderFactory.createShader({
                id: `${this.id}-vertex`,
                stage: 'vertex',
                source: this.source || this.vs,
                debugShaders: this.props.debugShaders
            });
            let fs = null;
            if (this.source) {
                fs = vs;
            } else if (this.fs) {
                fs = this.shaderFactory.createShader({
                    id: `${this.id}-fragment`,
                    stage: 'fragment',
                    source: this.source || this.fs,
                    debugShaders: this.props.debugShaders
                });
            }
            this.pipeline = this.pipelineFactory.createRenderPipeline({
                ...this.props,
                bufferLayout: this.bufferLayout,
                topology: this.topology,
                parameters: this.parameters,
                // TODO - why set bindings here when we reset them every frame?
                // Should we expose a BindGroup abstraction?
                bindings: this._getBindings(),
                vs,
                fs
            });
            this._attributeInfos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$get$2d$attribute$2d$from$2d$layouts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttributeInfosFromLayouts"])(this.pipeline.shaderLayout, this.bufferLayout);
            if (prevShaderVs) this.shaderFactory.release(prevShaderVs);
            if (prevShaderFs) this.shaderFactory.release(prevShaderFs);
        }
        return this.pipeline;
    }
    /** Throttle draw call logging */ _lastLogTime = 0;
    _logOpen = false;
    _logDrawCallStart() {
        // IF level is 4 or higher, log every frame.
        const logDrawTimeout = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].level > 3 ? 0 : LOG_DRAW_TIMEOUT;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {
            return;
        }
        this._lastLogTime = Date.now();
        this._logOpen = true;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {
            collapsed: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].level <= 2
        })();
    }
    _logDrawCallEnd() {
        if (this._logOpen) {
            const shaderLayoutTable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$debug$2f$debug$2d$shader$2d$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDebugTableForShaderLayout"])(this.pipeline.shaderLayout, this.id);
            // log.table(logLevel, attributeTable)();
            // log.table(logLevel, uniformTable)();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].table(LOG_DRAW_PRIORITY, shaderLayoutTable)();
            const uniformTable = this.shaderInputs.getDebugTable();
            // Add any global uniforms
            for (const [name, value] of Object.entries(this.uniforms)){
                uniformTable[name] = {
                    value
                };
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].table(LOG_DRAW_PRIORITY, uniformTable)();
            const attributeTable = this._getAttributeDebugTable();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].table(LOG_DRAW_PRIORITY, this._attributeInfos)();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].table(LOG_DRAW_PRIORITY, attributeTable)();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].groupEnd(LOG_DRAW_PRIORITY)();
            this._logOpen = false;
        }
    }
    _drawCount = 0;
    _logFramebuffer(renderPass) {
        const debugFramebuffers = this.device.props.debugFramebuffers;
        this._drawCount++;
        // Update first 3 frames and then every 60 frames
        if (!debugFramebuffers) {
            // } || (this._drawCount++ > 3 && this._drawCount % 60)) {
            return;
        }
        // TODO - display framebuffer output in debug window
        const framebuffer = renderPass.props.framebuffer;
        if (framebuffer) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$debug$2f$debug$2d$framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["debugFramebuffer"])(framebuffer, {
                id: framebuffer.id,
                minimap: true
            });
        // log.image({logLevel: LOG_DRAW_PRIORITY, message: `${framebuffer.id} %c sup?`, image})();
        }
    }
    _getAttributeDebugTable() {
        const table = {};
        for (const [name, attributeInfo] of Object.entries(this._attributeInfos)){
            const values = this.vertexArray.attributes[attributeInfo.location];
            table[attributeInfo.location] = {
                name,
                type: attributeInfo.shaderType,
                values: values ? this._getBufferOrConstantValues(values, attributeInfo.bufferDataType) : 'null'
            };
        }
        if (this.vertexArray.indexBuffer) {
            const { indexBuffer } = this.vertexArray;
            const values = indexBuffer.indexType === 'uint32' ? new Uint32Array(indexBuffer.debugData) : new Uint16Array(indexBuffer.debugData);
            table.indices = {
                name: 'indices',
                type: indexBuffer.indexType,
                values: values.toString()
            };
        }
        return table;
    }
    // TODO - fix typing of luma data types
    _getBufferOrConstantValues(attribute, dataType) {
        const TypedArrayConstructor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$vertex$2d$format$2d$from$2d$attribute$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTypedArrayFromDataType"])(dataType);
        const typedArray = attribute instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] ? new TypedArrayConstructor(attribute.debugData) : attribute;
        return typedArray.toString();
    }
}
function shaderModuleHasUniforms(module) {
    return Boolean(module.uniformTypes && !isObjectEmpty(module.uniformTypes));
}
function getPlatformInfo(device) {
    return {
        type: device.type,
        shaderLanguage: device.info.shadingLanguage,
        shaderLanguageVersion: device.info.shadingLanguageVersion,
        gpu: device.info.gpu,
        // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API
        features: device.features
    };
}
/** Returns true if given object is empty, false otherwise. */ function isObjectEmpty(obj) {
    // @ts-ignore key is unused
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for(const key in obj){
        return false;
    }
    return true;
} //# sourceMappingURL=model.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/compute/buffer-transform.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "BufferTransform": (()=>BufferTransform)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/model/model.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$glsl$2d$utils$2f$shader$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/shader-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/buffer.js [app-client] (ecmascript)");
;
;
;
class BufferTransform {
    device;
    model;
    transformFeedback;
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Model"].defaultProps,
        outputs: undefined,
        feedbackBuffers: undefined
    };
    static isSupported(device) {
        return device?.info?.type === 'webgl';
    }
    constructor(device, props = BufferTransform.defaultProps){
        if (!BufferTransform.isSupported(device)) {
            throw new Error('BufferTransform not yet implemented on WebGPU');
        }
        this.device = device;
        this.model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Model"](this.device, {
            id: props.id || 'buffer-transform-model',
            fs: props.fs || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$glsl$2d$utils$2f$shader$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPassthroughFS"])(),
            topology: props.topology || 'point-list',
            varyings: props.outputs || props.varyings,
            ...props
        });
        this.transformFeedback = this.device.createTransformFeedback({
            layout: this.model.pipeline.shaderLayout,
            // @ts-expect-error TODO
            buffers: props.feedbackBuffers
        });
        this.model.setTransformFeedback(this.transformFeedback);
        Object.seal(this);
    }
    /** Destroy owned resources. */ destroy() {
        if (this.model) {
            this.model.destroy();
        }
    }
    /** @deprecated Use {@link destroy}. */ delete() {
        this.destroy();
    }
    /** Run one transform loop. */ run(options) {
        if (options?.inputBuffers) {
            this.model.setAttributes(options.inputBuffers);
        }
        if (options?.outputBuffers) {
            this.transformFeedback.setBuffers(options.outputBuffers);
        }
        const renderPass = this.device.beginRenderPass(options);
        this.model.draw(renderPass);
        renderPass.end();
    }
    // DEPRECATED METHODS
    /** @deprecated App knows what buffers it is passing in - Returns the {@link Buffer} or {@link BufferRange} for given varying name. */ getBuffer(varyingName) {
        return this.transformFeedback.getBuffer(varyingName);
    }
    /** @deprecated App knows what buffers it is passing in - Reads the {@link Buffer} or {@link BufferRange} for given varying name. */ readAsync(varyingName) {
        const result = this.getBuffer(varyingName);
        if (!result) {
            throw new Error('BufferTransform#getBuffer');
        }
        if (result instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"]) {
            return result.readAsync();
        }
        const { buffer, byteOffset = 0, byteLength = buffer.byteLength } = result;
        return buffer.readAsync(byteOffset, byteLength);
    }
} //# sourceMappingURL=buffer-transform.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/geometry/geometry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "Geometry": (()=>Geometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [app-client] (ecmascript)");
;
class Geometry {
    id;
    /** Determines how vertices are read from the 'vertex' attributes */ topology;
    vertexCount;
    indices;
    attributes;
    userData = {};
    constructor(props){
        const { attributes = {}, indices = null, vertexCount = null } = props;
        this.id = props.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])('geometry');
        this.topology = props.topology;
        if (indices) {
            this.indices = ArrayBuffer.isView(indices) ? {
                value: indices,
                size: 1
            } : indices;
        }
        // @ts-expect-error
        this.attributes = {};
        for (const [attributeName, attributeValue] of Object.entries(attributes)){
            // Wrap "unwrapped" arrays and try to autodetect their type
            const attribute = ArrayBuffer.isView(attributeValue) ? {
                value: attributeValue
            } : attributeValue;
            if (!ArrayBuffer.isView(attribute.value)) {
                throw new Error(`${this._print(attributeName)}: must be typed array or object with value as typed array`);
            }
            if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {
                attribute.size = 3;
            }
            // Move indices to separate field
            if (attributeName === 'indices') {
                if (this.indices) {
                    throw new Error('Multiple indices detected');
                }
                this.indices = attribute;
            } else {
                this.attributes[attributeName] = attribute;
            }
        }
        if (this.indices && this.indices.isIndexed !== undefined) {
            this.indices = Object.assign({}, this.indices);
            delete this.indices.isIndexed;
        }
        this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
    }
    getVertexCount() {
        return this.vertexCount;
    }
    /**
     * Return an object with all attributes plus indices added as a field.
     * TODO Geometry types are a mess
     */ getAttributes() {
        return this.indices ? {
            indices: this.indices,
            ...this.attributes
        } : this.attributes;
    }
    // PRIVATE
    _print(attributeName) {
        return `Geometry ${this.id} attribute ${attributeName}`;
    }
    /**
     * GeometryAttribute
     * value: typed array
     * type: indices, vertices, uvs
     * size: elements per vertex
     * target: WebGL buffer type (string or constant)
     *
     * @param attributes
     * @param indices
     * @returns
     */ _setAttributes(attributes, indices) {
        return this;
    }
    _calculateVertexCount(attributes, indices) {
        if (indices) {
            return indices.value.length;
        }
        let vertexCount = Infinity;
        for (const attribute of Object.values(attributes)){
            const { value, size, constant } = attribute;
            if (!constant && value && size !== undefined && size >= 1) {
                vertexCount = Math.min(vertexCount, value.length / size);
            }
        }
        // assert(Number.isFinite(vertexCount));
        return vertexCount;
    }
} //# sourceMappingURL=geometry.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/compute/texture-transform.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "TextureTransform": (()=>TextureTransform)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/model/model.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$glsl$2d$utils$2f$shader$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/shader-utils.js [app-client] (ecmascript)");
;
;
const FS_OUTPUT_VARIABLE = 'transform_output';
class TextureTransform {
    device;
    model;
    sampler;
    currentIndex = 0;
    samplerTextureMap = null;
    bindings = [];
    resources = {};
    constructor(device, props){
        this.device = device;
        // For precise picking of element IDs.
        this.sampler = device.createSampler({
            addressModeU: 'clamp-to-edge',
            addressModeV: 'clamp-to-edge',
            minFilter: 'nearest',
            magFilter: 'nearest',
            mipmapFilter: 'nearest'
        });
        this.model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Model"](this.device, {
            id: props.id || 'texture-transform-model',
            fs: props.fs || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$glsl$2d$utils$2f$shader$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPassthroughFS"])({
                input: props.targetTextureVarying,
                inputChannels: props.targetTextureChannels,
                output: FS_OUTPUT_VARIABLE
            }),
            vertexCount: props.vertexCount,
            ...props
        });
        this._initialize(props);
        Object.seal(this);
    }
    // Delete owned resources.
    destroy() {
        this.model.destroy();
        for (const binding of this.bindings){
            binding.framebuffer?.destroy();
        }
    }
    /** @deprecated Use {@link destroy}. */ delete() {
        this.destroy();
    }
    run(options) {
        const { framebuffer } = this.bindings[this.currentIndex];
        const renderPass = this.device.beginRenderPass({
            framebuffer,
            ...options
        });
        this.model.draw(renderPass);
        renderPass.end();
    }
    getTargetTexture() {
        const { targetTexture } = this.bindings[this.currentIndex];
        return targetTexture;
    }
    getFramebuffer() {
        const currentResources = this.bindings[this.currentIndex];
        return currentResources.framebuffer;
    }
    // Private
    _initialize(props) {
        this._updateBindings(props);
    }
    _updateBindings(props) {
        this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], props);
    }
    _updateBinding(binding, { sourceBuffers, sourceTextures, targetTexture }) {
        if (!binding) {
            binding = {
                sourceBuffers: {},
                sourceTextures: {},
                // @ts-expect-error
                targetTexture: null
            };
        }
        Object.assign(binding.sourceTextures, sourceTextures);
        Object.assign(binding.sourceBuffers, sourceBuffers);
        if (targetTexture) {
            binding.targetTexture = targetTexture;
            const { width, height } = targetTexture;
            // TODO(donmccurdy): When is this called, and is this expected?
            if (binding.framebuffer) {
                binding.framebuffer.destroy();
            }
            binding.framebuffer = this.device.createFramebuffer({
                id: 'transform-framebuffer',
                width,
                height,
                colorAttachments: [
                    targetTexture
                ]
            });
            binding.framebuffer.resize({
                width,
                height
            });
        }
        return binding;
    }
    // set texture filtering parameters on source textures.
    _setSourceTextureParameters() {
        const index = this.currentIndex;
        const { sourceTextures } = this.bindings[index];
        for(const name in sourceTextures){
            sourceTextures[name].sampler = this.sampler;
        }
    }
} //# sourceMappingURL=texture-transform.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/geometries/cube-geometry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "CUBE_NON_INDEXED_COLORS": (()=>CUBE_NON_INDEXED_COLORS),
    "CUBE_NON_INDEXED_POSITIONS": (()=>CUBE_NON_INDEXED_POSITIONS),
    "CUBE_NON_INDEXED_TEX_COORDS": (()=>CUBE_NON_INDEXED_TEX_COORDS),
    "CubeGeometry": (()=>CubeGeometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$geometry$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/geometry/geometry.js [app-client] (ecmascript)");
;
;
class CubeGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$geometry$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Geometry"] {
    constructor(props = {}){
        const { id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])('cube-geometry'), indices = true } = props;
        super(indices ? {
            ...props,
            id,
            topology: 'triangle-list',
            indices: {
                size: 1,
                value: CUBE_INDICES
            },
            attributes: {
                ...ATTRIBUTES,
                ...props.attributes
            }
        } : {
            ...props,
            id,
            topology: 'triangle-list',
            indices: undefined,
            attributes: {
                ...NON_INDEXED_ATTRIBUTES,
                ...props.attributes
            }
        });
    }
}
// prettier-ignore
const CUBE_INDICES = new Uint16Array([
    0,
    1,
    2,
    0,
    2,
    3,
    4,
    5,
    6,
    4,
    6,
    7,
    8,
    9,
    10,
    8,
    10,
    11,
    12,
    13,
    14,
    12,
    14,
    15,
    16,
    17,
    18,
    16,
    18,
    19,
    20,
    21,
    22,
    20,
    22,
    23
]);
// prettier-ignore
const CUBE_POSITIONS = new Float32Array([
    -1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1
]);
// TODO - could be Uint8
// prettier-ignore
const CUBE_NORMALS = new Float32Array([
    // Front face
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    // Back face
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    // Top face
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    // Bottom face
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    // Right face
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    // Left face
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0
]);
// prettier-ignore
const CUBE_TEX_COORDS = new Float32Array([
    // Front face
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    // Back face
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    // Top face
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    // Bottom face
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    // Right face
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    // Left face
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1
]);
const CUBE_NON_INDEXED_POSITIONS = new Float32Array([
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    1,
    -1
]);
const CUBE_NON_INDEXED_TEX_COORDS = new Float32Array([
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0
]);
const CUBE_NON_INDEXED_COLORS = new Float32Array([
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    0,
    1,
    0,
    1
]);
const ATTRIBUTES = {
    POSITION: {
        size: 3,
        value: CUBE_POSITIONS
    },
    NORMAL: {
        size: 3,
        value: CUBE_NORMALS
    },
    TEXCOORD_0: {
        size: 2,
        value: CUBE_TEX_COORDS
    }
};
const NON_INDEXED_ATTRIBUTES = {
    POSITION: {
        size: 3,
        value: CUBE_NON_INDEXED_POSITIONS
    },
    // NORMAL: {size: 3, value: CUBE_NON_INDEXED_NORMALS},
    TEXCOORD_0: {
        size: 2,
        value: CUBE_NON_INDEXED_TEX_COORDS
    },
    COLOR_0: {
        size: 3,
        value: CUBE_NON_INDEXED_COLORS
    }
}; //# sourceMappingURL=cube-geometry.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/animation-loop/request-animation-frame.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* global window, setTimeout, clearTimeout */ /** Node.js polyfill for requestAnimationFrame */ // / <reference types="@types/node" />
__turbopack_esm__({
    "cancelAnimationFramePolyfill": (()=>cancelAnimationFramePolyfill),
    "requestAnimationFramePolyfill": (()=>requestAnimationFramePolyfill)
});
function requestAnimationFramePolyfill(callback) {
    return typeof window !== 'undefined' && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1000 / 60);
}
function cancelAnimationFramePolyfill(timerId) {
    return typeof window !== 'undefined' && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
} //# sourceMappingURL=request-animation-frame.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/animation-loop/animation-loop.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "AnimationLoop": (()=>AnimationLoop)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@probe.gl/stats/dist/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$luma$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/luma.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Stats$3e$__ = __turbopack_import__("[project]/node_modules/@probe.gl/stats/dist/lib/stats.js [app-client] (ecmascript) <export default as Stats>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$animation$2d$loop$2f$request$2d$animation$2d$frame$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/engine/dist/animation-loop/request-animation-frame.js [app-client] (ecmascript)");
;
;
;
let statIdCounter = 0;
const DEFAULT_ANIMATION_LOOP_PROPS = {
    device: null,
    onAddHTML: ()=>'',
    onInitialize: async ()=>{
        return null;
    },
    onRender: ()=>{},
    onFinalize: ()=>{},
    onError: (error)=>console.error(error),
    stats: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$luma$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["luma"].stats.get(`animation-loop-${statIdCounter++}`),
    // view parameters
    useDevicePixels: true,
    autoResizeViewport: false,
    autoResizeDrawingBuffer: false
};
class AnimationLoop {
    device = null;
    canvas = null;
    props;
    animationProps = null;
    timeline = null;
    stats;
    cpuTime;
    gpuTime;
    frameRate;
    display;
    needsRedraw = 'initialized';
    _initialized = false;
    _running = false;
    _animationFrameId = null;
    _nextFramePromise = null;
    _resolveNextFrame = null;
    _cpuStartTime = 0;
    _error = null;
    // _gpuTimeQuery: Query | null = null;
    /*
     * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
     */ constructor(props){
        this.props = {
            ...DEFAULT_ANIMATION_LOOP_PROPS,
            ...props
        };
        props = this.props;
        if (!props.device) {
            throw new Error('No device provided');
        }
        const { useDevicePixels = true } = this.props;
        // state
        this.stats = props.stats || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Stats$3e$__["Stats"]({
            id: 'animation-loop-stats'
        });
        this.cpuTime = this.stats.get('CPU Time');
        this.gpuTime = this.stats.get('GPU Time');
        this.frameRate = this.stats.get('Frame Rate');
        this.setProps({
            autoResizeViewport: props.autoResizeViewport,
            autoResizeDrawingBuffer: props.autoResizeDrawingBuffer,
            useDevicePixels
        });
        // Bind methods
        this.start = this.start.bind(this);
        this.stop = this.stop.bind(this);
        this._onMousemove = this._onMousemove.bind(this);
        this._onMouseleave = this._onMouseleave.bind(this);
    }
    destroy() {
        this.stop();
        this._setDisplay(null);
    }
    /** @deprecated Use .destroy() */ delete() {
        this.destroy();
    }
    setError(error) {
        this.props.onError(error);
        this._error = Error();
        const canvas = this.device?.canvasContext?.canvas;
        if (canvas instanceof HTMLCanvasElement) {
            const errorDiv = document.createElement('h1');
            errorDiv.innerHTML = error.message;
            errorDiv.style.position = 'absolute';
            errorDiv.style.top = '20%'; // left: 50%; transform: translate(-50%, -50%);';
            errorDiv.style.left = '10px';
            errorDiv.style.color = 'black';
            errorDiv.style.backgroundColor = 'red';
            document.body.appendChild(errorDiv);
        // canvas.style.position = 'absolute';
        }
    }
    /** Flags this animation loop as needing redraw */ setNeedsRedraw(reason) {
        this.needsRedraw = this.needsRedraw || reason;
        return this;
    }
    /** TODO - move these props to CanvasContext? */ setProps(props) {
        if ('autoResizeViewport' in props) {
            this.props.autoResizeViewport = props.autoResizeViewport || false;
        }
        if ('autoResizeDrawingBuffer' in props) {
            this.props.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer || false;
        }
        if ('useDevicePixels' in props) {
            this.props.useDevicePixels = props.useDevicePixels || false;
        }
        return this;
    }
    /** Starts a render loop if not already running */ async start() {
        if (this._running) {
            return this;
        }
        this._running = true;
        try {
            let appContext;
            if (!this._initialized) {
                this._initialized = true;
                // Create the WebGL context
                await this._initDevice();
                this._initialize();
                // Note: onIntialize can return a promise (e.g. in case app needs to load resources)
                await this.props.onInitialize(this._getAnimationProps());
            }
            // check that we haven't been stopped
            if (!this._running) {
                return null;
            }
            // Start the loop
            if (appContext !== false) {
                // cancel any pending renders to ensure only one loop can ever run
                this._cancelAnimationFrame();
                this._requestAnimationFrame();
            }
            return this;
        } catch (err) {
            const error = err instanceof Error ? err : new Error('Unknown error');
            this.props.onError(error);
            // this._running = false; // TODO
            throw error;
        }
    }
    /** Stops a render loop if already running, finalizing */ stop() {
        // console.debug(`Stopping ${this.constructor.name}`);
        if (this._running) {
            // call callback
            // If stop is called immediately, we can end up in a state where props haven't been initialized...
            if (this.animationProps && !this._error) {
                this.props.onFinalize(this.animationProps);
            }
            this._cancelAnimationFrame();
            this._nextFramePromise = null;
            this._resolveNextFrame = null;
            this._running = false;
        }
        return this;
    }
    /** Explicitly draw a frame */ redraw() {
        if (this.device?.isLost || this._error) {
            return this;
        }
        this._beginFrameTimers();
        this._setupFrame();
        this._updateAnimationProps();
        this._renderFrame(this._getAnimationProps());
        // clear needsRedraw flag
        this._clearNeedsRedraw();
        if (this._resolveNextFrame) {
            this._resolveNextFrame(this);
            this._nextFramePromise = null;
            this._resolveNextFrame = null;
        }
        this._endFrameTimers();
        return this;
    }
    /** Add a timeline, it will be automatically updated by the animation loop. */ attachTimeline(timeline) {
        this.timeline = timeline;
        return this.timeline;
    }
    /** Remove a timeline */ detachTimeline() {
        this.timeline = null;
    }
    /** Wait until a render completes */ waitForRender() {
        this.setNeedsRedraw('waitForRender');
        if (!this._nextFramePromise) {
            this._nextFramePromise = new Promise((resolve)=>{
                this._resolveNextFrame = resolve;
            });
        }
        return this._nextFramePromise;
    }
    /** TODO - should use device.deviceContext */ async toDataURL() {
        this.setNeedsRedraw('toDataURL');
        await this.waitForRender();
        if (this.canvas instanceof HTMLCanvasElement) {
            return this.canvas.toDataURL();
        }
        throw new Error('OffscreenCanvas');
    }
    // PRIVATE METHODS
    _initialize() {
        this._startEventHandling();
        // Initialize the callback data
        this._initializeAnimationProps();
        this._updateAnimationProps();
        // Default viewport setup, in case onInitialize wants to render
        this._resizeCanvasDrawingBuffer();
        this._resizeViewport();
    // this._gpuTimeQuery = Query.isSupported(this.gl, ['timers']) ? new Query(this.gl) : null;
    }
    _setDisplay(display) {
        if (this.display) {
            this.display.destroy();
            this.display.animationLoop = null;
        }
        // store animation loop on the display
        if (display) {
            display.animationLoop = this;
        }
        this.display = display;
    }
    _requestAnimationFrame() {
        if (!this._running) {
            return;
        }
        // VR display has a separate animation frame to sync with headset
        // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/
        // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame
        // if (this.display && this.display.requestAnimationFrame) {
        //   this._animationFrameId = this.display.requestAnimationFrame(this._animationFrame.bind(this));
        // }
        this._animationFrameId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$animation$2d$loop$2f$request$2d$animation$2d$frame$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["requestAnimationFramePolyfill"])(this._animationFrame.bind(this));
    }
    _cancelAnimationFrame() {
        if (this._animationFrameId === null) {
            return;
        }
        // VR display has a separate animation frame to sync with headset
        // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/
        // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame
        // if (this.display && this.display.cancelAnimationFramePolyfill) {
        //   this.display.cancelAnimationFrame(this._animationFrameId);
        // }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$animation$2d$loop$2f$request$2d$animation$2d$frame$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cancelAnimationFramePolyfill"])(this._animationFrameId);
        this._animationFrameId = null;
    }
    _animationFrame() {
        if (!this._running) {
            return;
        }
        this.redraw();
        this._requestAnimationFrame();
    }
    // Called on each frame, can be overridden to call onRender multiple times
    // to support e.g. stereoscopic rendering
    _renderFrame(animationProps) {
        // Allow e.g. VR display to render multiple frames.
        if (this.display) {
            this.display._renderFrame(animationProps);
            return;
        }
        // call callback
        this.props.onRender(this._getAnimationProps());
        // end callback
        // Submit commands (necessary on WebGPU)
        this.device?.submit();
    }
    _clearNeedsRedraw() {
        this.needsRedraw = false;
    }
    _setupFrame() {
        this._resizeCanvasDrawingBuffer();
        this._resizeViewport();
    }
    // Initialize the  object that will be passed to app callbacks
    _initializeAnimationProps() {
        const canvas = this.device?.canvasContext?.canvas;
        if (!this.device || !canvas) {
            throw new Error('loop');
        }
        this.animationProps = {
            animationLoop: this,
            device: this.device,
            canvas,
            timeline: this.timeline,
            // Initial values
            useDevicePixels: this.props.useDevicePixels,
            needsRedraw: false,
            // Placeholders
            width: 1,
            height: 1,
            aspect: 1,
            // Animation props
            time: 0,
            startTime: Date.now(),
            engineTime: 0,
            tick: 0,
            tock: 0,
            // Experimental
            _mousePosition: null // Event props
        };
    }
    _getAnimationProps() {
        if (!this.animationProps) {
            throw new Error('animationProps');
        }
        return this.animationProps;
    }
    // Update the context object that will be passed to app callbacks
    _updateAnimationProps() {
        if (!this.animationProps) {
            return;
        }
        // Can this be replaced with canvas context?
        const { width, height, aspect } = this._getSizeAndAspect();
        if (width !== this.animationProps.width || height !== this.animationProps.height) {
            this.setNeedsRedraw('drawing buffer resized');
        }
        if (aspect !== this.animationProps.aspect) {
            this.setNeedsRedraw('drawing buffer aspect changed');
        }
        this.animationProps.width = width;
        this.animationProps.height = height;
        this.animationProps.aspect = aspect;
        this.animationProps.needsRedraw = this.needsRedraw;
        // Update time properties
        this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
        if (this.timeline) {
            this.timeline.update(this.animationProps.engineTime);
        }
        this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);
        this.animationProps.tock++;
        // For back compatibility
        this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
    }
    /** Wait for supplied device */ async _initDevice() {
        this.device = await this.props.device;
        if (!this.device) {
            throw new Error('No device provided');
        }
        this.canvas = this.device.canvasContext?.canvas || null;
    // this._createInfoDiv();
    }
    _createInfoDiv() {
        if (this.canvas && this.props.onAddHTML) {
            const wrapperDiv = document.createElement('div');
            document.body.appendChild(wrapperDiv);
            wrapperDiv.style.position = 'relative';
            const div = document.createElement('div');
            div.style.position = 'absolute';
            div.style.left = '10px';
            div.style.bottom = '10px';
            div.style.width = '300px';
            div.style.background = 'white';
            if (this.canvas instanceof HTMLCanvasElement) {
                wrapperDiv.appendChild(this.canvas);
            }
            wrapperDiv.appendChild(div);
            const html = this.props.onAddHTML(div);
            if (html) {
                div.innerHTML = html;
            }
        }
    }
    _getSizeAndAspect() {
        if (!this.device) {
            return {
                width: 1,
                height: 1,
                aspect: 1
            };
        }
        // https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
        const [width, height] = this.device?.canvasContext?.getPixelSize() || [
            1,
            1
        ];
        // https://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html
        let aspect = 1;
        const canvas = this.device?.canvasContext?.canvas;
        // @ts-expect-error
        if (canvas && canvas.clientHeight) {
            // @ts-expect-error
            aspect = canvas.clientWidth / canvas.clientHeight;
        } else if (width > 0 && height > 0) {
            aspect = width / height;
        }
        return {
            width,
            height,
            aspect
        };
    }
    /** Default viewport setup */ _resizeViewport() {
        // TODO can we use canvas context to code this in a portable way?
        // @ts-expect-error Expose on canvasContext
        if (this.props.autoResizeViewport && this.device.gl) {
            // @ts-expect-error Expose canvasContext
            this.device.gl.viewport(0, 0, // @ts-expect-error Expose canvasContext
            this.device.gl.drawingBufferWidth, // @ts-expect-error Expose canvasContext
            this.device.gl.drawingBufferHeight);
        }
    }
    /**
     * Resize the render buffer of the canvas to match canvas client size
     * Optionally multiplying with devicePixel ratio
     */ _resizeCanvasDrawingBuffer() {
        if (this.props.autoResizeDrawingBuffer) {
            this.device?.canvasContext?.resize({
                useDevicePixels: this.props.useDevicePixels
            });
        }
    }
    _beginFrameTimers() {
        this.frameRate.timeEnd();
        this.frameRate.timeStart();
        // Check if timer for last frame has completed.
        // GPU timer results are never available in the same
        // frame they are captured.
        // if (
        //   this._gpuTimeQuery &&
        //   this._gpuTimeQuery.isResultAvailable() &&
        //   !this._gpuTimeQuery.isTimerDisjoint()
        // ) {
        //   this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());
        // }
        // if (this._gpuTimeQuery) {
        //   // GPU time query start
        //   this._gpuTimeQuery.beginTimeElapsedQuery();
        // }
        this.cpuTime.timeStart();
    }
    _endFrameTimers() {
        this.cpuTime.timeEnd();
    // if (this._gpuTimeQuery) {
    //   // GPU time query end. Results will be available on next frame.
    //   this._gpuTimeQuery.end();
    // }
    }
    // Event handling
    _startEventHandling() {
        if (this.canvas) {
            this.canvas.addEventListener('mousemove', this._onMousemove.bind(this));
            this.canvas.addEventListener('mouseleave', this._onMouseleave.bind(this));
        }
    }
    _onMousemove(event) {
        if (event instanceof MouseEvent) {
            this._getAnimationProps()._mousePosition = [
                event.offsetX,
                event.offsetY
            ];
        }
    }
    _onMouseleave(event) {
        this._getAnimationProps()._mousePosition = null;
    }
} //# sourceMappingURL=animation-loop.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/animation/timeline.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "Timeline": (()=>Timeline)
});
let channelHandles = 1;
let animationHandles = 1;
class Timeline {
    time = 0;
    channels = new Map();
    animations = new Map();
    playing = false;
    lastEngineTime = -1;
    constructor(){}
    addChannel(props) {
        const { delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1 } = props;
        const channelId = channelHandles++;
        const channel = {
            time: 0,
            delay,
            duration,
            rate,
            repeat
        };
        this._setChannelTime(channel, this.time);
        this.channels.set(channelId, channel);
        return channelId;
    }
    removeChannel(channelId) {
        this.channels.delete(channelId);
        for (const [animationHandle, animation] of this.animations){
            if (animation.channel === channelId) {
                this.detachAnimation(animationHandle);
            }
        }
    }
    isFinished(channelId) {
        const channel = this.channels.get(channelId);
        if (channel === undefined) {
            return false;
        }
        return this.time >= channel.delay + channel.duration * channel.repeat;
    }
    getTime(channelId) {
        if (channelId === undefined) {
            return this.time;
        }
        const channel = this.channels.get(channelId);
        if (channel === undefined) {
            return -1;
        }
        return channel.time;
    }
    setTime(time) {
        this.time = Math.max(0, time);
        const channels = this.channels.values();
        for (const channel of channels){
            this._setChannelTime(channel, this.time);
        }
        const animations = this.animations.values();
        for (const animationData of animations){
            const { animation, channel } = animationData;
            animation.setTime(this.getTime(channel));
        }
    }
    play() {
        this.playing = true;
    }
    pause() {
        this.playing = false;
        this.lastEngineTime = -1;
    }
    reset() {
        this.setTime(0);
    }
    attachAnimation(animation, channelHandle) {
        const animationHandle = animationHandles++;
        this.animations.set(animationHandle, {
            animation,
            channel: channelHandle
        });
        animation.setTime(this.getTime(channelHandle));
        return animationHandle;
    }
    detachAnimation(channelId) {
        this.animations.delete(channelId);
    }
    update(engineTime) {
        if (this.playing) {
            if (this.lastEngineTime === -1) {
                this.lastEngineTime = engineTime;
            }
            this.setTime(this.time + (engineTime - this.lastEngineTime));
            this.lastEngineTime = engineTime;
        }
    }
    _setChannelTime(channel, time) {
        const offsetTime = time - channel.delay;
        const totalDuration = channel.duration * channel.repeat;
        // Note(Tarek): Don't loop on final repeat.
        if (offsetTime >= totalDuration) {
            channel.time = channel.duration * channel.rate;
        } else {
            channel.time = Math.max(0, offsetTime) % channel.duration;
            channel.time *= channel.rate;
        }
    }
} //# sourceMappingURL=timeline.js.map
}}),
"[project]/node_modules/@luma.gl/constants/dist/webgl-constants.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* eslint-disable key-spacing, max-len, no-inline-comments, camelcase */ /**
 * Standard WebGL, WebGL2 and extension constants (OpenGL constants)
 * @note (Most) of these constants are also defined on the WebGLRenderingContext interface.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants
 * @privateRemarks Locally called `GLEnum` instead of `GL`, because `babel-plugin-inline-webl-constants`
 *  both depends on and processes this module, but shouldn't replace these declarations.
 */ // eslint-disable-next-line no-shadow
__turbopack_esm__({
    "GL": (()=>GLEnum)
});
var GLEnum;
(function(GLEnum) {
    // Clearing buffers
    // Constants passed to clear() to clear buffer masks.
    /** Passed to clear to clear the current depth buffer. */ GLEnum[GLEnum["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
    /** Passed to clear to clear the current stencil buffer. */ GLEnum[GLEnum["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
    /** Passed to clear to clear the current color buffer. */ GLEnum[GLEnum["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
    // Rendering primitives
    // Constants passed to drawElements() or drawArrays() to specify what kind of primitive to render.
    /** Passed to drawElements or drawArrays to draw single points. */ GLEnum[GLEnum["POINTS"] = 0] = "POINTS";
    /** Passed to drawElements or drawArrays to draw lines. Each vertex connects to the one after it. */ GLEnum[GLEnum["LINES"] = 1] = "LINES";
    /** Passed to drawElements or drawArrays to draw lines. Each set of two vertices is treated as a separate line segment. */ GLEnum[GLEnum["LINE_LOOP"] = 2] = "LINE_LOOP";
    /** Passed to drawElements or drawArrays to draw a connected group of line segments from the first vertex to the last. */ GLEnum[GLEnum["LINE_STRIP"] = 3] = "LINE_STRIP";
    /** Passed to drawElements or drawArrays to draw triangles. Each set of three vertices creates a separate triangle. */ GLEnum[GLEnum["TRIANGLES"] = 4] = "TRIANGLES";
    /** Passed to drawElements or drawArrays to draw a connected group of triangles. */ GLEnum[GLEnum["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    /** Passed to drawElements or drawArrays to draw a connected group of triangles. Each vertex connects to the previous and the first vertex in the fan. */ GLEnum[GLEnum["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    // Blending modes
    // Constants passed to blendFunc() or blendFuncSeparate() to specify the blending mode (for both, RBG and alpha, or separately).
    /** Passed to blendFunc or blendFuncSeparate to turn off a component. */ GLEnum[GLEnum["ZERO"] = 0] = "ZERO";
    /** Passed to blendFunc or blendFuncSeparate to turn on a component. */ GLEnum[GLEnum["ONE"] = 1] = "ONE";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by the source elements color. */ GLEnum[GLEnum["SRC_COLOR"] = 768] = "SRC_COLOR";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the source elements color. */ GLEnum[GLEnum["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by the source's alpha. */ GLEnum[GLEnum["SRC_ALPHA"] = 770] = "SRC_ALPHA";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the source's alpha. */ GLEnum[GLEnum["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by the destination's alpha. */ GLEnum[GLEnum["DST_ALPHA"] = 772] = "DST_ALPHA";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the destination's alpha. */ GLEnum[GLEnum["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by the destination's color. */ GLEnum[GLEnum["DST_COLOR"] = 774] = "DST_COLOR";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the destination's color. */ GLEnum[GLEnum["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by the minimum of source's alpha or one minus the destination's alpha. */ GLEnum[GLEnum["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
    /** Passed to blendFunc or blendFuncSeparate to specify a constant color blend function. */ GLEnum[GLEnum["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
    /** Passed to blendFunc or blendFuncSeparate to specify one minus a constant color blend function. */ GLEnum[GLEnum["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
    /** Passed to blendFunc or blendFuncSeparate to specify a constant alpha blend function. */ GLEnum[GLEnum["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
    /** Passed to blendFunc or blendFuncSeparate to specify one minus a constant alpha blend function. */ GLEnum[GLEnum["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
    // Blending equations
    // Constants passed to blendEquation() or blendEquationSeparate() to control
    // how the blending is calculated (for both, RBG and alpha, or separately).
    /** Passed to blendEquation or blendEquationSeparate to set an addition blend function. */ /** Passed to blendEquation or blendEquationSeparate to specify a subtraction blend function (source - destination). */ /** Passed to blendEquation or blendEquationSeparate to specify a reverse subtraction blend function (destination - source). */ GLEnum[GLEnum["FUNC_ADD"] = 32774] = "FUNC_ADD";
    GLEnum[GLEnum["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
    GLEnum[GLEnum["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
    // Getting GL parameter information
    // Constants passed to getParameter() to specify what information to return.
    /** Passed to getParameter to get the current RGB blend function. */ GLEnum[GLEnum["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
    /** Passed to getParameter to get the current RGB blend function. Same as BLEND_EQUATION */ GLEnum[GLEnum["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
    /** Passed to getParameter to get the current alpha blend function. Same as BLEND_EQUATION */ GLEnum[GLEnum["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
    /** Passed to getParameter to get the current destination RGB blend function. */ GLEnum[GLEnum["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
    /** Passed to getParameter to get the current destination RGB blend function. */ GLEnum[GLEnum["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
    /** Passed to getParameter to get the current destination alpha blend function. */ GLEnum[GLEnum["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
    /** Passed to getParameter to get the current source alpha blend function. */ GLEnum[GLEnum["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
    /** Passed to getParameter to return a the current blend color. */ GLEnum[GLEnum["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
    /** Passed to getParameter to get the array buffer binding. */ GLEnum[GLEnum["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
    /** Passed to getParameter to get the current element array buffer. */ GLEnum[GLEnum["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
    /** Passed to getParameter to get the current lineWidth (set by the lineWidth method). */ GLEnum[GLEnum["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
    /** Passed to getParameter to get the current size of a point drawn with gl.POINTS */ GLEnum[GLEnum["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
    /** Passed to getParameter to get the range of available widths for a line. Returns a length-2 array with the lo value at 0, and hight at 1. */ GLEnum[GLEnum["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
    /** Passed to getParameter to get the current value of cullFace. Should return FRONT, BACK, or FRONT_AND_BACK */ GLEnum[GLEnum["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
    /** Passed to getParameter to determine the current value of frontFace. Should return CW or CCW. */ GLEnum[GLEnum["FRONT_FACE"] = 2886] = "FRONT_FACE";
    /** Passed to getParameter to return a length-2 array of floats giving the current depth range. */ GLEnum[GLEnum["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
    /** Passed to getParameter to determine if the depth write mask is enabled. */ GLEnum[GLEnum["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
    /** Passed to getParameter to determine the current depth clear value. */ GLEnum[GLEnum["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
    /** Passed to getParameter to get the current depth function. Returns NEVER, ALWAYS, LESS, EQUAL, LEQUAL, GREATER, GEQUAL, or NOTEQUAL. */ GLEnum[GLEnum["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
    /** Passed to getParameter to get the value the stencil will be cleared to. */ GLEnum[GLEnum["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
    /** Passed to getParameter to get the current stencil function. Returns NEVER, ALWAYS, LESS, EQUAL, LEQUAL, GREATER, GEQUAL, or NOTEQUAL. */ GLEnum[GLEnum["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
    /** Passed to getParameter to get the current stencil fail function. Should return KEEP, REPLACE, INCR, DECR, INVERT, INCR_WRAP, or DECR_WRAP. */ GLEnum[GLEnum["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
    /** Passed to getParameter to get the current stencil fail function should the depth buffer test fail. Should return KEEP, REPLACE, INCR, DECR, INVERT, INCR_WRAP, or DECR_WRAP. */ GLEnum[GLEnum["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
    /** Passed to getParameter to get the current stencil fail function should the depth buffer test pass. Should return KEEP, REPLACE, INCR, DECR, INVERT, INCR_WRAP, or DECR_WRAP. */ GLEnum[GLEnum["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
    /** Passed to getParameter to get the reference value used for stencil tests. */ GLEnum[GLEnum["STENCIL_REF"] = 2967] = "STENCIL_REF";
    GLEnum[GLEnum["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
    GLEnum[GLEnum["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
    GLEnum[GLEnum["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
    GLEnum[GLEnum["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
    GLEnum[GLEnum["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
    GLEnum[GLEnum["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
    GLEnum[GLEnum["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
    GLEnum[GLEnum["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
    GLEnum[GLEnum["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
    /** An Int32Array with four elements for the current viewport dimensions. */ GLEnum[GLEnum["VIEWPORT"] = 2978] = "VIEWPORT";
    /** An Int32Array with four elements for the current scissor box dimensions. */ GLEnum[GLEnum["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
    GLEnum[GLEnum["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
    GLEnum[GLEnum["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
    GLEnum[GLEnum["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
    GLEnum[GLEnum["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
    GLEnum[GLEnum["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
    GLEnum[GLEnum["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
    GLEnum[GLEnum["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
    GLEnum[GLEnum["RED_BITS"] = 3410] = "RED_BITS";
    GLEnum[GLEnum["GREEN_BITS"] = 3411] = "GREEN_BITS";
    GLEnum[GLEnum["BLUE_BITS"] = 3412] = "BLUE_BITS";
    GLEnum[GLEnum["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
    GLEnum[GLEnum["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
    GLEnum[GLEnum["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
    GLEnum[GLEnum["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
    GLEnum[GLEnum["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
    GLEnum[GLEnum["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
    GLEnum[GLEnum["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
    GLEnum[GLEnum["SAMPLES"] = 32937] = "SAMPLES";
    GLEnum[GLEnum["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
    GLEnum[GLEnum["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
    GLEnum[GLEnum["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
    GLEnum[GLEnum["VENDOR"] = 7936] = "VENDOR";
    GLEnum[GLEnum["RENDERER"] = 7937] = "RENDERER";
    GLEnum[GLEnum["VERSION"] = 7938] = "VERSION";
    GLEnum[GLEnum["IMPLEMENTATION_COLOR_READ_TYPE"] = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE";
    GLEnum[GLEnum["IMPLEMENTATION_COLOR_READ_FORMAT"] = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT";
    GLEnum[GLEnum["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
    // Buffers
    // Constants passed to bufferData(), bufferSubData(), bindBuffer(), or
    // getBufferParameter().
    /** Passed to bufferData as a hint about whether the contents of the buffer are likely to be used often and not change often. */ GLEnum[GLEnum["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
    /** Passed to bufferData as a hint about whether the contents of the buffer are likely to not be used often. */ GLEnum[GLEnum["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
    /** Passed to bufferData as a hint about whether the contents of the buffer are likely to be used often and change often. */ GLEnum[GLEnum["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
    /** Passed to bindBuffer or bufferData to specify the type of buffer being used. */ GLEnum[GLEnum["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    /** Passed to bindBuffer or bufferData to specify the type of buffer being used. */ GLEnum[GLEnum["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    /** Passed to getBufferParameter to get a buffer's size. */ GLEnum[GLEnum["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
    /** Passed to getBufferParameter to get the hint for the buffer passed in when it was created. */ GLEnum[GLEnum["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
    // Vertex attributes
    // Constants passed to getVertexAttrib().
    /** Passed to getVertexAttrib to read back the current vertex attribute. */ GLEnum[GLEnum["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
    // Culling
    // Constants passed to cullFace().
    /** Passed to enable/disable to turn on/off culling. Can also be used with getParameter to find the current culling method. */ GLEnum[GLEnum["CULL_FACE"] = 2884] = "CULL_FACE";
    /** Passed to cullFace to specify that only front faces should be culled. */ GLEnum[GLEnum["FRONT"] = 1028] = "FRONT";
    /** Passed to cullFace to specify that only back faces should be culled. */ GLEnum[GLEnum["BACK"] = 1029] = "BACK";
    /** Passed to cullFace to specify that front and back faces should be culled. */ GLEnum[GLEnum["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
    // Enabling and disabling
    // Constants passed to enable() or disable().
    /** Passed to enable/disable to turn on/off blending. Can also be used with getParameter to find the current blending method. */ GLEnum[GLEnum["BLEND"] = 3042] = "BLEND";
    /** Passed to enable/disable to turn on/off the depth test. Can also be used with getParameter to query the depth test. */ GLEnum[GLEnum["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
    /** Passed to enable/disable to turn on/off dithering. Can also be used with getParameter to find the current dithering method. */ GLEnum[GLEnum["DITHER"] = 3024] = "DITHER";
    /** Passed to enable/disable to turn on/off the polygon offset. Useful for rendering hidden-line images, decals, and or solids with highlighted edges. Can also be used with getParameter to query the scissor test. */ GLEnum[GLEnum["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
    /** Passed to enable/disable to turn on/off the alpha to coverage. Used in multi-sampling alpha channels. */ GLEnum[GLEnum["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
    /** Passed to enable/disable to turn on/off the sample coverage. Used in multi-sampling. */ GLEnum[GLEnum["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
    /** Passed to enable/disable to turn on/off the scissor test. Can also be used with getParameter to query the scissor test. */ GLEnum[GLEnum["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
    /** Passed to enable/disable to turn on/off the stencil test. Can also be used with getParameter to query the stencil test. */ GLEnum[GLEnum["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
    // Errors
    // Constants returned from getError().
    /** Returned from getError(). */ GLEnum[GLEnum["NO_ERROR"] = 0] = "NO_ERROR";
    /** Returned from getError(). */ GLEnum[GLEnum["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
    /** Returned from getError(). */ GLEnum[GLEnum["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
    /** Returned from getError(). */ GLEnum[GLEnum["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
    /** Returned from getError(). */ GLEnum[GLEnum["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
    /** Returned from getError(). */ GLEnum[GLEnum["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
    // Front face directions
    // Constants passed to frontFace().
    /** Passed to frontFace to specify the front face of a polygon is drawn in the clockwise direction */ GLEnum[GLEnum["CW"] = 2304] = "CW";
    /** Passed to frontFace to specify the front face of a polygon is drawn in the counter clockwise direction */ GLEnum[GLEnum["CCW"] = 2305] = "CCW";
    // Hints
    // Constants passed to hint()
    /** There is no preference for this behavior. */ GLEnum[GLEnum["DONT_CARE"] = 4352] = "DONT_CARE";
    /** The most efficient behavior should be used. */ GLEnum[GLEnum["FASTEST"] = 4353] = "FASTEST";
    /** The most correct or the highest quality option should be used. */ GLEnum[GLEnum["NICEST"] = 4354] = "NICEST";
    /** Hint for the quality of filtering when generating mipmap images with WebGLRenderingContext.generateMipmap(). */ GLEnum[GLEnum["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
    // Data types
    GLEnum[GLEnum["BYTE"] = 5120] = "BYTE";
    GLEnum[GLEnum["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    GLEnum[GLEnum["SHORT"] = 5122] = "SHORT";
    GLEnum[GLEnum["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    GLEnum[GLEnum["INT"] = 5124] = "INT";
    GLEnum[GLEnum["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    GLEnum[GLEnum["FLOAT"] = 5126] = "FLOAT";
    GLEnum[GLEnum["DOUBLE"] = 5130] = "DOUBLE";
    // Pixel formats
    GLEnum[GLEnum["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    GLEnum[GLEnum["ALPHA"] = 6406] = "ALPHA";
    GLEnum[GLEnum["RGB"] = 6407] = "RGB";
    GLEnum[GLEnum["RGBA"] = 6408] = "RGBA";
    GLEnum[GLEnum["LUMINANCE"] = 6409] = "LUMINANCE";
    GLEnum[GLEnum["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    // Pixel types
    // UNSIGNED_BYTE = 0x1401,
    GLEnum[GLEnum["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    GLEnum[GLEnum["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    GLEnum[GLEnum["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    // Shaders
    // Constants passed to createShader() or getShaderParameter()
    /** Passed to createShader to define a fragment shader. */ GLEnum[GLEnum["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
    /** Passed to createShader to define a vertex shader */ GLEnum[GLEnum["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
    /** Passed to getShaderParameter to get the status of the compilation. Returns false if the shader was not compiled. You can then query getShaderInfoLog to find the exact error */ GLEnum[GLEnum["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
    /** Passed to getShaderParameter to determine if a shader was deleted via deleteShader. Returns true if it was, false otherwise. */ GLEnum[GLEnum["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
    /** Passed to getProgramParameter after calling linkProgram to determine if a program was linked correctly. Returns false if there were errors. Use getProgramInfoLog to find the exact error. */ GLEnum[GLEnum["LINK_STATUS"] = 35714] = "LINK_STATUS";
    /** Passed to getProgramParameter after calling validateProgram to determine if it is valid. Returns false if errors were found. */ GLEnum[GLEnum["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
    /** Passed to getProgramParameter after calling attachShader to determine if the shader was attached correctly. Returns false if errors occurred. */ GLEnum[GLEnum["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
    /** Passed to getProgramParameter to get the number of attributes active in a program. */ GLEnum[GLEnum["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
    /** Passed to getProgramParameter to get the number of uniforms active in a program. */ GLEnum[GLEnum["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
    /** The maximum number of entries possible in the vertex attribute list. */ GLEnum[GLEnum["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
    GLEnum[GLEnum["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
    GLEnum[GLEnum["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
    GLEnum[GLEnum["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
    GLEnum[GLEnum["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
    /** Implementation dependent number of maximum texture units. At least 8. */ GLEnum[GLEnum["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
    GLEnum[GLEnum["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
    GLEnum[GLEnum["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
    GLEnum[GLEnum["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
    GLEnum[GLEnum["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
    // Depth or stencil tests
    // Constants passed to depthFunc() or stencilFunc().
    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass, i.e., nothing will be drawn. */ GLEnum[GLEnum["NEVER"] = 512] = "NEVER";
    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value. */ GLEnum[GLEnum["LESS"] = 513] = "LESS";
    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value. */ GLEnum[GLEnum["EQUAL"] = 514] = "EQUAL";
    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value. */ GLEnum[GLEnum["LEQUAL"] = 515] = "LEQUAL";
    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value. */ GLEnum[GLEnum["GREATER"] = 516] = "GREATER";
    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value. */ GLEnum[GLEnum["NOTEQUAL"] = 517] = "NOTEQUAL";
    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value. */ GLEnum[GLEnum["GEQUAL"] = 518] = "GEQUAL";
    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass, i.e., pixels will be drawn in the order they are drawn. */ GLEnum[GLEnum["ALWAYS"] = 519] = "ALWAYS";
    // Stencil actions
    // Constants passed to stencilOp().
    GLEnum[GLEnum["KEEP"] = 7680] = "KEEP";
    GLEnum[GLEnum["REPLACE"] = 7681] = "REPLACE";
    GLEnum[GLEnum["INCR"] = 7682] = "INCR";
    GLEnum[GLEnum["DECR"] = 7683] = "DECR";
    GLEnum[GLEnum["INVERT"] = 5386] = "INVERT";
    GLEnum[GLEnum["INCR_WRAP"] = 34055] = "INCR_WRAP";
    GLEnum[GLEnum["DECR_WRAP"] = 34056] = "DECR_WRAP";
    // Textures
    // Constants passed to texParameteri(),
    // texParameterf(), bindTexture(), texImage2D(), and others.
    GLEnum[GLEnum["NEAREST"] = 9728] = "NEAREST";
    GLEnum[GLEnum["LINEAR"] = 9729] = "LINEAR";
    GLEnum[GLEnum["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    GLEnum[GLEnum["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    GLEnum[GLEnum["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    GLEnum[GLEnum["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
    /** The texture magnification function is used when the pixel being textured maps to an area less than or equal to one texture element. It sets the texture magnification function to either GL_NEAREST or GL_LINEAR (see below). GL_NEAREST is generally faster than GL_LINEAR, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. Default: GL_LINEAR.  */ GLEnum[GLEnum["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
    /** The texture minifying function is used whenever the pixel being textured maps to an area greater than one texture element. There are six defined minifying functions. Two of them use the nearest one or nearest four texture elements to compute the texture value. The other four use mipmaps. Default: GL_NEAREST_MIPMAP_LINEAR */ GLEnum[GLEnum["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
    /** Sets the wrap parameter for texture coordinate  to either GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT. G */ GLEnum[GLEnum["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
    /** Sets the wrap parameter for texture coordinate  to either GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT. G */ GLEnum[GLEnum["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
    GLEnum[GLEnum["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    GLEnum[GLEnum["TEXTURE"] = 5890] = "TEXTURE";
    GLEnum[GLEnum["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    GLEnum[GLEnum["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
    GLEnum[GLEnum["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    GLEnum[GLEnum["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    GLEnum[GLEnum["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    GLEnum[GLEnum["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    GLEnum[GLEnum["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    GLEnum[GLEnum["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    GLEnum[GLEnum["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
    // TEXTURE0 - 31 0x84C0 - 0x84DF A texture unit.
    GLEnum[GLEnum["TEXTURE0"] = 33984] = "TEXTURE0";
    GLEnum[GLEnum["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
    GLEnum[GLEnum["REPEAT"] = 10497] = "REPEAT";
    GLEnum[GLEnum["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    GLEnum[GLEnum["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    // Emulation
    GLEnum[GLEnum["TEXTURE_WIDTH"] = 4096] = "TEXTURE_WIDTH";
    GLEnum[GLEnum["TEXTURE_HEIGHT"] = 4097] = "TEXTURE_HEIGHT";
    // Uniform types
    GLEnum[GLEnum["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
    GLEnum[GLEnum["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
    GLEnum[GLEnum["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
    GLEnum[GLEnum["INT_VEC2"] = 35667] = "INT_VEC2";
    GLEnum[GLEnum["INT_VEC3"] = 35668] = "INT_VEC3";
    GLEnum[GLEnum["INT_VEC4"] = 35669] = "INT_VEC4";
    GLEnum[GLEnum["BOOL"] = 35670] = "BOOL";
    GLEnum[GLEnum["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
    GLEnum[GLEnum["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
    GLEnum[GLEnum["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
    GLEnum[GLEnum["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
    GLEnum[GLEnum["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
    GLEnum[GLEnum["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
    GLEnum[GLEnum["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
    GLEnum[GLEnum["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
    // Shader precision-specified types
    GLEnum[GLEnum["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
    GLEnum[GLEnum["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
    GLEnum[GLEnum["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
    GLEnum[GLEnum["LOW_INT"] = 36339] = "LOW_INT";
    GLEnum[GLEnum["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
    GLEnum[GLEnum["HIGH_INT"] = 36341] = "HIGH_INT";
    // Framebuffers and renderbuffers
    GLEnum[GLEnum["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
    GLEnum[GLEnum["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
    GLEnum[GLEnum["RGBA4"] = 32854] = "RGBA4";
    GLEnum[GLEnum["RGB5_A1"] = 32855] = "RGB5_A1";
    GLEnum[GLEnum["RGB565"] = 36194] = "RGB565";
    GLEnum[GLEnum["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
    GLEnum[GLEnum["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
    GLEnum[GLEnum["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
    GLEnum[GLEnum["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    GLEnum[GLEnum["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
    GLEnum[GLEnum["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
    GLEnum[GLEnum["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
    GLEnum[GLEnum["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
    GLEnum[GLEnum["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
    GLEnum[GLEnum["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
    GLEnum[GLEnum["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
    GLEnum[GLEnum["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
    GLEnum[GLEnum["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
    GLEnum[GLEnum["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
    GLEnum[GLEnum["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
    GLEnum[GLEnum["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
    GLEnum[GLEnum["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
    GLEnum[GLEnum["NONE"] = 0] = "NONE";
    GLEnum[GLEnum["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
    GLEnum[GLEnum["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    GLEnum[GLEnum["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    GLEnum[GLEnum["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    GLEnum[GLEnum["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
    GLEnum[GLEnum["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
    GLEnum[GLEnum["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
    GLEnum[GLEnum["READ_FRAMEBUFFER"] = 36008] = "READ_FRAMEBUFFER";
    GLEnum[GLEnum["DRAW_FRAMEBUFFER"] = 36009] = "DRAW_FRAMEBUFFER";
    GLEnum[GLEnum["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
    GLEnum[GLEnum["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
    // Pixel storage modes
    // Constants passed to pixelStorei().
    GLEnum[GLEnum["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
    GLEnum[GLEnum["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
    GLEnum[GLEnum["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
    // Additional constants defined WebGL 2
    // These constants are defined on the WebGL2RenderingContext interface.
    // All WebGL 1 constants are also available in a WebGL 2 context.
    // Getting GL parameter information
    // Constants passed to getParameter()
    // to specify what information to return.
    GLEnum[GLEnum["READ_BUFFER"] = 3074] = "READ_BUFFER";
    GLEnum[GLEnum["UNPACK_ROW_LENGTH"] = 3314] = "UNPACK_ROW_LENGTH";
    GLEnum[GLEnum["UNPACK_SKIP_ROWS"] = 3315] = "UNPACK_SKIP_ROWS";
    GLEnum[GLEnum["UNPACK_SKIP_PIXELS"] = 3316] = "UNPACK_SKIP_PIXELS";
    GLEnum[GLEnum["PACK_ROW_LENGTH"] = 3330] = "PACK_ROW_LENGTH";
    GLEnum[GLEnum["PACK_SKIP_ROWS"] = 3331] = "PACK_SKIP_ROWS";
    GLEnum[GLEnum["PACK_SKIP_PIXELS"] = 3332] = "PACK_SKIP_PIXELS";
    GLEnum[GLEnum["TEXTURE_BINDING_3D"] = 32874] = "TEXTURE_BINDING_3D";
    GLEnum[GLEnum["UNPACK_SKIP_IMAGES"] = 32877] = "UNPACK_SKIP_IMAGES";
    GLEnum[GLEnum["UNPACK_IMAGE_HEIGHT"] = 32878] = "UNPACK_IMAGE_HEIGHT";
    GLEnum[GLEnum["MAX_3D_TEXTURE_SIZE"] = 32883] = "MAX_3D_TEXTURE_SIZE";
    GLEnum[GLEnum["MAX_ELEMENTS_VERTICES"] = 33000] = "MAX_ELEMENTS_VERTICES";
    GLEnum[GLEnum["MAX_ELEMENTS_INDICES"] = 33001] = "MAX_ELEMENTS_INDICES";
    GLEnum[GLEnum["MAX_TEXTURE_LOD_BIAS"] = 34045] = "MAX_TEXTURE_LOD_BIAS";
    GLEnum[GLEnum["MAX_FRAGMENT_UNIFORM_COMPONENTS"] = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS";
    GLEnum[GLEnum["MAX_VERTEX_UNIFORM_COMPONENTS"] = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS";
    GLEnum[GLEnum["MAX_ARRAY_TEXTURE_LAYERS"] = 35071] = "MAX_ARRAY_TEXTURE_LAYERS";
    GLEnum[GLEnum["MIN_PROGRAM_TEXEL_OFFSET"] = 35076] = "MIN_PROGRAM_TEXEL_OFFSET";
    GLEnum[GLEnum["MAX_PROGRAM_TEXEL_OFFSET"] = 35077] = "MAX_PROGRAM_TEXEL_OFFSET";
    GLEnum[GLEnum["MAX_VARYING_COMPONENTS"] = 35659] = "MAX_VARYING_COMPONENTS";
    GLEnum[GLEnum["FRAGMENT_SHADER_DERIVATIVE_HINT"] = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT";
    GLEnum[GLEnum["RASTERIZER_DISCARD"] = 35977] = "RASTERIZER_DISCARD";
    GLEnum[GLEnum["VERTEX_ARRAY_BINDING"] = 34229] = "VERTEX_ARRAY_BINDING";
    GLEnum[GLEnum["MAX_VERTEX_OUTPUT_COMPONENTS"] = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS";
    GLEnum[GLEnum["MAX_FRAGMENT_INPUT_COMPONENTS"] = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS";
    GLEnum[GLEnum["MAX_SERVER_WAIT_TIMEOUT"] = 37137] = "MAX_SERVER_WAIT_TIMEOUT";
    GLEnum[GLEnum["MAX_ELEMENT_INDEX"] = 36203] = "MAX_ELEMENT_INDEX";
    // Textures
    // Constants passed to texParameteri(),
    // texParameterf(), bindTexture(), texImage2D(), and others.
    GLEnum[GLEnum["RED"] = 6403] = "RED";
    GLEnum[GLEnum["RGB8"] = 32849] = "RGB8";
    GLEnum[GLEnum["RGBA8"] = 32856] = "RGBA8";
    GLEnum[GLEnum["RGB10_A2"] = 32857] = "RGB10_A2";
    GLEnum[GLEnum["TEXTURE_3D"] = 32879] = "TEXTURE_3D";
    /** Sets the wrap parameter for texture coordinate  to either GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT. G */ GLEnum[GLEnum["TEXTURE_WRAP_R"] = 32882] = "TEXTURE_WRAP_R";
    GLEnum[GLEnum["TEXTURE_MIN_LOD"] = 33082] = "TEXTURE_MIN_LOD";
    GLEnum[GLEnum["TEXTURE_MAX_LOD"] = 33083] = "TEXTURE_MAX_LOD";
    GLEnum[GLEnum["TEXTURE_BASE_LEVEL"] = 33084] = "TEXTURE_BASE_LEVEL";
    GLEnum[GLEnum["TEXTURE_MAX_LEVEL"] = 33085] = "TEXTURE_MAX_LEVEL";
    GLEnum[GLEnum["TEXTURE_COMPARE_MODE"] = 34892] = "TEXTURE_COMPARE_MODE";
    GLEnum[GLEnum["TEXTURE_COMPARE_FUNC"] = 34893] = "TEXTURE_COMPARE_FUNC";
    GLEnum[GLEnum["SRGB"] = 35904] = "SRGB";
    GLEnum[GLEnum["SRGB8"] = 35905] = "SRGB8";
    GLEnum[GLEnum["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
    GLEnum[GLEnum["COMPARE_REF_TO_TEXTURE"] = 34894] = "COMPARE_REF_TO_TEXTURE";
    GLEnum[GLEnum["RGBA32F"] = 34836] = "RGBA32F";
    GLEnum[GLEnum["RGB32F"] = 34837] = "RGB32F";
    GLEnum[GLEnum["RGBA16F"] = 34842] = "RGBA16F";
    GLEnum[GLEnum["RGB16F"] = 34843] = "RGB16F";
    GLEnum[GLEnum["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    GLEnum[GLEnum["TEXTURE_BINDING_2D_ARRAY"] = 35869] = "TEXTURE_BINDING_2D_ARRAY";
    GLEnum[GLEnum["R11F_G11F_B10F"] = 35898] = "R11F_G11F_B10F";
    GLEnum[GLEnum["RGB9_E5"] = 35901] = "RGB9_E5";
    GLEnum[GLEnum["RGBA32UI"] = 36208] = "RGBA32UI";
    GLEnum[GLEnum["RGB32UI"] = 36209] = "RGB32UI";
    GLEnum[GLEnum["RGBA16UI"] = 36214] = "RGBA16UI";
    GLEnum[GLEnum["RGB16UI"] = 36215] = "RGB16UI";
    GLEnum[GLEnum["RGBA8UI"] = 36220] = "RGBA8UI";
    GLEnum[GLEnum["RGB8UI"] = 36221] = "RGB8UI";
    GLEnum[GLEnum["RGBA32I"] = 36226] = "RGBA32I";
    GLEnum[GLEnum["RGB32I"] = 36227] = "RGB32I";
    GLEnum[GLEnum["RGBA16I"] = 36232] = "RGBA16I";
    GLEnum[GLEnum["RGB16I"] = 36233] = "RGB16I";
    GLEnum[GLEnum["RGBA8I"] = 36238] = "RGBA8I";
    GLEnum[GLEnum["RGB8I"] = 36239] = "RGB8I";
    GLEnum[GLEnum["RED_INTEGER"] = 36244] = "RED_INTEGER";
    GLEnum[GLEnum["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    GLEnum[GLEnum["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    GLEnum[GLEnum["R8"] = 33321] = "R8";
    GLEnum[GLEnum["RG8"] = 33323] = "RG8";
    GLEnum[GLEnum["R16F"] = 33325] = "R16F";
    GLEnum[GLEnum["R32F"] = 33326] = "R32F";
    GLEnum[GLEnum["RG16F"] = 33327] = "RG16F";
    GLEnum[GLEnum["RG32F"] = 33328] = "RG32F";
    GLEnum[GLEnum["R8I"] = 33329] = "R8I";
    GLEnum[GLEnum["R8UI"] = 33330] = "R8UI";
    GLEnum[GLEnum["R16I"] = 33331] = "R16I";
    GLEnum[GLEnum["R16UI"] = 33332] = "R16UI";
    GLEnum[GLEnum["R32I"] = 33333] = "R32I";
    GLEnum[GLEnum["R32UI"] = 33334] = "R32UI";
    GLEnum[GLEnum["RG8I"] = 33335] = "RG8I";
    GLEnum[GLEnum["RG8UI"] = 33336] = "RG8UI";
    GLEnum[GLEnum["RG16I"] = 33337] = "RG16I";
    GLEnum[GLEnum["RG16UI"] = 33338] = "RG16UI";
    GLEnum[GLEnum["RG32I"] = 33339] = "RG32I";
    GLEnum[GLEnum["RG32UI"] = 33340] = "RG32UI";
    GLEnum[GLEnum["R8_SNORM"] = 36756] = "R8_SNORM";
    GLEnum[GLEnum["RG8_SNORM"] = 36757] = "RG8_SNORM";
    GLEnum[GLEnum["RGB8_SNORM"] = 36758] = "RGB8_SNORM";
    GLEnum[GLEnum["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
    GLEnum[GLEnum["RGB10_A2UI"] = 36975] = "RGB10_A2UI";
    /* covered by extension
    COMPRESSED_R11_EAC  = 0x9270,
    COMPRESSED_SIGNED_R11_EAC = 0x9271,
    COMPRESSED_RG11_EAC = 0x9272,
    COMPRESSED_SIGNED_RG11_EAC  = 0x9273,
    COMPRESSED_RGB8_ETC2  = 0x9274,
    COMPRESSED_SRGB8_ETC2 = 0x9275,
    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2  = 0x9276,
    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC  = 0x9277,
    COMPRESSED_RGBA8_ETC2_EAC = 0x9278,
    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC  = 0x9279,
    */ GLEnum[GLEnum["TEXTURE_IMMUTABLE_FORMAT"] = 37167] = "TEXTURE_IMMUTABLE_FORMAT";
    GLEnum[GLEnum["TEXTURE_IMMUTABLE_LEVELS"] = 33503] = "TEXTURE_IMMUTABLE_LEVELS";
    // Pixel types
    GLEnum[GLEnum["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    GLEnum[GLEnum["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    GLEnum[GLEnum["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    GLEnum[GLEnum["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    GLEnum[GLEnum["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    GLEnum[GLEnum["HALF_FLOAT"] = 5131] = "HALF_FLOAT";
    GLEnum[GLEnum["RG"] = 33319] = "RG";
    GLEnum[GLEnum["RG_INTEGER"] = 33320] = "RG_INTEGER";
    GLEnum[GLEnum["INT_2_10_10_10_REV"] = 36255] = "INT_2_10_10_10_REV";
    // Queries
    GLEnum[GLEnum["CURRENT_QUERY"] = 34917] = "CURRENT_QUERY";
    /** Returns a GLuint containing the query result. */ GLEnum[GLEnum["QUERY_RESULT"] = 34918] = "QUERY_RESULT";
    /** Whether query result is available. */ GLEnum[GLEnum["QUERY_RESULT_AVAILABLE"] = 34919] = "QUERY_RESULT_AVAILABLE";
    /** Occlusion query (if drawing passed depth test)  */ GLEnum[GLEnum["ANY_SAMPLES_PASSED"] = 35887] = "ANY_SAMPLES_PASSED";
    /** Occlusion query less accurate/faster version */ GLEnum[GLEnum["ANY_SAMPLES_PASSED_CONSERVATIVE"] = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE";
    // Draw buffers
    GLEnum[GLEnum["MAX_DRAW_BUFFERS"] = 34852] = "MAX_DRAW_BUFFERS";
    GLEnum[GLEnum["DRAW_BUFFER0"] = 34853] = "DRAW_BUFFER0";
    GLEnum[GLEnum["DRAW_BUFFER1"] = 34854] = "DRAW_BUFFER1";
    GLEnum[GLEnum["DRAW_BUFFER2"] = 34855] = "DRAW_BUFFER2";
    GLEnum[GLEnum["DRAW_BUFFER3"] = 34856] = "DRAW_BUFFER3";
    GLEnum[GLEnum["DRAW_BUFFER4"] = 34857] = "DRAW_BUFFER4";
    GLEnum[GLEnum["DRAW_BUFFER5"] = 34858] = "DRAW_BUFFER5";
    GLEnum[GLEnum["DRAW_BUFFER6"] = 34859] = "DRAW_BUFFER6";
    GLEnum[GLEnum["DRAW_BUFFER7"] = 34860] = "DRAW_BUFFER7";
    GLEnum[GLEnum["DRAW_BUFFER8"] = 34861] = "DRAW_BUFFER8";
    GLEnum[GLEnum["DRAW_BUFFER9"] = 34862] = "DRAW_BUFFER9";
    GLEnum[GLEnum["DRAW_BUFFER10"] = 34863] = "DRAW_BUFFER10";
    GLEnum[GLEnum["DRAW_BUFFER11"] = 34864] = "DRAW_BUFFER11";
    GLEnum[GLEnum["DRAW_BUFFER12"] = 34865] = "DRAW_BUFFER12";
    GLEnum[GLEnum["DRAW_BUFFER13"] = 34866] = "DRAW_BUFFER13";
    GLEnum[GLEnum["DRAW_BUFFER14"] = 34867] = "DRAW_BUFFER14";
    GLEnum[GLEnum["DRAW_BUFFER15"] = 34868] = "DRAW_BUFFER15";
    GLEnum[GLEnum["MAX_COLOR_ATTACHMENTS"] = 36063] = "MAX_COLOR_ATTACHMENTS";
    GLEnum[GLEnum["COLOR_ATTACHMENT1"] = 36065] = "COLOR_ATTACHMENT1";
    GLEnum[GLEnum["COLOR_ATTACHMENT2"] = 36066] = "COLOR_ATTACHMENT2";
    GLEnum[GLEnum["COLOR_ATTACHMENT3"] = 36067] = "COLOR_ATTACHMENT3";
    GLEnum[GLEnum["COLOR_ATTACHMENT4"] = 36068] = "COLOR_ATTACHMENT4";
    GLEnum[GLEnum["COLOR_ATTACHMENT5"] = 36069] = "COLOR_ATTACHMENT5";
    GLEnum[GLEnum["COLOR_ATTACHMENT6"] = 36070] = "COLOR_ATTACHMENT6";
    GLEnum[GLEnum["COLOR_ATTACHMENT7"] = 36071] = "COLOR_ATTACHMENT7";
    GLEnum[GLEnum["COLOR_ATTACHMENT8"] = 36072] = "COLOR_ATTACHMENT8";
    GLEnum[GLEnum["COLOR_ATTACHMENT9"] = 36073] = "COLOR_ATTACHMENT9";
    GLEnum[GLEnum["COLOR_ATTACHMENT10"] = 36074] = "COLOR_ATTACHMENT10";
    GLEnum[GLEnum["COLOR_ATTACHMENT11"] = 36075] = "COLOR_ATTACHMENT11";
    GLEnum[GLEnum["COLOR_ATTACHMENT12"] = 36076] = "COLOR_ATTACHMENT12";
    GLEnum[GLEnum["COLOR_ATTACHMENT13"] = 36077] = "COLOR_ATTACHMENT13";
    GLEnum[GLEnum["COLOR_ATTACHMENT14"] = 36078] = "COLOR_ATTACHMENT14";
    GLEnum[GLEnum["COLOR_ATTACHMENT15"] = 36079] = "COLOR_ATTACHMENT15";
    // Samplers
    GLEnum[GLEnum["SAMPLER_3D"] = 35679] = "SAMPLER_3D";
    GLEnum[GLEnum["SAMPLER_2D_SHADOW"] = 35682] = "SAMPLER_2D_SHADOW";
    GLEnum[GLEnum["SAMPLER_2D_ARRAY"] = 36289] = "SAMPLER_2D_ARRAY";
    GLEnum[GLEnum["SAMPLER_2D_ARRAY_SHADOW"] = 36292] = "SAMPLER_2D_ARRAY_SHADOW";
    GLEnum[GLEnum["SAMPLER_CUBE_SHADOW"] = 36293] = "SAMPLER_CUBE_SHADOW";
    GLEnum[GLEnum["INT_SAMPLER_2D"] = 36298] = "INT_SAMPLER_2D";
    GLEnum[GLEnum["INT_SAMPLER_3D"] = 36299] = "INT_SAMPLER_3D";
    GLEnum[GLEnum["INT_SAMPLER_CUBE"] = 36300] = "INT_SAMPLER_CUBE";
    GLEnum[GLEnum["INT_SAMPLER_2D_ARRAY"] = 36303] = "INT_SAMPLER_2D_ARRAY";
    GLEnum[GLEnum["UNSIGNED_INT_SAMPLER_2D"] = 36306] = "UNSIGNED_INT_SAMPLER_2D";
    GLEnum[GLEnum["UNSIGNED_INT_SAMPLER_3D"] = 36307] = "UNSIGNED_INT_SAMPLER_3D";
    GLEnum[GLEnum["UNSIGNED_INT_SAMPLER_CUBE"] = 36308] = "UNSIGNED_INT_SAMPLER_CUBE";
    GLEnum[GLEnum["UNSIGNED_INT_SAMPLER_2D_ARRAY"] = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY";
    GLEnum[GLEnum["MAX_SAMPLES"] = 36183] = "MAX_SAMPLES";
    GLEnum[GLEnum["SAMPLER_BINDING"] = 35097] = "SAMPLER_BINDING";
    // Buffers
    GLEnum[GLEnum["PIXEL_PACK_BUFFER"] = 35051] = "PIXEL_PACK_BUFFER";
    GLEnum[GLEnum["PIXEL_UNPACK_BUFFER"] = 35052] = "PIXEL_UNPACK_BUFFER";
    GLEnum[GLEnum["PIXEL_PACK_BUFFER_BINDING"] = 35053] = "PIXEL_PACK_BUFFER_BINDING";
    GLEnum[GLEnum["PIXEL_UNPACK_BUFFER_BINDING"] = 35055] = "PIXEL_UNPACK_BUFFER_BINDING";
    GLEnum[GLEnum["COPY_READ_BUFFER"] = 36662] = "COPY_READ_BUFFER";
    GLEnum[GLEnum["COPY_WRITE_BUFFER"] = 36663] = "COPY_WRITE_BUFFER";
    GLEnum[GLEnum["COPY_READ_BUFFER_BINDING"] = 36662] = "COPY_READ_BUFFER_BINDING";
    GLEnum[GLEnum["COPY_WRITE_BUFFER_BINDING"] = 36663] = "COPY_WRITE_BUFFER_BINDING";
    // Data types
    GLEnum[GLEnum["FLOAT_MAT2x3"] = 35685] = "FLOAT_MAT2x3";
    GLEnum[GLEnum["FLOAT_MAT2x4"] = 35686] = "FLOAT_MAT2x4";
    GLEnum[GLEnum["FLOAT_MAT3x2"] = 35687] = "FLOAT_MAT3x2";
    GLEnum[GLEnum["FLOAT_MAT3x4"] = 35688] = "FLOAT_MAT3x4";
    GLEnum[GLEnum["FLOAT_MAT4x2"] = 35689] = "FLOAT_MAT4x2";
    GLEnum[GLEnum["FLOAT_MAT4x3"] = 35690] = "FLOAT_MAT4x3";
    GLEnum[GLEnum["UNSIGNED_INT_VEC2"] = 36294] = "UNSIGNED_INT_VEC2";
    GLEnum[GLEnum["UNSIGNED_INT_VEC3"] = 36295] = "UNSIGNED_INT_VEC3";
    GLEnum[GLEnum["UNSIGNED_INT_VEC4"] = 36296] = "UNSIGNED_INT_VEC4";
    GLEnum[GLEnum["UNSIGNED_NORMALIZED"] = 35863] = "UNSIGNED_NORMALIZED";
    GLEnum[GLEnum["SIGNED_NORMALIZED"] = 36764] = "SIGNED_NORMALIZED";
    // Vertex attributes
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_INTEGER"] = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER";
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_DIVISOR"] = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR";
    // Transform feedback
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_BUFFER_MODE"] = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE";
    GLEnum[GLEnum["MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"] = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_VARYINGS"] = 35971] = "TRANSFORM_FEEDBACK_VARYINGS";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_BUFFER_START"] = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_BUFFER_SIZE"] = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"] = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
    GLEnum[GLEnum["MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"] = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
    GLEnum[GLEnum["MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"] = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
    GLEnum[GLEnum["INTERLEAVED_ATTRIBS"] = 35980] = "INTERLEAVED_ATTRIBS";
    GLEnum[GLEnum["SEPARATE_ATTRIBS"] = 35981] = "SEPARATE_ATTRIBS";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_BUFFER"] = 35982] = "TRANSFORM_FEEDBACK_BUFFER";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_BUFFER_BINDING"] = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK"] = 36386] = "TRANSFORM_FEEDBACK";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_PAUSED"] = 36387] = "TRANSFORM_FEEDBACK_PAUSED";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_ACTIVE"] = 36388] = "TRANSFORM_FEEDBACK_ACTIVE";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_BINDING"] = 36389] = "TRANSFORM_FEEDBACK_BINDING";
    // Framebuffers and renderbuffers
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"] = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_RED_SIZE"] = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"] = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"] = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"] = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"] = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"] = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE";
    GLEnum[GLEnum["FRAMEBUFFER_DEFAULT"] = 33304] = "FRAMEBUFFER_DEFAULT";
    // DEPTH_STENCIL_ATTACHMENT  = 0x821A,
    // DEPTH_STENCIL = 0x84F9,
    GLEnum[GLEnum["DEPTH24_STENCIL8"] = 35056] = "DEPTH24_STENCIL8";
    GLEnum[GLEnum["DRAW_FRAMEBUFFER_BINDING"] = 36006] = "DRAW_FRAMEBUFFER_BINDING";
    GLEnum[GLEnum["READ_FRAMEBUFFER_BINDING"] = 36010] = "READ_FRAMEBUFFER_BINDING";
    GLEnum[GLEnum["RENDERBUFFER_SAMPLES"] = 36011] = "RENDERBUFFER_SAMPLES";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"] = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER";
    GLEnum[GLEnum["FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"] = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
    // Uniforms
    GLEnum[GLEnum["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
    GLEnum[GLEnum["UNIFORM_BUFFER_BINDING"] = 35368] = "UNIFORM_BUFFER_BINDING";
    GLEnum[GLEnum["UNIFORM_BUFFER_START"] = 35369] = "UNIFORM_BUFFER_START";
    GLEnum[GLEnum["UNIFORM_BUFFER_SIZE"] = 35370] = "UNIFORM_BUFFER_SIZE";
    GLEnum[GLEnum["MAX_VERTEX_UNIFORM_BLOCKS"] = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS";
    GLEnum[GLEnum["MAX_FRAGMENT_UNIFORM_BLOCKS"] = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS";
    GLEnum[GLEnum["MAX_COMBINED_UNIFORM_BLOCKS"] = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS";
    GLEnum[GLEnum["MAX_UNIFORM_BUFFER_BINDINGS"] = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS";
    GLEnum[GLEnum["MAX_UNIFORM_BLOCK_SIZE"] = 35376] = "MAX_UNIFORM_BLOCK_SIZE";
    GLEnum[GLEnum["MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"] = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
    GLEnum[GLEnum["MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"] = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
    GLEnum[GLEnum["UNIFORM_BUFFER_OFFSET_ALIGNMENT"] = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT";
    GLEnum[GLEnum["ACTIVE_UNIFORM_BLOCKS"] = 35382] = "ACTIVE_UNIFORM_BLOCKS";
    GLEnum[GLEnum["UNIFORM_TYPE"] = 35383] = "UNIFORM_TYPE";
    GLEnum[GLEnum["UNIFORM_SIZE"] = 35384] = "UNIFORM_SIZE";
    GLEnum[GLEnum["UNIFORM_BLOCK_INDEX"] = 35386] = "UNIFORM_BLOCK_INDEX";
    GLEnum[GLEnum["UNIFORM_OFFSET"] = 35387] = "UNIFORM_OFFSET";
    GLEnum[GLEnum["UNIFORM_ARRAY_STRIDE"] = 35388] = "UNIFORM_ARRAY_STRIDE";
    GLEnum[GLEnum["UNIFORM_MATRIX_STRIDE"] = 35389] = "UNIFORM_MATRIX_STRIDE";
    GLEnum[GLEnum["UNIFORM_IS_ROW_MAJOR"] = 35390] = "UNIFORM_IS_ROW_MAJOR";
    GLEnum[GLEnum["UNIFORM_BLOCK_BINDING"] = 35391] = "UNIFORM_BLOCK_BINDING";
    GLEnum[GLEnum["UNIFORM_BLOCK_DATA_SIZE"] = 35392] = "UNIFORM_BLOCK_DATA_SIZE";
    GLEnum[GLEnum["UNIFORM_BLOCK_ACTIVE_UNIFORMS"] = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS";
    GLEnum[GLEnum["UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"] = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES";
    GLEnum[GLEnum["UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"] = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER";
    GLEnum[GLEnum["UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"] = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER";
    // Sync objects
    GLEnum[GLEnum["OBJECT_TYPE"] = 37138] = "OBJECT_TYPE";
    GLEnum[GLEnum["SYNC_CONDITION"] = 37139] = "SYNC_CONDITION";
    GLEnum[GLEnum["SYNC_STATUS"] = 37140] = "SYNC_STATUS";
    GLEnum[GLEnum["SYNC_FLAGS"] = 37141] = "SYNC_FLAGS";
    GLEnum[GLEnum["SYNC_FENCE"] = 37142] = "SYNC_FENCE";
    GLEnum[GLEnum["SYNC_GPU_COMMANDS_COMPLETE"] = 37143] = "SYNC_GPU_COMMANDS_COMPLETE";
    GLEnum[GLEnum["UNSIGNALED"] = 37144] = "UNSIGNALED";
    GLEnum[GLEnum["SIGNALED"] = 37145] = "SIGNALED";
    GLEnum[GLEnum["ALREADY_SIGNALED"] = 37146] = "ALREADY_SIGNALED";
    GLEnum[GLEnum["TIMEOUT_EXPIRED"] = 37147] = "TIMEOUT_EXPIRED";
    GLEnum[GLEnum["CONDITION_SATISFIED"] = 37148] = "CONDITION_SATISFIED";
    GLEnum[GLEnum["WAIT_FAILED"] = 37149] = "WAIT_FAILED";
    GLEnum[GLEnum["SYNC_FLUSH_COMMANDS_BIT"] = 1] = "SYNC_FLUSH_COMMANDS_BIT";
    // Miscellaneous constants
    GLEnum[GLEnum["COLOR"] = 6144] = "COLOR";
    GLEnum[GLEnum["DEPTH"] = 6145] = "DEPTH";
    GLEnum[GLEnum["STENCIL"] = 6146] = "STENCIL";
    GLEnum[GLEnum["MIN"] = 32775] = "MIN";
    GLEnum[GLEnum["MAX"] = 32776] = "MAX";
    GLEnum[GLEnum["DEPTH_COMPONENT24"] = 33190] = "DEPTH_COMPONENT24";
    GLEnum[GLEnum["STREAM_READ"] = 35041] = "STREAM_READ";
    GLEnum[GLEnum["STREAM_COPY"] = 35042] = "STREAM_COPY";
    GLEnum[GLEnum["STATIC_READ"] = 35045] = "STATIC_READ";
    GLEnum[GLEnum["STATIC_COPY"] = 35046] = "STATIC_COPY";
    GLEnum[GLEnum["DYNAMIC_READ"] = 35049] = "DYNAMIC_READ";
    GLEnum[GLEnum["DYNAMIC_COPY"] = 35050] = "DYNAMIC_COPY";
    GLEnum[GLEnum["DEPTH_COMPONENT32F"] = 36012] = "DEPTH_COMPONENT32F";
    GLEnum[GLEnum["DEPTH32F_STENCIL8"] = 36013] = "DEPTH32F_STENCIL8";
    GLEnum[GLEnum["INVALID_INDEX"] = 4294967295] = "INVALID_INDEX";
    GLEnum[GLEnum["TIMEOUT_IGNORED"] = -1] = "TIMEOUT_IGNORED";
    GLEnum[GLEnum["MAX_CLIENT_WAIT_TIMEOUT_WEBGL"] = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL";
    // Constants defined in WebGL extensions
    // WEBGL_debug_renderer_info
    /** Passed to getParameter to get the vendor string of the graphics driver. */ GLEnum[GLEnum["UNMASKED_VENDOR_WEBGL"] = 37445] = "UNMASKED_VENDOR_WEBGL";
    /** Passed to getParameter to get the renderer string of the graphics driver. */ GLEnum[GLEnum["UNMASKED_RENDERER_WEBGL"] = 37446] = "UNMASKED_RENDERER_WEBGL";
    // EXT_texture_filter_anisotropic
    /** Returns the maximum available anisotropy. */ GLEnum[GLEnum["MAX_TEXTURE_MAX_ANISOTROPY_EXT"] = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT";
    /** Passed to texParameter to set the desired maximum anisotropy for a texture. */ GLEnum[GLEnum["TEXTURE_MAX_ANISOTROPY_EXT"] = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT";
    // EXT_texture_norm16 - https://khronos.org/registry/webgl/extensions/EXT_texture_norm16/
    GLEnum[GLEnum["R16_EXT"] = 33322] = "R16_EXT";
    GLEnum[GLEnum["RG16_EXT"] = 33324] = "RG16_EXT";
    GLEnum[GLEnum["RGB16_EXT"] = 32852] = "RGB16_EXT";
    GLEnum[GLEnum["RGBA16_EXT"] = 32859] = "RGBA16_EXT";
    GLEnum[GLEnum["R16_SNORM_EXT"] = 36760] = "R16_SNORM_EXT";
    GLEnum[GLEnum["RG16_SNORM_EXT"] = 36761] = "RG16_SNORM_EXT";
    GLEnum[GLEnum["RGB16_SNORM_EXT"] = 36762] = "RGB16_SNORM_EXT";
    GLEnum[GLEnum["RGBA16_SNORM_EXT"] = 36763] = "RGBA16_SNORM_EXT";
    // WEBGL_compressed_texture_s3tc (BC1, BC2, BC3)
    /** A DXT1-compressed image in an RGB image format. */ GLEnum[GLEnum["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
    /** A DXT1-compressed image in an RGB image format with a simple on/off alpha value. */ GLEnum[GLEnum["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
    /** A DXT3-compressed image in an RGBA image format. Compared to a 32-bit RGBA texture, it offers 4:1 compression. */ GLEnum[GLEnum["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
    /** A DXT5-compressed image in an RGBA image format. It also provides a 4:1 compression, but differs to the DXT3 compression in how the alpha compression is done. */ GLEnum[GLEnum["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
    // WEBGL_compressed_texture_s3tc_srgb (BC1, BC2, BC3 -  SRGB)
    GLEnum[GLEnum["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
    GLEnum[GLEnum["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
    GLEnum[GLEnum["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
    GLEnum[GLEnum["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
    // WEBGL_compressed_texture_rgtc (BC4, BC5)
    GLEnum[GLEnum["COMPRESSED_RED_RGTC1_EXT"] = 36283] = "COMPRESSED_RED_RGTC1_EXT";
    GLEnum[GLEnum["COMPRESSED_SIGNED_RED_RGTC1_EXT"] = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT";
    GLEnum[GLEnum["COMPRESSED_RED_GREEN_RGTC2_EXT"] = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT";
    GLEnum[GLEnum["COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"] = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
    // WEBGL_compressed_texture_bptc (BC6, BC7)
    GLEnum[GLEnum["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
    GLEnum[GLEnum["COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT"] = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT";
    GLEnum[GLEnum["COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT"] = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT";
    GLEnum[GLEnum["COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT"] = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT";
    // WEBGL_compressed_texture_es3
    /** One-channel (red) unsigned format compression. */ GLEnum[GLEnum["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
    /** One-channel (red) signed format compression. */ GLEnum[GLEnum["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
    /** Two-channel (red and green) unsigned format compression. */ GLEnum[GLEnum["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
    /** Two-channel (red and green) signed format compression. */ GLEnum[GLEnum["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
    /** Compresses RGB8 data with no alpha channel. */ GLEnum[GLEnum["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
    /** Compresses RGBA8 data. The RGB part is encoded the same as RGB_ETC2, but the alpha part is encoded separately. */ GLEnum[GLEnum["COMPRESSED_RGBA8_ETC2_EAC"] = 37493] = "COMPRESSED_RGBA8_ETC2_EAC";
    /** Compresses sRGB8 data with no alpha channel. */ GLEnum[GLEnum["COMPRESSED_SRGB8_ETC2"] = 37494] = "COMPRESSED_SRGB8_ETC2";
    /** Compresses sRGBA8 data. The sRGB part is encoded the same as SRGB_ETC2, but the alpha part is encoded separately. */ GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
    /** Similar to RGB8_ETC, but with ability to punch through the alpha channel, which means to make it completely opaque or transparent. */ GLEnum[GLEnum["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    /** Similar to SRGB8_ETC, but with ability to punch through the alpha channel, which means to make it completely opaque or transparent. */ GLEnum[GLEnum["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    // WEBGL_compressed_texture_pvrtc
    /** RGB compression in 4-bit mode. One block for each 4×4 pixels. */ GLEnum[GLEnum["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
    /** RGBA compression in 4-bit mode. One block for each 4×4 pixels. */ GLEnum[GLEnum["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
    /** RGB compression in 2-bit mode. One block for each 8×4 pixels. */ GLEnum[GLEnum["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
    /** RGBA compression in 2-bit mode. One block for each 8×4 pixels. */ GLEnum[GLEnum["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
    // WEBGL_compressed_texture_etc1
    /** Compresses 24-bit RGB data with no alpha channel. */ GLEnum[GLEnum["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
    // WEBGL_compressed_texture_atc
    GLEnum[GLEnum["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
    GLEnum[GLEnum["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
    GLEnum[GLEnum["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
    // WEBGL_compressed_texture_astc
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
    // EXT_disjoint_timer_query
    /** The number of bits used to hold the query result for the given target. */ GLEnum[GLEnum["QUERY_COUNTER_BITS_EXT"] = 34916] = "QUERY_COUNTER_BITS_EXT";
    /** The currently active query. */ GLEnum[GLEnum["CURRENT_QUERY_EXT"] = 34917] = "CURRENT_QUERY_EXT";
    /** The query result. */ GLEnum[GLEnum["QUERY_RESULT_EXT"] = 34918] = "QUERY_RESULT_EXT";
    /** A Boolean indicating whether or not a query result is available. */ GLEnum[GLEnum["QUERY_RESULT_AVAILABLE_EXT"] = 34919] = "QUERY_RESULT_AVAILABLE_EXT";
    /** Elapsed time (in nanoseconds). */ GLEnum[GLEnum["TIME_ELAPSED_EXT"] = 35007] = "TIME_ELAPSED_EXT";
    /** The current time. */ GLEnum[GLEnum["TIMESTAMP_EXT"] = 36392] = "TIMESTAMP_EXT";
    /** A Boolean indicating whether or not the GPU performed any disjoint operation (lost context) */ GLEnum[GLEnum["GPU_DISJOINT_EXT"] = 36795] = "GPU_DISJOINT_EXT";
    // KHR_parallel_shader_compile https://registry.khronos.org/webgl/extensions/KHR_parallel_shader_compile
    /** a non-blocking poll operation, so that compile/link status availability can be queried without potentially incurring stalls */ GLEnum[GLEnum["COMPLETION_STATUS_KHR"] = 37297] = "COMPLETION_STATUS_KHR";
    // EXT_depth_clamp https://registry.khronos.org/webgl/extensions/EXT_depth_clamp/
    /** Disables depth clipping */ GLEnum[GLEnum["DEPTH_CLAMP_EXT"] = 34383] = "DEPTH_CLAMP_EXT";
    // WEBGL_provoking_vertex https://registry.khronos.org/webgl/extensions/WEBGL_provoking_vertex/
    /** Values of first vertex in primitive are used for flat shading */ GLEnum[GLEnum["FIRST_VERTEX_CONVENTION_WEBGL"] = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL";
    /** Values of first vertex in primitive are used for flat shading */ GLEnum[GLEnum["LAST_VERTEX_CONVENTION_WEBGL"] = 36430] = "LAST_VERTEX_CONVENTION_WEBGL";
    /** Controls which vertex in primitive is used for flat shading */ GLEnum[GLEnum["PROVOKING_VERTEX_WEBL"] = 36431] = "PROVOKING_VERTEX_WEBL";
    // WEBGL_polygon_mode https://registry.khronos.org/webgl/extensions/WEBGL_polygon_mode/
    GLEnum[GLEnum["POLYGON_MODE_WEBGL"] = 2880] = "POLYGON_MODE_WEBGL";
    GLEnum[GLEnum["POLYGON_OFFSET_LINE_WEBGL"] = 10754] = "POLYGON_OFFSET_LINE_WEBGL";
    GLEnum[GLEnum["LINE_WEBGL"] = 6913] = "LINE_WEBGL";
    GLEnum[GLEnum["FILL_WEBGL"] = 6914] = "FILL_WEBGL";
    // WEBGL_clip_cull_distance https://registry.khronos.org/webgl/extensions/WEBGL_clip_cull_distance/
    /** Max clip distances */ GLEnum[GLEnum["MAX_CLIP_DISTANCES_WEBGL"] = 3378] = "MAX_CLIP_DISTANCES_WEBGL";
    /** Max cull distances */ GLEnum[GLEnum["MAX_CULL_DISTANCES_WEBGL"] = 33529] = "MAX_CULL_DISTANCES_WEBGL";
    /** Max clip and cull distances */ GLEnum[GLEnum["MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL"] = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL";
    /** Enable gl_ClipDistance[0] and gl_CullDistance[0] */ GLEnum[GLEnum["CLIP_DISTANCE0_WEBGL"] = 12288] = "CLIP_DISTANCE0_WEBGL";
    /** Enable gl_ClipDistance[1] and gl_CullDistance[1] */ GLEnum[GLEnum["CLIP_DISTANCE1_WEBGL"] = 12289] = "CLIP_DISTANCE1_WEBGL";
    /** Enable gl_ClipDistance[2] and gl_CullDistance[2] */ GLEnum[GLEnum["CLIP_DISTANCE2_WEBGL"] = 12290] = "CLIP_DISTANCE2_WEBGL";
    /** Enable gl_ClipDistance[3] and gl_CullDistance[3] */ GLEnum[GLEnum["CLIP_DISTANCE3_WEBGL"] = 12291] = "CLIP_DISTANCE3_WEBGL";
    /** Enable gl_ClipDistance[4] and gl_CullDistance[4] */ GLEnum[GLEnum["CLIP_DISTANCE4_WEBGL"] = 12292] = "CLIP_DISTANCE4_WEBGL";
    /** Enable gl_ClipDistance[5] and gl_CullDistance[5] */ GLEnum[GLEnum["CLIP_DISTANCE5_WEBGL"] = 12293] = "CLIP_DISTANCE5_WEBGL";
    /** Enable gl_ClipDistance[6] and gl_CullDistance[6] */ GLEnum[GLEnum["CLIP_DISTANCE6_WEBGL"] = 12294] = "CLIP_DISTANCE6_WEBGL";
    /** Enable gl_ClipDistance[7] and gl_CullDistance[7] */ GLEnum[GLEnum["CLIP_DISTANCE7_WEBGL"] = 12295] = "CLIP_DISTANCE7_WEBGL";
    /** EXT_polygon_offset_clamp https://registry.khronos.org/webgl/extensions/EXT_polygon_offset_clamp/ */ GLEnum[GLEnum["POLYGON_OFFSET_CLAMP_EXT"] = 36379] = "POLYGON_OFFSET_CLAMP_EXT";
    /** EXT_clip_control https://registry.khronos.org/webgl/extensions/EXT_clip_control/ */ GLEnum[GLEnum["LOWER_LEFT_EXT"] = 36001] = "LOWER_LEFT_EXT";
    GLEnum[GLEnum["UPPER_LEFT_EXT"] = 36002] = "UPPER_LEFT_EXT";
    GLEnum[GLEnum["NEGATIVE_ONE_TO_ONE_EXT"] = 37726] = "NEGATIVE_ONE_TO_ONE_EXT";
    GLEnum[GLEnum["ZERO_TO_ONE_EXT"] = 37727] = "ZERO_TO_ONE_EXT";
    GLEnum[GLEnum["CLIP_ORIGIN_EXT"] = 37724] = "CLIP_ORIGIN_EXT";
    GLEnum[GLEnum["CLIP_DEPTH_MODE_EXT"] = 37725] = "CLIP_DEPTH_MODE_EXT";
    /** WEBGL_blend_func_extended https://registry.khronos.org/webgl/extensions/WEBGL_blend_func_extended/ */ GLEnum[GLEnum["SRC1_COLOR_WEBGL"] = 35065] = "SRC1_COLOR_WEBGL";
    GLEnum[GLEnum["SRC1_ALPHA_WEBGL"] = 34185] = "SRC1_ALPHA_WEBGL";
    GLEnum[GLEnum["ONE_MINUS_SRC1_COLOR_WEBGL"] = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL";
    GLEnum[GLEnum["ONE_MINUS_SRC1_ALPHA_WEBGL"] = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL";
    GLEnum[GLEnum["MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL"] = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL";
    /** EXT_texture_mirror_clamp_to_edge https://registry.khronos.org/webgl/extensions/EXT_texture_mirror_clamp_to_edge/ */ GLEnum[GLEnum["MIRROR_CLAMP_TO_EDGE_EXT"] = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
})(GLEnum || (GLEnum = {}));
;
 //# sourceMappingURL=webgl-constants.js.map
}}),
}]);

//# sourceMappingURL=node_modules_%40luma_gl_13c49e._.js.map