(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@luma_gl_core_dist_f0a10f._.js", {

"[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "log": (()=>log)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@probe.gl/log/dist/log.js [app-client] (ecmascript)");
;
const log = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Log"]({
    id: 'luma.gl'
}); //# sourceMappingURL=log.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/utils/uid.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "uid": (()=>uid)
});
const uidCounters = {};
function uid(id = 'id') {
    uidCounters[id] = uidCounters[id] || 1;
    const count = uidCounters[id]++;
    return `${id}-${count}`;
} //# sourceMappingURL=uid.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/utils/stats-manager.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "StatsManager": (()=>StatsManager),
    "lumaStats": (()=>lumaStats)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@probe.gl/stats/dist/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Stats$3e$__ = __turbopack_import__("[project]/node_modules/@probe.gl/stats/dist/lib/stats.js [app-client] (ecmascript) <export default as Stats>");
;
class StatsManager {
    stats = new Map();
    getStats(name) {
        return this.get(name);
    }
    get(name) {
        if (!this.stats.has(name)) {
            this.stats.set(name, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Stats$3e$__["Stats"]({
                id: name
            }));
        }
        return this.stats.get(name);
    }
}
const lumaStats = new StatsManager(); //# sourceMappingURL=stats-manager.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/texture-format-table.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* eslint-disable camelcase */ // Define local device feature strings to optimize minification
__turbopack_esm__({
    "getTextureFormatDefinition": (()=>getTextureFormatDefinition),
    "getTextureFormatTable": (()=>getTextureFormatTable)
});
const texture_compression_bc = 'texture-compression-bc';
const texture_compression_astc = 'texture-compression-astc';
const texture_compression_etc2 = 'texture-compression-etc2';
const texture_compression_etc1_webgl = 'texture-compression-etc1-webgl';
const texture_compression_pvrtc_webgl = 'texture-compression-pvrtc-webgl';
const texture_compression_atc_webgl = 'texture-compression-atc-webgl';
const float32_renderable = 'float32-renderable-webgl';
const float16_renderable = 'float16-renderable-webgl';
const rgb9e5ufloat_renderable = 'rgb9e5ufloat-renderable-webgl';
const snorm8_renderable = 'snorm8-renderable-webgl';
const norm16_renderable = 'norm16-renderable-webgl';
const snorm16_renderable = 'snorm16-renderable-webgl';
const float32_filterable = 'float32-filterable';
const float16_filterable = 'float16-filterable-webgl';
function getTextureFormatDefinition(format) {
    const info = TEXTURE_FORMAT_TABLE[format];
    if (!info) {
        throw new Error(`Unsupported texture format ${format}`);
    }
    return info;
}
function getTextureFormatTable() {
    return TEXTURE_FORMAT_TABLE;
}
// prettier-ignore
const TEXTURE_FORMAT_TABLE = {
    // 8-bit formats
    'r8unorm': {},
    'r8snorm': {
        render: snorm8_renderable
    },
    'r8uint': {},
    'r8sint': {},
    // 16-bit formats
    'rg8unorm': {},
    'rg8snorm': {
        render: snorm8_renderable
    },
    'rg8uint': {},
    'rg8sint': {},
    'r16uint': {},
    'r16sint': {},
    'r16float': {
        render: float16_renderable,
        filter: 'float16-filterable-webgl'
    },
    'r16unorm-webgl': {
        f: norm16_renderable
    },
    'r16snorm-webgl': {
        f: snorm16_renderable
    },
    // Packed 16-bit formats
    'rgba4unorm-webgl': {
        channels: 'rgba',
        bitsPerChannel: [
            4,
            4,
            4,
            4
        ],
        packed: true
    },
    'rgb565unorm-webgl': {
        channels: 'rgb',
        bitsPerChannel: [
            5,
            6,
            5,
            0
        ],
        packed: true
    },
    'rgb5a1unorm-webgl': {
        channels: 'rgba',
        bitsPerChannel: [
            5,
            5,
            5,
            1
        ],
        packed: true
    },
    // 24-bit formats
    'rgb8unorm-webgl': {},
    'rgb8snorm-webgl': {},
    // 32-bit formats  
    'rgba8unorm': {},
    'rgba8unorm-srgb': {},
    'rgba8snorm': {
        render: snorm8_renderable
    },
    'rgba8uint': {},
    'rgba8sint': {},
    // 32-bit, reverse colors, webgpu only
    'bgra8unorm': {},
    'bgra8unorm-srgb': {},
    'rg16uint': {},
    'rg16sint': {},
    'rg16float': {
        render: float16_renderable,
        filter: float16_filterable
    },
    'rg16unorm-webgl': {
        render: norm16_renderable
    },
    'rg16snorm-webgl': {
        render: snorm16_renderable
    },
    'r32uint': {},
    'r32sint': {},
    'r32float': {
        render: float32_renderable,
        filter: float32_filterable
    },
    // Packed 32 bit formats
    'rgb9e5ufloat': {
        channels: 'rgb',
        packed: true,
        render: rgb9e5ufloat_renderable
    },
    'rg11b10ufloat': {
        channels: 'rgb',
        bitsPerChannel: [
            11,
            11,
            10,
            0
        ],
        packed: true,
        p: 1,
        render: float32_renderable
    },
    'rgb10a2unorm': {
        channels: 'rgba',
        bitsPerChannel: [
            10,
            10,
            10,
            2
        ],
        packed: true,
        p: 1
    },
    'rgb10a2uint-webgl': {
        channels: 'rgba',
        bitsPerChannel: [
            10,
            10,
            10,
            2
        ],
        packed: true,
        p: 1,
        wgpu: false
    },
    // 48-bit formats
    'rgb16unorm-webgl': {
        f: norm16_renderable
    },
    'rgb16snorm-webgl': {
        f: norm16_renderable
    },
    // 64-bit formats
    'rg32uint': {},
    'rg32sint': {},
    'rg32float': {
        render: false,
        filter: float32_filterable
    },
    'rgba16uint': {},
    'rgba16sint': {},
    'rgba16float': {
        render: float16_renderable,
        filter: float16_filterable
    },
    'rgba16unorm-webgl': {
        render: norm16_renderable
    },
    'rgba16snorm-webgl': {
        render: snorm16_renderable
    },
    // 96-bit formats (deprecated!)
    'rgb32float-webgl': {
        render: float32_renderable,
        filter: float32_filterable
    },
    // 128-bit formats
    'rgba32uint': {},
    'rgba32sint': {},
    'rgba32float': {
        render: float32_renderable,
        filter: float32_filterable
    },
    // Depth/stencil
    // Depth and stencil formats
    stencil8: {
        attachment: 'stencil',
        bitsPerChannel: [
            8,
            0,
            0,
            0
        ],
        dataType: 'uint8'
    },
    'depth16unorm': {
        attachment: 'depth',
        bitsPerChannel: [
            16,
            0,
            0,
            0
        ],
        dataType: 'uint16'
    },
    'depth24plus': {
        attachment: 'depth',
        bitsPerChannel: [
            24,
            0,
            0,
            0
        ],
        dataType: 'uint32'
    },
    'depth32float': {
        attachment: 'depth',
        bitsPerChannel: [
            32,
            0,
            0,
            0
        ],
        dataType: 'float32'
    },
    // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
    'depth24plus-stencil8': {
        attachment: 'depth-stencil',
        bitsPerChannel: [
            24,
            8,
            0,
            0
        ],
        packed: true
    },
    // "depth32float-stencil8" feature
    'depth32float-stencil8': {
        attachment: 'depth-stencil',
        bitsPerChannel: [
            32,
            8,
            0,
            0
        ],
        packed: true
    },
    // BC compressed formats: check device.features.has("texture-compression-bc");
    'bc1-rgb-unorm-webgl': {
        f: texture_compression_bc
    },
    'bc1-rgb-unorm-srgb-webgl': {
        f: texture_compression_bc
    },
    'bc1-rgba-unorm': {
        f: texture_compression_bc
    },
    'bc1-rgba-unorm-srgb': {
        f: texture_compression_bc
    },
    'bc2-rgba-unorm': {
        f: texture_compression_bc
    },
    'bc2-rgba-unorm-srgb': {
        f: texture_compression_bc
    },
    'bc3-rgba-unorm': {
        f: texture_compression_bc
    },
    'bc3-rgba-unorm-srgb': {
        f: texture_compression_bc
    },
    'bc4-r-unorm': {
        f: texture_compression_bc
    },
    'bc4-r-snorm': {
        f: texture_compression_bc
    },
    'bc5-rg-unorm': {
        f: texture_compression_bc
    },
    'bc5-rg-snorm': {
        f: texture_compression_bc
    },
    'bc6h-rgb-ufloat': {
        f: texture_compression_bc
    },
    'bc6h-rgb-float': {
        f: texture_compression_bc
    },
    'bc7-rgba-unorm': {
        f: texture_compression_bc
    },
    'bc7-rgba-unorm-srgb': {
        f: texture_compression_bc
    },
    // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
    // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
    'etc2-rgb8unorm': {
        f: texture_compression_etc2
    },
    'etc2-rgb8unorm-srgb': {
        f: texture_compression_etc2
    },
    'etc2-rgb8a1unorm': {
        f: texture_compression_etc2
    },
    'etc2-rgb8a1unorm-srgb': {
        f: texture_compression_etc2
    },
    'etc2-rgba8unorm': {
        f: texture_compression_etc2
    },
    'etc2-rgba8unorm-srgb': {
        f: texture_compression_etc2
    },
    'eac-r11unorm': {
        f: texture_compression_etc2
    },
    'eac-r11snorm': {
        f: texture_compression_etc2
    },
    'eac-rg11unorm': {
        f: texture_compression_etc2
    },
    'eac-rg11snorm': {
        f: texture_compression_etc2
    },
    // X_ASTC compressed formats: device.features.has("texture-compression-astc")
    'astc-4x4-unorm': {
        f: texture_compression_astc
    },
    'astc-4x4-unorm-srgb': {
        f: texture_compression_astc
    },
    'astc-5x4-unorm': {
        f: texture_compression_astc
    },
    'astc-5x4-unorm-srgb': {
        f: texture_compression_astc
    },
    'astc-5x5-unorm': {
        f: texture_compression_astc
    },
    'astc-5x5-unorm-srgb': {
        f: texture_compression_astc
    },
    'astc-6x5-unorm': {
        f: texture_compression_astc
    },
    'astc-6x5-unorm-srgb': {
        f: texture_compression_astc
    },
    'astc-6x6-unorm': {
        f: texture_compression_astc
    },
    'astc-6x6-unorm-srgb': {
        f: texture_compression_astc
    },
    'astc-8x5-unorm': {
        f: texture_compression_astc
    },
    'astc-8x5-unorm-srgb': {
        f: texture_compression_astc
    },
    'astc-8x6-unorm': {
        f: texture_compression_astc
    },
    'astc-8x6-unorm-srgb': {
        f: texture_compression_astc
    },
    'astc-8x8-unorm': {
        f: texture_compression_astc
    },
    'astc-8x8-unorm-srgb': {
        f: texture_compression_astc
    },
    'astc-10x5-unorm': {
        f: texture_compression_astc
    },
    'astc-10x5-unorm-srgb': {
        f: texture_compression_astc
    },
    'astc-10x6-unorm': {
        f: texture_compression_astc
    },
    'astc-10x6-unorm-srgb': {
        f: texture_compression_astc
    },
    'astc-10x8-unorm': {
        f: texture_compression_astc
    },
    'astc-10x8-unorm-srgb': {
        f: texture_compression_astc
    },
    'astc-10x10-unorm': {
        f: texture_compression_astc
    },
    'astc-10x10-unorm-srgb': {
        f: texture_compression_astc
    },
    'astc-12x10-unorm': {
        f: texture_compression_astc
    },
    'astc-12x10-unorm-srgb': {
        f: texture_compression_astc
    },
    'astc-12x12-unorm': {
        f: texture_compression_astc
    },
    'astc-12x12-unorm-srgb': {
        f: texture_compression_astc
    },
    // WEBGL_compressed_texture_pvrtc
    'pvrtc-rgb4unorm-webgl': {
        f: texture_compression_pvrtc_webgl
    },
    'pvrtc-rgba4unorm-webgl': {
        f: texture_compression_pvrtc_webgl
    },
    'pvrtc-rbg2unorm-webgl': {
        f: texture_compression_pvrtc_webgl
    },
    'pvrtc-rgba2unorm-webgl': {
        f: texture_compression_pvrtc_webgl
    },
    // WEBGL_compressed_texture_etc1
    'etc1-rbg-unorm-webgl': {
        f: texture_compression_etc1_webgl
    },
    // WEBGL_compressed_texture_atc
    'atc-rgb-unorm-webgl': {
        f: texture_compression_atc_webgl
    },
    'atc-rgba-unorm-webgl': {
        f: texture_compression_atc_webgl
    },
    'atc-rgbai-unorm-webgl': {
        f: texture_compression_atc_webgl
    }
}; //# sourceMappingURL=texture-format-table.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/decode-data-type.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** Decodes a vertex type, returning byte length and flags (integer, signed, normalized) */ __turbopack_esm__({
    "decodeVertexType": (()=>decodeVertexType)
});
function decodeVertexType(type) {
    const dataType = TYPE_MAP[type];
    const bytes = getDataTypeBytes(dataType);
    const normalized = type.includes('norm');
    const integer = !normalized && !type.startsWith('float');
    const signed = type.startsWith('s');
    return {
        dataType: TYPE_MAP[type],
        byteLength: bytes,
        integer,
        signed,
        normalized
    };
}
function getDataTypeBytes(type) {
    const bytes = TYPE_SIZES[type];
    // assert(bytes);
    return bytes;
}
const TYPE_MAP = {
    uint8: 'uint8',
    sint8: 'sint8',
    unorm8: 'uint8',
    snorm8: 'sint8',
    uint16: 'uint16',
    sint16: 'sint16',
    unorm16: 'uint16',
    snorm16: 'sint16',
    float16: 'float16',
    float32: 'float32',
    uint32: 'uint32',
    sint32: 'sint32'
};
const TYPE_SIZES = {
    uint8: 1,
    sint8: 1,
    uint16: 2,
    sint16: 2,
    float16: 2,
    float32: 4,
    uint32: 4,
    sint32: 4
}; //# sourceMappingURL=decode-data-type.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/decode-texture-format.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "decodeTextureFormat": (()=>decodeTextureFormat),
    "isTextureFormatCompressed": (()=>isTextureFormatCompressed)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$data$2d$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/decode-data-type.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$texture$2d$format$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/texture-format-table.js [app-client] (ecmascript)");
;
;
// prettier-ignore
const COMPRESSED_TEXTURE_FORMAT_PREFIXES = [
    'bc1',
    'bc2',
    'bc3',
    'bc4',
    'bc5',
    'bc6',
    'bc7',
    'etc1',
    'etc2',
    'eac',
    'atc',
    'astc',
    'pvrtc'
];
const RGB_FORMAT_REGEX = /^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;
function isTextureFormatCompressed(format) {
    return COMPRESSED_TEXTURE_FORMAT_PREFIXES.some((prefix)=>format.startsWith(prefix));
}
function decodeTextureFormat(format) {
    let formatInfo = decodeTextureFormatUsingTable(format);
    if (isTextureFormatCompressed(format)) {
        formatInfo.channels = 'rgb';
        formatInfo.components = 3;
        formatInfo.bytesPerPixel = 1;
        formatInfo.srgb = false;
        formatInfo.compressed = true;
        const blockSize = getCompressedTextureBlockSize(format);
        if (blockSize) {
            formatInfo.blockWidth = blockSize.blockWidth;
            formatInfo.blockHeight = blockSize.blockHeight;
        }
    }
    // Fill in missing information that can be derived from the format string
    const matches = RGB_FORMAT_REGEX.exec(format);
    if (matches) {
        const [, channels, length, type, srgb, suffix] = matches;
        const dataType = `${type}${length}`;
        const decodedType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$data$2d$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVertexType"])(dataType);
        const bits = decodedType.byteLength * 8;
        const components = channels.length;
        const bitsPerChannel = [
            bits,
            components >= 2 ? bits : 0,
            components >= 3 ? bits : 0,
            components >= 4 ? bits : 0
        ];
        formatInfo = {
            format,
            attachment: formatInfo.attachment,
            dataType: decodedType.dataType,
            components,
            channels: channels,
            integer: decodedType.integer,
            signed: decodedType.signed,
            normalized: decodedType.normalized,
            bitsPerChannel,
            bytesPerPixel: decodedType.byteLength * channels.length,
            packed: formatInfo.packed,
            srgb: formatInfo.srgb
        };
        if (suffix === '-webgl') {
            formatInfo.webgl = true;
        }
        // dataType - overwritten by decodedType
        if (srgb === '-srgb') {
            formatInfo.srgb = true;
        }
    }
    if (format.endsWith('-webgl')) {
        formatInfo.webgl = true;
    }
    if (format.endsWith('-srgb')) {
        formatInfo.srgb = true;
    }
    return formatInfo;
}
/** Decode texture format info from the table */ function decodeTextureFormatUsingTable(format) {
    const info = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$texture$2d$format$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTextureFormatDefinition"])(format);
    const bytesPerPixel = info.bytesPerPixel || 1;
    const bitsPerChannel = info.bitsPerChannel || [
        8,
        8,
        8,
        8
    ];
    delete info.bitsPerChannel;
    delete info.bytesPerPixel;
    delete info.f;
    delete info.render;
    delete info.filter;
    delete info.blend;
    delete info.store;
    const formatInfo = {
        ...info,
        format,
        attachment: info.attachment || 'color',
        channels: info.channels || 'r',
        components: info.components || info.channels?.length || 1,
        bytesPerPixel,
        bitsPerChannel,
        dataType: info.dataType || 'uint8',
        srgb: info.srgb ?? false,
        packed: info.packed ?? false,
        webgl: info.webgl ?? false,
        integer: info.integer ?? false,
        signed: info.signed ?? false,
        normalized: info.normalized ?? false,
        compressed: info.compressed ?? false
    };
    return formatInfo;
}
/** Parses ASTC block widths from format string */ function getCompressedTextureBlockSize(format) {
    const REGEX = /.*-(\d+)x(\d+)-.*/;
    const matches = REGEX.exec(format);
    if (matches) {
        const [, blockWidth, blockHeight] = matches;
        return {
            blockWidth: Number(blockWidth),
            blockHeight: Number(blockHeight)
        };
    }
    return null;
} /*
'r8unorm':	{s: "float"}, // 	✓	✓	✓	},
'r8snorm':	{s: "float"}, // 		✓		},
'r8uint':	{s: "uint"}, // 	✓	✓		},
'r8sint':	{s: "sint"}, // 	✓	✓		},
'rg8unorm':	{s: "float"}, // 	✓	✓	✓	},
'rg8snorm':	{s: "float"}, // 		✓		},
'rg8uint':	{s: "uint"}, // 	✓	✓		},
'rg8sint':	{s: "sint"}, // 	✓	✓		},
'rgba8unorm':	{s: "float"}, // 	✓	✓	✓	✓},
'rgba8unorm-srgb': {s: "float"}, // 	✓	✓	✓	},
'rgba8snorm':	{s: "float"}, // 		✓		✓},
'rgba8uint':	{s: "uint"}, // 	✓	✓		✓},
'rgba8sint':	{s: "sint"}, // 	✓	✓		✓},
'bgra8unorm':	{s: "float"}, // 	✓	✓	✓	},
'bgra8unorm-srgb': {s: "float"}, // 	✓	✓	✓	},
// 16-bit per component
'r16uint': {s: "uint"}, // 	✓	✓		},
'r16sint': {s: "sint"}, // 	✓	✓		},
'r16float': {s: "float"}, // 	✓	✓	✓	},
'rg16uint': {s: "uint"}, // 	✓	✓		},
'rg16sint': {s: "sint"}, // 	✓	✓		},
'rg16float': {s: "float"}, // 	✓	✓	✓	},
'rgba16uint': {s: "uint"}, // 	✓	✓		✓},
'rgba16sint': {s: "sint"}, // 	✓	✓		✓},
'rgba16float': {s: "float"}, // 	✓	✓	✓	✓},
// 32-bit per component
'r32uint': {s: "uint"}, // 	✓			✓},
'r32sint': {s: "sint"}, // 	✓			✓},
'r32float': {"unfilterable-float"	✓	✓		✓},
'rg32uint': {s: "uint"}, // 	✓			✓},
'rg32sint': {s: "sint"}, // 	✓			✓},
'rg32float': {"unfilterable-float"	✓			✓},
'rgba32uint': {s: "uint"}, // 	✓			✓},
'rgba32sint': {s: "sint"}, // 	✓			✓},
'rgba32float': {"unfilterable-float"	✓			✓},
// mixed component width
'rgb10a2unorm': {s: "float"}, // 	✓	✓	✓	}
'rg11b10ufloat': {s: "float"}, // 		✓		}
// Format	Bytes per texel	Aspect	GPUTextureSampleType	Valid image copy source	Valid image copy destination
'stencil8': {1 − 4	stencil	"uint"	✓}
'depth16unorm': {2	depth	"depth"	✓}
'depth24plus': {4	depth	"depth"	✗}
'depth24plus': {stencil8	4 − 8	depth	"depth"	✗}
'stencil': {s: "uint"}, // 	✓}
'depth32float': {4	depth	"depth"	✓	✗}
'depth24unorm': {stencil8	4	depth	"depth"	✗}
'stencil': {s: "uint"}, // 	✓}
'depth32float': {stencil8}

// Format	Bytes per block	GPUTextureSampleType	Block Size	Feature
'rgb9e5ufloat': {c: 4, s: "float",	bpp: 4/(1*1)},

'bc1-rgba-unorm': {c: 4. s: "float", bpp: 8/(4 * 4) f: 'texture-compression-bc'},
'bc1-rgba-unorm-srgb': {c: 4. s: "float", bpp: 8/(4 * 4) f: 'texture-compression-bc'},
'bc2-rgba-unorm': {c: 4. s: "float", bpp: 16/(4 * 4) f: 'texture-compression-bc'},
'bc2-rgba-unorm-srgb': {c: 4. s: "float", bpp: 16/(4 * 4) f: 'texture-compression-bc'},
'bc3-rgba-unorm': {c: 4. s: "float", bpp: 16/(4 * 4) f: 'texture-compression-bc'},
'bc3-rgba-unorm-srgb': {c: 4. s: "float", bpp: 16/(4 * 4) f: 'texture-compression-bc'},
'bc4-r-unorm': {c: 1. s: "float", bpp: 8/(4 * 4) f: 'texture-compression-bc'},
'bc4-r-snorm': {c: 1. s: "float", bpp: 8/(4 * 4) f: 'texture-compression-bc'},
'bc5-rg-unorm': {c: 2. s: "float", bpp: 16/(4 * 4) f: 'texture-compression-bc'},
'bc5-rg-snorm': { },
'bc6h-rgb-ufloat': {	16 },
'bc6h-rgb-float': { },
'bc7-rgba-unorm': {	16 },
'bc7-rgba-unorm-srgb': { },

'etc2-rgb8unorm': {	8	"float"	4 × 4	texture-compression-etc2 },
'etc2-rgb8unorm-srgb': { },
'etc2-rgb8a1unorm': {	8 },
'etc2-rgb8a1unorm-srgb': { },
'etc2-rgba8unorm': {	16 },
'etc2-rgba8unorm-srgb': { },

'eac-r11unorm': {	8 },
'eac-r11snorm': { },
'eac-rg11unorm': {	16 },
'eac-rg11snorm': { },

'astc-4x4-unorm': {	16	"float"	4 × 4	texture-compression-astc },
'astc-4x4-unorm-srgb': { },
'astc-5x4-unorm': {	16	5 × 4 },
'astc-5x4-unorm-srgb': { },
'astc-5x5-unorm': {	16	5 × 5 },
'astc-5x5-unorm-srgb': { },
'astc-6x5-unorm': {	16	6 × 5 },
'astc-6x5-unorm-srgb': { },
'astc-6x6-unorm': {	16	6 × 6 },
'astc-6x6-unorm-srgb': { },
'astc-8x5-unorm': {	16	8 × 5 },
'astc-8x5-unorm-srgb': { },
'astc-8x6-unorm': {	16	8 × 6 },
'astc-8x6-unorm-srgb': { },
'astc-8x8-unorm': {	16	8 × 8 },
'astc-8x8-unorm-srgb': { },
'astc-10x5-unorm': {	16	10 × 5 },
'astc-10x5-unorm-srgb': { },
'astc-10x6-unorm': {	16	10 × 6 },
'astc-10x6-unorm-srgb': { },
'astc-10x8-unorm': {	16	10 × 8 },
'astc-10x8-unorm-srgb': { },
'astc-10x10-unorm': {	16	10 × 10 },
'astc-10x10-unorm-srgb': { },
'astc-12x10-unorm': {	16	12 × 10 },
'astc-12x10-unorm-srgb': { },
'astc-12x12-unorm': {	16 },
*/  //# sourceMappingURL=decode-texture-format.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/texture-format-capabilities.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "getTextureFormatCapabilities": (()=>getTextureFormatCapabilities)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$texture$2d$format$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/texture-format-table.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$texture$2d$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/decode-texture-format.js [app-client] (ecmascript)");
;
;
function getTextureFormatCapabilities(format) {
    const info = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$texture$2d$format$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTextureFormatDefinition"])(format);
    const formatCapabilities = {
        format,
        create: info.f ?? true,
        render: info.render ?? true,
        filter: info.filter ?? true,
        blend: info.blend ?? true,
        store: info.store ?? true
    };
    const formatInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$texture$2d$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeTextureFormat"])(format);
    const isDepthStencil = format.startsWith('depth') || format.startsWith('stencil');
    const isSigned = formatInfo?.signed;
    const isInteger = formatInfo?.integer;
    const isWebGLSpecific = formatInfo?.webgl;
    // signed formats are not renderable
    formatCapabilities.render &&= !isSigned;
    // signed and integer formats are not filterable
    formatCapabilities.filter &&= !isDepthStencil && !isSigned && !isInteger && !isWebGLSpecific;
    return formatCapabilities;
} //# sourceMappingURL=texture-format-capabilities.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/resources/resource.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "Resource": (()=>Resource)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/uid.js [app-client] (ecmascript)");
;
class Resource {
    /** Default properties for resource */ static defaultProps = {
        id: 'undefined',
        handle: undefined,
        userData: undefined
    };
    toString() {
        return `${this[Symbol.toStringTag] || this.constructor.name}:"${this.id}"`;
    }
    /** props.id, for debugging. */ id;
    props;
    userData = {};
    _device;
    /** Whether this resource has been destroyed */ destroyed = false;
    /** For resources that allocate GPU memory */ allocatedBytes = 0;
    /** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created "sub" resources. */ _attachedResources = new Set();
    /**
     * Create a new Resource. Called from Subclass
     */ constructor(device, props, defaultProps){
        if (!device) {
            throw new Error('no device');
        }
        this._device = device;
        this.props = selectivelyMerge(props, defaultProps);
        const id = this.props.id !== 'undefined' ? this.props.id : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])(this[Symbol.toStringTag]);
        this.props.id = id;
        this.id = id;
        this.userData = this.props.userData || {};
        this.addStats();
    }
    /**
     * destroy can be called on any resource to release it before it is garbage collected.
     */ destroy() {
        this.destroyResource();
    }
    /** @deprecated Use destroy() */ delete() {
        this.destroy();
        return this;
    }
    /**
     * Combines a map of user props and default props, only including props from defaultProps
     * @returns returns a map of overridden default props
     */ getProps() {
        return this.props;
    }
    // ATTACHED RESOURCES
    /**
     * Attaches a resource. Attached resources are auto destroyed when this resource is destroyed
     * Called automatically when sub resources are auto created but can be called by application
     */ attachResource(resource) {
        this._attachedResources.add(resource);
    }
    /**
     * Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.
     */ detachResource(resource) {
        this._attachedResources.delete(resource);
    }
    /**
     * Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.
     */ destroyAttachedResource(resource) {
        if (this._attachedResources.delete(resource)) {
            resource.destroy();
        }
    }
    /** Destroy all owned resources. Make sure the resources are no longer needed before calling. */ destroyAttachedResources() {
        for (const resource of Object.values(this._attachedResources)){
            resource.destroy();
        }
        // don't remove while we are iterating
        this._attachedResources = new Set();
    }
    // PROTECTED METHODS
    /** Perform all destroy steps. Can be called by derived resources when overriding destroy() */ destroyResource() {
        this.destroyAttachedResources();
        this.removeStats();
        this.destroyed = true;
    }
    /** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */ removeStats() {
        const stats = this._device.statsManager.getStats('Resource Counts');
        const name = this[Symbol.toStringTag];
        stats.get(`${name}s Active`).decrementCount();
    }
    /** Called by subclass to track memory allocations */ trackAllocatedMemory(bytes, name = this[Symbol.toStringTag]) {
        const stats = this._device.statsManager.getStats('Resource Counts');
        stats.get('GPU Memory').addCount(bytes);
        stats.get(`${name} Memory`).addCount(bytes);
        this.allocatedBytes = bytes;
    }
    /** Called by subclass to track memory deallocations */ trackDeallocatedMemory(name = this[Symbol.toStringTag]) {
        const stats = this._device.statsManager.getStats('Resource Counts');
        stats.get('GPU Memory').subtractCount(this.allocatedBytes);
        stats.get(`${name} Memory`).subtractCount(this.allocatedBytes);
        this.allocatedBytes = 0;
    }
    /** Called by resource constructor to track object creation */ addStats() {
        const stats = this._device.statsManager.getStats('Resource Counts');
        const name = this[Symbol.toStringTag];
        stats.get('Resources Created').incrementCount();
        stats.get(`${name}s Created`).incrementCount();
        stats.get(`${name}s Active`).incrementCount();
    }
}
/**
 * Combines a map of user props and default props, only including props from defaultProps
 * @param props
 * @param defaultProps
 * @returns returns a map of overridden default props
 */ function selectivelyMerge(props, defaultProps) {
    const mergedProps = {
        ...defaultProps
    };
    for(const key in props){
        if (props[key] !== undefined) {
            mergedProps[key] = props[key];
        }
    }
    return mergedProps;
} //# sourceMappingURL=resource.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/resources/buffer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "Buffer": (()=>Buffer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/resource.js [app-client] (ecmascript)");
;
class Buffer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"] {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"].defaultProps,
        usage: 0,
        byteLength: 0,
        byteOffset: 0,
        data: null,
        indexType: 'uint16',
        mappedAtCreation: false
    };
    // Usage Flags
    static MAP_READ = 0x01;
    static MAP_WRITE = 0x02;
    static COPY_SRC = 0x0004;
    static COPY_DST = 0x0008;
    /** Index buffer */ static INDEX = 0x0010;
    /** Vertex buffer */ static VERTEX = 0x0020;
    /** Uniform buffer */ static UNIFORM = 0x0040;
    /** Storage buffer */ static STORAGE = 0x0080;
    static INDIRECT = 0x0100;
    static QUERY_RESOLVE = 0x0200;
    get [Symbol.toStringTag]() {
        return 'Buffer';
    }
    /** The usage with which this buffer was created */ usage;
    /** For index buffers, whether indices are 16 or 32 bit */ indexType;
    /** "Time" of last update, can be used to check if redraw is needed */ updateTimestamp;
    constructor(device, props){
        const deducedProps = {
            ...props
        };
        // Deduce indexType
        if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {
            if (props.data instanceof Uint32Array) {
                deducedProps.indexType = 'uint32';
            } else if (props.data instanceof Uint16Array) {
                deducedProps.indexType = 'uint16';
            }
        }
        // Remove data from props before storing, we don't want to hold on to a big chunk of memory
        delete deducedProps.data;
        super(device, deducedProps, Buffer.defaultProps);
        this.usage = deducedProps.usage || 0;
        this.indexType = deducedProps.indexType;
        // TODO - perhaps this should be set on async write completion?
        this.updateTimestamp = device.incrementTimestamp();
    }
    /**
     * Create a copy of this Buffer with new byteLength, with same props but of the specified size.
     * @note Does not copy contents of the cloned Buffer.
     */ clone(props) {
        return this.device.createBuffer({
            ...this.props,
            ...props
        });
    }
    /** Read data synchronously. @note WebGL2 only */ readSyncWebGL(byteOffset, byteLength) {
        throw new Error('not implemented');
    }
    // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)
    /** Max amount of debug data saved. Two vec4's */ static DEBUG_DATA_MAX_LENGTH = 32;
    /** A partial CPU-side copy of the data in this buffer, for debugging purposes */ debugData = new ArrayBuffer(0);
    /** This doesn't handle partial non-zero offset updates correctly */ _setDebugData(data, byteOffset, byteLength) {
        const arrayBuffer = ArrayBuffer.isView(data) ? data.buffer : data;
        const debugDataLength = Math.min(data ? data.byteLength : byteLength, Buffer.DEBUG_DATA_MAX_LENGTH);
        if (arrayBuffer === null) {
            this.debugData = new ArrayBuffer(debugDataLength);
        } else if (byteOffset === 0 && byteLength === arrayBuffer.byteLength) {
            this.debugData = arrayBuffer.slice(0, debugDataLength);
        } else {
            this.debugData = arrayBuffer.slice(byteOffset, byteOffset + debugDataLength);
        }
    }
} //# sourceMappingURL=buffer.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/device.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "Device": (()=>Device),
    "DeviceFeatures": (()=>DeviceFeatures),
    "DeviceLimits": (()=>DeviceLimits)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/uid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$stats$2d$manager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/stats-manager.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$texture$2d$format$2d$capabilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/texture-format-capabilities.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$texture$2d$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/decode-texture-format.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/buffer.js [app-client] (ecmascript)");
;
;
;
;
;
;
class DeviceLimits {
}
class DeviceFeatures {
    features;
    disabledFeatures;
    constructor(features = [], disabledFeatures){
        this.features = new Set(features);
        this.disabledFeatures = disabledFeatures || {};
    }
    *[Symbol.iterator]() {
        yield* this.features;
    }
    has(feature) {
        return !this.disabledFeatures?.[feature] && this.features.has(feature);
    }
}
class Device {
    static defaultProps = {
        id: null,
        powerPreference: 'high-performance',
        failIfMajorPerformanceCaveat: false,
        createCanvasContext: undefined,
        // Callbacks
        onError: (error)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].error(error.message)(),
        // Experimental
        _reuseDevices: false,
        _requestMaxLimits: true,
        _factoryDestroyPolicy: 'unused',
        // TODO - Change these after confirming things work as expected
        _initializeFeatures: true,
        _disabledFeatures: {
            'compilation-status-async-webgl': true
        },
        _resourceDefaults: {},
        // WebGL specific
        webgl: {},
        debug: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].get('debug') || undefined,
        debugShaders: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].get('debug-shaders') || undefined,
        debugFramebuffers: Boolean(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].get('debug-framebuffers')),
        debugWebGL: Boolean(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].get('debug-webgl')),
        debugSpectorJS: undefined,
        debugSpectorJSUrl: undefined,
        // INTERNAL
        _handle: undefined
    };
    get [Symbol.toStringTag]() {
        return 'Device';
    }
    constructor(props){
        this.props = {
            ...Device.defaultProps,
            ...props
        };
        this.id = this.props.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])(this[Symbol.toStringTag].toLowerCase());
    }
    /** id of this device, primarily for debugging */ id;
    /** A copy of the device props  */ props;
    /** Available for the application to store data on the device */ userData = {};
    /** stats */ statsManager = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$stats$2d$manager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lumaStats"];
    /** An abstract timestamp used for change tracking */ timestamp = 0;
    /** True if this device has been reused during device creation (app has multiple references) */ _reused = false;
    /** Used by other luma.gl modules to store data on the device */ _lumaData = {};
    /** Determines what operations are supported on a texture format, checking against supported device features */ getTextureFormatCapabilities(format) {
        const genericCapabilities = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$texture$2d$format$2d$capabilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTextureFormatCapabilities"])(format);
        // Check standard features
        const checkFeature = (featureOrBoolean)=>(typeof featureOrBoolean === 'string' ? this.features.has(featureOrBoolean) : featureOrBoolean) ?? true;
        const supported = checkFeature(genericCapabilities.create);
        const deviceCapabilities = {
            format,
            create: supported,
            render: supported && checkFeature(genericCapabilities.render),
            filter: supported && checkFeature(genericCapabilities.filter),
            blend: supported && checkFeature(genericCapabilities.blend),
            store: supported && checkFeature(genericCapabilities.store)
        };
        return this._getDeviceSpecificTextureFormatCapabilities(deviceCapabilities);
    }
    /** Check if device supports a specific texture format (creation and `nearest` sampling) */ isTextureFormatSupported(format, capabilities) {
        return this.getTextureFormatCapabilities(format).create;
    }
    /** Check if linear filtering (sampler interpolation) is supported for a specific texture format */ isTextureFormatFilterable(format) {
        return this.getTextureFormatCapabilities(format).filter;
    }
    /** Check if device supports rendering to a framebuffer color attachment of a specific texture format */ isTextureFormatRenderable(format) {
        return this.getTextureFormatCapabilities(format).render;
    }
    /** Check if a specific texture format is GPU compressed */ isTextureFormatCompressed(format) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$texture$2d$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextureFormatCompressed"])(format);
    }
    /**
     * Trigger device loss.
     * @returns `true` if context loss could actually be triggered.
     * @note primarily intended for testing how application reacts to device loss
     */ loseDevice() {
        return false;
    }
    /** Report error (normally called for unhandled device errors) */ reportError(error) {
        this.props.onError(error);
    }
    /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */ getDefaultCanvasContext() {
        if (!this.canvasContext) {
            throw new Error('Device has no default CanvasContext. See props.createCanvasContext');
        }
        return this.canvasContext;
    }
    createCommandEncoder(props = {}) {
        throw new Error('not implemented');
    }
    /** A monotonic counter for tracking buffer and texture updates */ incrementTimestamp() {
        return this.timestamp++;
    }
    // Error Handling
    /** Report unhandled device errors */ onError(error) {
        this.props.onError(error);
    }
    // DEPRECATED METHODS
    /** @deprecated Use getDefaultCanvasContext() */ getCanvasContext() {
        return this.getDefaultCanvasContext();
    }
    // WebGL specific HACKS - enables app to remove webgl import
    // Use until we have a better way to handle these
    /** @deprecated - will be removed - should use command encoder */ readPixelsToArrayWebGL(source, options) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use command encoder */ readPixelsToBufferWebGL(source, options) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */ setParametersWebGL(parameters) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */ getParametersWebGL(parameters) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */ withParametersWebGL(parameters, func) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use clear arguments in RenderPass */ clearWebGL(options) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use for debugging only */ resetWebGL() {
        throw new Error('not implemented');
    }
    // IMPLEMENTATION
    /** Helper to get the canvas context props */ static _getCanvasContextProps(props) {
        return props.createCanvasContext === true ? {} : props.createCanvasContext;
    }
    /** Subclasses use this to support .createBuffer() overloads */ _normalizeBufferProps(props) {
        if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {
            props = {
                data: props
            };
        }
        // TODO - fragile, as this is done before we merge with default options
        // inside the Buffer constructor
        const newProps = {
            ...props
        };
        // Deduce indexType
        if ((props.usage || 0) & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].INDEX && !props.indexType) {
            if (props.data instanceof Uint32Array) {
                newProps.indexType = 'uint32';
            } else if (props.data instanceof Uint16Array) {
                newProps.indexType = 'uint16';
            } else {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn('indices buffer content must be of integer type')();
            }
        }
        return newProps;
    }
} //# sourceMappingURL=device.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/resources/texture.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "Texture": (()=>Texture)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/resource.js [app-client] (ecmascript)");
;
class Texture extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"] {
    static COPY_SRC = 0x01;
    static COPY_DST = 0x02;
    static TEXTURE = 0x04;
    static STORAGE = 0x08;
    static RENDER_ATTACHMENT = 0x10;
    static CubeFaces = [
        '+X',
        '-X',
        '+Y',
        '-Y',
        '+Z',
        '-Z'
    ];
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"].defaultProps,
        data: null,
        dimension: '2d',
        format: 'rgba8unorm',
        width: undefined,
        height: undefined,
        depth: 1,
        mipmaps: false,
        compressed: false,
        usage: 0,
        mipLevels: undefined,
        samples: undefined,
        sampler: {},
        view: undefined,
        flipY: undefined
    };
    get [Symbol.toStringTag]() {
        return 'Texture';
    }
    toString() {
        return `Texture(${this.id},${this.format},${this.width}x${this.height})`;
    }
    /** dimension of this texture */ dimension;
    /** format of this texture */ format;
    /** width in pixels of this texture */ width;
    /** height in pixels of this texture */ height;
    /** depth of this texture */ depth;
    /** mip levels in this texture */ mipLevels;
    /** "Time" of last update. Monotonically increasing timestamp. TODO move to AsyncTexture? */ updateTimestamp;
    /** Do not use directly. Create with device.createTexture() */ constructor(device, props){
        props = Texture.normalizeProps(device, props);
        super(device, props, Texture.defaultProps);
        this.dimension = this.props.dimension;
        this.format = this.props.format;
        // Size
        this.width = this.props.width;
        this.height = this.props.height;
        this.depth = this.props.depth;
        // Calculate size, if not provided
        if (this.props.width === undefined || this.props.height === undefined) {
            // @ts-ignore
            const size = Texture.getTextureDataSize(this.props.data);
            this.width = size?.width || 1;
            this.height = size?.height || 1;
        }
        // mipLevels
        // If mipmap generation is requested and mipLevels is not provided, initialize a full pyramid
        if (this.props.mipmaps && this.props.mipLevels === undefined) {
            this.props.mipLevels = 'pyramid';
        }
        // Auto-calculate the number of mip levels as a convenience
        // TODO - Should we clamp to 1-getMipLevelCount?
        this.mipLevels = this.props.mipLevels === 'pyramid' ? Texture.getMipLevelCount(this.width, this.height) : this.props.mipLevels || 1;
        // TODO - perhaps this should be set on async write completion?
        this.updateTimestamp = device.incrementTimestamp();
    }
    /**
     * Create a new texture with the same parameters and optionally, a different size
     * @note Textures are immutable and cannot be resized after creation, but we can create a similar texture with the same parameters but a new size.
     * @note Does not copy contents of the texture
     */ clone(size) {
        return this.device.createTexture({
            ...this.props,
            ...size
        });
    }
    /** Check if data is an external image */ static isExternalImage(data) {
        return typeof ImageData !== 'undefined' && data instanceof ImageData || typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap || typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement || typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement || typeof VideoFrame !== 'undefined' && data instanceof VideoFrame || typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas;
    }
    /** Determine size (width and height) of provided image data */ static getExternalImageSize(data) {
        if (typeof ImageData !== 'undefined' && data instanceof ImageData || typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap || typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas) {
            return {
                width: data.width,
                height: data.height
            };
        }
        if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {
            return {
                width: data.naturalWidth,
                height: data.naturalHeight
            };
        }
        if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {
            return {
                width: data.videoWidth,
                height: data.videoHeight
            };
        }
        if (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) {
            // TODO: is this the right choice for width and height?
            return {
                width: data.displayWidth,
                height: data.displayHeight
            };
        }
        throw new Error('Unknown image type');
    }
    /** Check if texture data is a typed array */ static isTextureLevelData(data) {
        const typedArray = data?.data;
        return ArrayBuffer.isView(typedArray);
    }
    /** Get the size of the texture described by the provided TextureData */ static getTextureDataSize(data) {
        if (!data) {
            return null;
        }
        if (ArrayBuffer.isView(data)) {
            return null;
        }
        // Recurse into arrays (array of miplevels)
        if (Array.isArray(data)) {
            return Texture.getTextureDataSize(data[0]);
        }
        if (Texture.isExternalImage(data)) {
            return Texture.getExternalImageSize(data);
        }
        if (data && typeof data === 'object' && data.constructor === Object) {
            const textureDataArray = Object.values(data);
            const untypedData = textureDataArray[0];
            return {
                width: untypedData.width,
                height: untypedData.height
            };
        }
        throw new Error('texture size deduction failed');
    }
    /**
     * Normalize TextureData to an array of TextureLevelData / ExternalImages
     * @param data
     * @param options
     * @returns array of TextureLevelData / ExternalImages
     */ static normalizeTextureData(data, options) {
        let lodArray;
        if (ArrayBuffer.isView(data)) {
            lodArray = [
                {
                    // ts-expect-error does data really need to be Uint8ClampedArray?
                    data,
                    width: options.width,
                    height: options.height
                }
            ];
        } else if (!Array.isArray(data)) {
            lodArray = [
                data
            ];
        } else {
            lodArray = data;
        }
        return lodArray;
    }
    /** Calculate the number of mip levels for a texture of width and height */ static getMipLevelCount(width, height) {
        return Math.floor(Math.log2(Math.max(width, height))) + 1;
    }
    /** Convert luma.gl cubemap face constants to depth index */ static getCubeFaceDepth(face) {
        // prettier-ignore
        switch(face){
            case '+X':
                return 0;
            case '-X':
                return 1;
            case '+Y':
                return 2;
            case '-Y':
                return 3;
            case '+Z':
                return 4;
            case '-Z':
                return 5;
            default:
                throw new Error(face);
        }
    }
    /** Default options */ static defaultCopyExternalImageOptions = {
        image: undefined,
        sourceX: 0,
        sourceY: 0,
        width: undefined,
        height: undefined,
        depth: 1,
        mipLevel: 0,
        x: 0,
        y: 0,
        z: 0,
        aspect: 'all',
        colorSpace: 'srgb',
        premultipliedAlpha: false,
        flipY: false
    };
    /** Ensure we have integer coordinates */ static normalizeProps(device, props) {
        const newProps = {
            ...props
        };
        // Allow device to override props (e.g. props.mipmaps)
        const overriddenDefaultProps = device?.props?._resourceDefaults?.texture || {};
        // TODO - Type issue with props.data circumvented with Object.assign
        Object.assign(newProps, overriddenDefaultProps);
        // Ensure we have integer coordinates
        const { width, height } = newProps;
        if (typeof width === 'number') {
            newProps.width = Math.max(1, Math.ceil(width));
        }
        if (typeof height === 'number') {
            newProps.height = Math.max(1, Math.ceil(height));
        }
        return newProps;
    }
} //# sourceMappingURL=texture.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/resources/framebuffer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "Framebuffer": (()=>Framebuffer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/resource.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/texture.js [app-client] (ecmascript)");
;
;
;
class Framebuffer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"] {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"].defaultProps,
        width: 1,
        height: 1,
        colorAttachments: [],
        depthStencilAttachment: null // 'depth24plus-stencil8'
    };
    get [Symbol.toStringTag]() {
        return 'Framebuffer';
    }
    /** Width of all attachments in this framebuffer */ width;
    /** Height of all attachments in this framebuffer */ height;
    constructor(device, props = {}){
        super(device, props, Framebuffer.defaultProps);
        this.width = this.props.width;
        this.height = this.props.height;
    }
    /**
     * Create a copy of this framebuffer with new attached textures, with same props but of the specified size.
     * @note Does not copy contents of the attached textures.
     */ clone(size) {
        const colorAttachments = this.colorAttachments.map((colorAttachment)=>colorAttachment.texture.clone(size));
        const depthStencilAttachment = this.depthStencilAttachment && this.depthStencilAttachment.texture.clone(size);
        return this.device.createFramebuffer({
            ...this.props,
            colorAttachments,
            depthStencilAttachment
        });
    }
    resize(size) {
        let updateSize = !size;
        if (size) {
            const [width, height] = Array.isArray(size) ? size : [
                size.width,
                size.height
            ];
            updateSize = updateSize || height !== this.height || width !== this.width;
            this.width = width;
            this.height = height;
        }
        if (updateSize) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)();
            this.resizeAttachments(this.width, this.height);
        }
    }
    /** Auto creates any textures */ autoCreateAttachmentTextures() {
        if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment) {
            throw new Error('Framebuffer has noattachments');
        }
        this.colorAttachments = this.props.colorAttachments.map((attachment, index)=>{
            if (typeof attachment === 'string') {
                const texture = this.createColorTexture(attachment, index);
                this.attachResource(texture);
                return texture.view;
            }
            if (attachment instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"]) {
                return attachment.view;
            }
            return attachment;
        });
        const attachment = this.props.depthStencilAttachment;
        if (attachment) {
            if (typeof attachment === 'string') {
                const texture = this.createDepthStencilTexture(attachment);
                this.attachResource(texture);
                this.depthStencilAttachment = texture.view;
            } else if (attachment instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"]) {
                this.depthStencilAttachment = attachment.view;
            } else {
                this.depthStencilAttachment = attachment;
            }
        }
    }
    /** Create a color texture */ createColorTexture(format, index) {
        return this.device.createTexture({
            id: `${this.id}-color-attachment-${index}`,
            usage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"].RENDER_ATTACHMENT,
            format,
            width: this.width,
            height: this.height,
            // TODO deprecated? - luma.gl v8 compatibility
            sampler: {
                magFilter: 'linear',
                minFilter: 'linear'
            }
        });
    }
    /** Create depth stencil texture */ createDepthStencilTexture(format) {
        return this.device.createTexture({
            id: `${this.id}-depth-stencil-attachment`,
            usage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"].RENDER_ATTACHMENT,
            format,
            width: this.width,
            height: this.height,
            mipmaps: false
        });
    }
    /**
     * Default implementation of resize
     * Creates new textures with correct size for all attachments.
     * and destroys existing textures if owned
     */ resizeAttachments(width, height) {
        for(let i = 0; i < this.colorAttachments.length; ++i){
            if (this.colorAttachments[i]) {
                const resizedTexture = this.colorAttachments[i].texture.clone({
                    width,
                    height
                });
                this.destroyAttachedResource(this.colorAttachments[i]);
                this.colorAttachments[i] = resizedTexture.view;
                this.attachResource(resizedTexture.view);
            }
        }
        if (this.depthStencilAttachment) {
            const resizedTexture = this.depthStencilAttachment.texture.clone({
                width,
                height
            });
            this.destroyAttachedResource(this.depthStencilAttachment);
            this.depthStencilAttachment = resizedTexture.view;
            this.attachResource(resizedTexture);
        }
        this.updateAttachments();
    }
} //# sourceMappingURL=framebuffer.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/canvas-context.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "CanvasContext": (()=>CanvasContext)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@probe.gl/env/dist/lib/is-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/uid.js [app-client] (ecmascript)");
;
;
;
class CanvasContext {
    static defaultProps = {
        canvas: null,
        width: 800,
        height: 600,
        useDevicePixels: true,
        autoResize: true,
        container: null,
        visible: true,
        alphaMode: 'opaque',
        colorSpace: 'srgb'
    };
    id;
    props;
    canvas;
    htmlCanvas;
    offscreenCanvas;
    type;
    width = 1;
    height = 1;
    resizeObserver;
    /** State used by luma.gl classes: TODO - move to canvasContext*/ _canvasSizeInfo = {
        clientWidth: 0,
        clientHeight: 0,
        devicePixelRatio: 1
    };
    toString() {
        return `${this[Symbol.toStringTag]}(${this.id})`;
    }
    constructor(props){
        this.props = {
            ...CanvasContext.defaultProps,
            ...props
        };
        props = this.props;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBrowser"])()) {
            this.id = 'node-canvas-context';
            this.type = 'node';
            this.width = this.props.width;
            this.height = this.props.height;
            // TODO - does this prevent app from using jsdom style polyfills?
            this.canvas = null;
            return;
        }
        if (!props.canvas) {
            const canvas = createCanvas(props);
            const container = getContainer(props?.container || null);
            container.insertBefore(canvas, container.firstChild);
            this.canvas = canvas;
            if (!props?.visible) {
                this.canvas.style.visibility = 'hidden';
            }
        } else if (typeof props.canvas === 'string') {
            this.canvas = getCanvasFromDOM(props.canvas);
        } else {
            this.canvas = props.canvas;
        }
        if (this.canvas instanceof HTMLCanvasElement) {
            this.id = this.canvas.id;
            this.type = 'html-canvas';
            this.htmlCanvas = this.canvas;
        } else {
            this.id = 'offscreen-canvas';
            this.type = 'offscreen-canvas';
            this.offscreenCanvas = this.canvas;
        }
        // React to size changes
        if (this.canvas instanceof HTMLCanvasElement && props.autoResize) {
            this.resizeObserver = new ResizeObserver((entries)=>{
                for (const entry of entries){
                    if (entry.target === this.canvas) {
                        this.update();
                    }
                }
            });
            this.resizeObserver.observe(this.canvas);
        }
    }
    /**
     * Returns the current DPR, if props.useDevicePixels is true
     * Device refers to physical
     */ getDevicePixelRatio(useDevicePixels) {
        if (typeof OffscreenCanvas !== 'undefined' && this.canvas instanceof OffscreenCanvas) {
            return 1;
        }
        useDevicePixels = useDevicePixels === undefined ? this.props.useDevicePixels : useDevicePixels;
        if (!useDevicePixels || useDevicePixels <= 0) {
            return 1;
        }
        // The param was mainly provide to support the test cases, could be removed
        if (useDevicePixels === true) {
            const dpr = typeof window !== 'undefined' && window.devicePixelRatio;
            return dpr || 1;
        }
        return useDevicePixels;
    }
    /**
     * Returns the size of drawing buffer in device pixels.
     * @note This can be different from the 'CSS' size of a canvas, and also from the
     * canvas' internal drawing buffer size (.width, .height).
     * This is the size required to cover the canvas, adjusted for DPR
     */ getPixelSize() {
        switch(this.type){
            case 'node':
                return [
                    this.width,
                    this.height
                ];
            case 'offscreen-canvas':
                return [
                    this.canvas.width,
                    this.canvas.height
                ];
            case 'html-canvas':
                const dpr = this.getDevicePixelRatio();
                const canvas = this.canvas;
                // If not attached to DOM client size can be 0
                return canvas.parentElement ? [
                    canvas.clientWidth * dpr,
                    canvas.clientHeight * dpr
                ] : [
                    this.canvas.width,
                    this.canvas.height
                ];
            default:
                throw new Error(this.type);
        }
    }
    getAspect() {
        const [width, height] = this.getPixelSize();
        return width / height;
    }
    /**
     * Returns multiplier need to convert CSS size to Device size
     */ cssToDeviceRatio() {
        try {
            // For headless gl we might have used custom width and height
            // hence use cached clientWidth
            const [drawingBufferWidth] = this.getDrawingBufferSize();
            // _canvasSizeInfo may not be populated if `setDevicePixelRatio` is never called
            const clientWidth = this._canvasSizeInfo.clientWidth || this.htmlCanvas?.clientWidth;
            return clientWidth ? drawingBufferWidth / clientWidth : 1;
        } catch  {
            return 1;
        }
    }
    /**
     * Maps CSS pixel position to device pixel position
     */ cssToDevicePixels(cssPixel, yInvert = true) {
        const ratio = this.cssToDeviceRatio();
        const [width, height] = this.getDrawingBufferSize();
        return scalePixels(cssPixel, ratio, width, height, yInvert);
    }
    /**
     * Use devicePixelRatio to set canvas width and height
     * @note this is a raw port of luma.gl v8 code. Might be worth a review
     */ setDevicePixelRatio(devicePixelRatio, options = {}) {
        if (!this.htmlCanvas) {
            return;
        }
        // NOTE: if options.width and options.height not used remove in v8
        let clientWidth = 'width' in options ? options.width : this.htmlCanvas.clientWidth;
        let clientHeight = 'height' in options ? options.height : this.htmlCanvas.clientHeight;
        if (!clientWidth || !clientHeight) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].log(1, 'Canvas clientWidth/clientHeight is 0')();
            // by forcing devicePixel ratio to 1, we do not scale canvas.width and height in each frame.
            devicePixelRatio = 1;
            clientWidth = this.htmlCanvas.width || 1;
            clientHeight = this.htmlCanvas.height || 1;
        }
        const cachedSize = this._canvasSizeInfo;
        // Check if canvas needs to be resized
        if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
            let clampedPixelRatio = devicePixelRatio;
            const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
            const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
            this.htmlCanvas.width = canvasWidth;
            this.htmlCanvas.height = canvasHeight;
            // @ts-expect-error This only works for WebGL
            const gl = this.device.gl;
            if (gl) {
                // Note: when devicePixelRatio is too high, it is possible we might hit system limit for
                // drawing buffer width and hight, in those cases they get clamped and resulting aspect ration may not be maintained
                // for those cases, reduce devicePixelRatio.
                const [drawingBufferWidth, drawingBufferHeight] = this.getDrawingBufferSize();
                if (drawingBufferWidth !== canvasWidth || drawingBufferHeight !== canvasHeight) {
                    clampedPixelRatio = Math.min(drawingBufferWidth / clientWidth, drawingBufferHeight / clientHeight);
                    this.htmlCanvas.width = Math.floor(clientWidth * clampedPixelRatio);
                    this.htmlCanvas.height = Math.floor(clientHeight * clampedPixelRatio);
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn('Device pixel ratio clamped')();
                }
                this._canvasSizeInfo.clientWidth = clientWidth;
                this._canvasSizeInfo.clientHeight = clientHeight;
                this._canvasSizeInfo.devicePixelRatio = devicePixelRatio;
            }
        }
    }
    // PRIVATE
    /** @todo Major hack done to port the CSS methods above, base canvas context should not depend on WebGL */ getDrawingBufferSize() {
        // @ts-expect-error This only works for WebGL
        const gl = this.device.gl;
        if (!gl) {
            // use default device pixel ratio
            throw new Error('canvas size');
        }
        return [
            gl.drawingBufferWidth,
            gl.drawingBufferHeight
        ];
    }
    /**
     * Allows subclass constructor to override the canvas id for auto created canvases.
     * This can really help when debugging DOM in apps that create multiple devices
     */ _setAutoCreatedCanvasId(id) {
        if (this.htmlCanvas?.id === 'lumagl-auto-created-canvas') {
            this.htmlCanvas.id = id;
        }
    }
}
// HELPER FUNCTIONS
function getContainer(container) {
    if (typeof container === 'string') {
        const element = document.getElementById(container);
        if (!element) {
            throw new Error(`${container} is not an HTML element`);
        }
        return element;
    } else if (container) {
        return container;
    }
    return document.body;
}
/** Get a Canvas element from DOM id */ function getCanvasFromDOM(canvasId) {
    const canvas = document.getElementById(canvasId);
    if (!(canvas instanceof HTMLCanvasElement)) {
        throw new Error('Object is not a canvas element');
    }
    return canvas;
}
/** Create a new canvas */ function createCanvas(props) {
    const { width, height } = props;
    const targetCanvas = document.createElement('canvas');
    targetCanvas.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])('lumagl-auto-created-canvas');
    targetCanvas.width = width || 1;
    targetCanvas.height = height || 1;
    targetCanvas.style.width = Number.isFinite(width) ? `${width}px` : '100%';
    targetCanvas.style.height = Number.isFinite(height) ? `${height}px` : '100%';
    return targetCanvas;
}
/**
 *
 * @param pixel
 * @param ratio
 * @param width
 * @param height
 * @param yInvert
 * @returns
 */ function scalePixels(pixel, ratio, width, height, yInvert) {
    const point = pixel;
    const x = scaleX(point[0], ratio, width);
    let y = scaleY(point[1], ratio, height, yInvert);
    // Find boundaries of next pixel to provide valid range of device pixel locations
    let t = scaleX(point[0] + 1, ratio, width);
    // If next pixel's position is clamped to boundary, use it as is, otherwise subtract 1 for current pixel boundary
    const xHigh = t === width - 1 ? t : t - 1;
    t = scaleY(point[1] + 1, ratio, height, yInvert);
    let yHigh;
    if (yInvert) {
        // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range
        t = t === 0 ? t : t + 1;
        // swap y and yHigh
        yHigh = y;
        y = t;
    } else {
        // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range
        yHigh = t === height - 1 ? t : t - 1;
    // y remains same
    }
    return {
        x,
        y,
        // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.
        width: Math.max(xHigh - x + 1, 1),
        height: Math.max(yHigh - y + 1, 1)
    };
}
function scaleX(x, ratio, width) {
    // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit
    const r = Math.min(Math.round(x * ratio), width - 1);
    return r;
}
function scaleY(y, ratio, height, yInvert) {
    // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit
    return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);
} //# sourceMappingURL=canvas-context.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/resources/texture-view.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "TextureView": (()=>TextureView)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/resource.js [app-client] (ecmascript)");
;
class TextureView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"] {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"].defaultProps,
        format: undefined,
        dimension: undefined,
        aspect: 'all',
        baseMipLevel: 0,
        mipLevelCount: undefined,
        baseArrayLayer: 0,
        arrayLayerCount: undefined
    };
    get [Symbol.toStringTag]() {
        return 'TextureView';
    }
    /** Should not be constructed directly. Use `texture.createView(props)` */ constructor(device, props){
        super(device, props, TextureView.defaultProps);
    }
} //# sourceMappingURL=texture-view.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/resources/sampler.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "Sampler": (()=>Sampler)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/resource.js [app-client] (ecmascript)");
;
class Sampler extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"] {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"].defaultProps,
        type: 'color-sampler',
        addressModeU: 'clamp-to-edge',
        addressModeV: 'clamp-to-edge',
        addressModeW: 'clamp-to-edge',
        magFilter: 'nearest',
        minFilter: 'nearest',
        mipmapFilter: 'none',
        lodMinClamp: 0,
        lodMaxClamp: 32,
        compare: 'less-equal',
        maxAnisotropy: 1
    };
    get [Symbol.toStringTag]() {
        return 'Sampler';
    }
    constructor(device, props){
        props = Sampler.normalizeProps(device, props);
        super(device, props, Sampler.defaultProps);
    }
    static normalizeProps(device, props) {
        const overriddenDefaultProps = device?.props?._resourceDefaults?.sampler || {};
        const newProps = {
            ...props,
            ...overriddenDefaultProps
        };
        return newProps;
    }
} //# sourceMappingURL=sampler.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter-utils/format-compiler-log.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** @returns annotated errors or warnings */ __turbopack_esm__({
    "formatCompilerLog": (()=>formatCompilerLog)
});
function formatCompilerLog(shaderLog, source, options) {
    let formattedLog = '';
    const lines = source.split(/\r?\n/);
    const log = shaderLog.slice().sort((a, b)=>a.lineNum - b.lineNum);
    switch(options?.showSourceCode || 'no'){
        case 'all':
            // Parse the error - note: browser and driver dependent
            let currentMessage = 0;
            for(let lineNum = 1; lineNum <= lines.length; lineNum++){
                formattedLog += getNumberedLine(lines[lineNum - 1], lineNum, options);
                while(log.length > currentMessage && log[currentMessage].lineNum === lineNum){
                    const message = log[currentMessage++];
                    formattedLog += formatCompilerMessage(message, lines, message.lineNum, {
                        ...options,
                        inlineSource: false
                    });
                }
            }
            return formattedLog;
        case 'issues':
        case 'no':
            // Parse the error - note: browser and driver dependent
            for (const message of shaderLog){
                formattedLog += formatCompilerMessage(message, lines, message.lineNum, {
                    inlineSource: options?.showSourceCode !== 'no'
                });
            }
            return formattedLog;
    }
}
// Helpers
/** Format one message */ function formatCompilerMessage(message, lines, lineNum, options) {
    if (options?.inlineSource) {
        const numberedLines = getNumberedLines(lines, lineNum);
        // If we got error position on line add a `^^^` indicator on next line
        const positionIndicator = message.linePos > 0 ? `${' '.repeat(message.linePos + 5)}^^^\n` : '';
        return `
${numberedLines}${positionIndicator}${message.type.toUpperCase()}: ${message.message}

`;
    }
    const color = message.type === 'error' ? 'red' : '#8B4000'; // dark orange
    return options?.html ? `<div class='luma-compiler-log-error' style="color:${color};"><b> ${message.type.toUpperCase()}: ${message.message}</b></div>` : `${message.type.toUpperCase()}: ${message.message}`;
}
function getNumberedLines(lines, lineNum, options) {
    let numberedLines = '';
    for(let lineIndex = lineNum - 2; lineIndex <= lineNum; lineIndex++){
        const sourceLine = lines[lineIndex - 1];
        if (sourceLine !== undefined) {
            numberedLines += getNumberedLine(sourceLine, lineNum, options);
        }
    }
    return numberedLines;
}
function getNumberedLine(line, lineNum, options) {
    const escapedLine = options?.html ? escapeHTML(line) : line;
    return `${padLeft(String(lineNum), 4)}: ${escapedLine}${options?.html ? '<br/>' : '\n'}`;
}
/**
 * Pads a string with a number of spaces (space characters) to the left
 * @param {String} string - string to pad
 * @param {Number} digits - number of spaces to add
 * @return {String} string - The padded string
 */ function padLeft(string, paddedLength) {
    let result = '';
    for(let i = string.length; i < paddedLength; ++i){
        result += ' ';
    }
    return result + string;
}
function escapeHTML(unsafe) {
    return unsafe.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll('"', '&quot;').replaceAll("'", '&#039;');
} //# sourceMappingURL=format-compiler-log.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/resources/shader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "Shader": (()=>Shader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/resource.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$format$2d$compiler$2d$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter-utils/format-compiler-log.js [app-client] (ecmascript)");
// import { log } from '../../utils/log';
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/uid.js [app-client] (ecmascript)");
;
;
;
class Shader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"] {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"].defaultProps,
        language: 'auto',
        stage: undefined,
        source: '',
        sourceMap: null,
        entryPoint: 'main',
        debugShaders: undefined
    };
    get [Symbol.toStringTag]() {
        return 'Shader';
    }
    /** The stage of this shader */ stage;
    /** The source code of this shader */ source;
    /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */ compilationStatus = 'pending';
    /** Create a new Shader instance */ constructor(device, props){
        props = {
            ...props,
            debugShaders: props.debugShaders || device.props.debugShaders || 'errors'
        };
        super(device, {
            id: getShaderIdFromProps(props),
            ...props
        }, Shader.defaultProps);
        this.stage = this.props.stage;
        this.source = this.props.source;
    }
    /** Get compiler log synchronously (WebGL only) */ getCompilationInfoSync() {
        return null;
    }
    /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */ getTranslatedSource() {
        return null;
    }
    // PORTABLE HELPERS
    /** In browser logging of errors */ async debugShader() {
        const trigger = this.props.debugShaders;
        switch(trigger){
            case 'never':
                return;
            case 'errors':
                // On WebGL - Don't extract the log unless errors
                if (this.compilationStatus === 'success') {
                    return;
                }
                break;
            case 'warnings':
            case 'always':
                break;
        }
        const messages = await this.getCompilationInfo();
        if (trigger === 'warnings' && messages?.length === 0) {
            return;
        }
        this._displayShaderLog(messages);
    }
    // PRIVATE
    /**
     * In-browser UI logging of errors
     * TODO - this HTML formatting code should not be in Device, should be pluggable
     */ _displayShaderLog(messages) {
        // Return if under Node.js / incomplete `document` polyfills
        if (typeof document === 'undefined' || !document?.createElement) {
            return;
        }
        const shaderName = getShaderName(this.source);
        const shaderTitle = `${this.stage} ${shaderName}`;
        let htmlLog = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$format$2d$compiler$2d$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatCompilerLog"])(messages, this.source, {
            showSourceCode: 'all',
            html: true
        });
        // Show translated source if available
        const translatedSource = this.getTranslatedSource();
        if (translatedSource) {
            htmlLog += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${translatedSource}</pre></code>`;
        }
        // Make it clickable so we can copy to clipboard
        const button = document.createElement('Button');
        button.innerHTML = `
<h1>Shader Compilation Error in ${shaderTitle}</h1><br /><br />
<code style="user-select:text;"><pre>
${htmlLog}
</pre></code>`;
        button.style.top = '10px';
        button.style.left = '10px';
        button.style.position = 'absolute';
        button.style.zIndex = '9999';
        button.style.width = '100%';
        button.style.textAlign = 'left';
        document.body.appendChild(button);
        const errors = document.getElementsByClassName('luma-compiler-log-error');
        errors[0]?.scrollIntoView();
        // TODO - add a small embedded copy button (instead of main button)
        button.onclick = ()=>{
            // const source = this.source.replaceAll('\n', '<br />');
            const dataURI = `data:text/plain,${encodeURIComponent(this.source)}`;
            navigator.clipboard.writeText(dataURI);
        };
    // TODO - add a small embedded close button
    }
}
// HELPERS
/** Deduce an id, from shader source, or supplied id, or shader type */ function getShaderIdFromProps(props) {
    return getShaderName(props.source) || props.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])(`unnamed ${props.stage}-shader`);
}
/** Extracts GLSLIFY style naming of shaders: `#define SHADER_NAME ...` */ function getShaderName(shader, defaultName = 'unnamed') {
    const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
    const match = SHADER_NAME_REGEXP.exec(shader);
    return match ? match[1] : defaultName;
} //# sourceMappingURL=shader.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/utils/array-utils-flat.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "getScratchArray": (()=>getScratchArray),
    "getScratchArrayBuffer": (()=>getScratchArrayBuffer)
});
let arrayBuffer;
function getScratchArrayBuffer(byteLength) {
    if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
        arrayBuffer = new ArrayBuffer(byteLength);
    }
    return arrayBuffer;
}
function getScratchArray(Type, length) {
    const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length);
    return new Type(scratchArrayBuffer, 0, length); // arrayBuffer, byteOffset, length (in elements)
} //# sourceMappingURL=array-utils-flat.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/decode-attribute-type.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** Decodes a vertex type, returning byte length and flags (integer, signed, normalized) */ __turbopack_esm__({
    "decodeShaderAttributeType": (()=>decodeShaderAttributeType)
});
function decodeShaderAttributeType(attributeType) {
    const [dataType, components] = TYPE_INFO[attributeType];
    const integer = dataType === 'i32' || dataType === 'u32';
    const signed = dataType !== 'u32';
    const byteLength = TYPE_SIZES[dataType] * components;
    const defaultVertexFormat = getCompatibleVertexFormat(dataType, components);
    return {
        dataType,
        components,
        defaultVertexFormat,
        byteLength,
        integer,
        signed
    };
}
/** Get the "default" vertex format for a certain shader data type */ function getCompatibleVertexFormat(dataType, components) {
    let vertexType;
    switch(dataType){
        case 'f32':
            vertexType = 'float32';
            break;
        case 'i32':
            vertexType = 'sint32';
            break;
        case 'u32':
            vertexType = 'uint32';
            break;
        case 'f16':
            return components <= 2 ? 'float16x2' : 'float16x4';
    }
    // TODO logic does not work for float16
    if (components === 1) {
        return vertexType;
    }
    return `${vertexType}x${components}`;
}
/** All valid shader attribute types. A table guarantees exhaustive list and fast execution */ const TYPE_INFO = {
    f32: [
        'f32',
        1
    ],
    'vec2<f32>': [
        'f32',
        2
    ],
    'vec3<f32>': [
        'f32',
        3
    ],
    'vec4<f32>': [
        'f32',
        4
    ],
    f16: [
        'f16',
        1
    ],
    'vec2<f16>': [
        'f16',
        2
    ],
    'vec3<f16>': [
        'f16',
        3
    ],
    'vec4<f16>': [
        'f16',
        4
    ],
    i32: [
        'i32',
        1
    ],
    'vec2<i32>': [
        'i32',
        2
    ],
    'vec3<i32>': [
        'i32',
        3
    ],
    'vec4<i32>': [
        'i32',
        4
    ],
    u32: [
        'u32',
        1
    ],
    'vec2<u32>': [
        'u32',
        2
    ],
    'vec3<u32>': [
        'u32',
        3
    ],
    'vec4<u32>': [
        'u32',
        4
    ]
};
const TYPE_SIZES = {
    f32: 4,
    f16: 2,
    i32: 4,
    u32: 4
}; //# sourceMappingURL=decode-attribute-type.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/decode-vertex-format.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "decodeVertexFormat": (()=>decodeVertexFormat)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$data$2d$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/decode-data-type.js [app-client] (ecmascript)");
;
function decodeVertexFormat(format) {
    // Strip the -webgl ending if present
    let webglOnly;
    if (format.endsWith('-webgl')) {
        format.replace('-webgl', '');
        webglOnly = true;
    }
    // split components from type
    const [type_, count] = format.split('x');
    const type = type_;
    const components = count ? parseInt(count) : 1;
    // decode the type
    const decodedType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$data$2d$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVertexType"])(type);
    const result = {
        type,
        components,
        byteLength: decodedType.byteLength * components,
        integer: decodedType.integer,
        signed: decodedType.signed,
        normalized: decodedType.normalized
    };
    if (webglOnly) {
        result.webglOnly = true;
    }
    return result;
} //# sourceMappingURL=decode-vertex-format.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter-utils/get-attribute-from-layouts.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "getAttributeInfosByLocation": (()=>getAttributeInfosByLocation),
    "getAttributeInfosFromLayouts": (()=>getAttributeInfosFromLayouts)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$attribute$2d$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/decode-attribute-type.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$vertex$2d$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/decode-vertex-format.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
;
;
;
function getAttributeInfosFromLayouts(shaderLayout, bufferLayout) {
    const attributeInfos = {};
    for (const attribute of shaderLayout.attributes){
        const attributeInfo = getAttributeInfoFromLayouts(shaderLayout, bufferLayout, attribute.name);
        if (attributeInfo) {
            attributeInfos[attribute.name] = attributeInfo;
        }
    }
    return attributeInfos;
}
function getAttributeInfosByLocation(shaderLayout, bufferLayout, maxVertexAttributes = 16) {
    const attributeInfos = getAttributeInfosFromLayouts(shaderLayout, bufferLayout);
    const locationInfos = new Array(maxVertexAttributes).fill(null);
    for (const attributeInfo of Object.values(attributeInfos)){
        locationInfos[attributeInfo.location] = attributeInfo;
    }
    return locationInfos;
}
/**
 * Get the combined information from a shader layout and a buffer layout for a specific attribute
 */ function getAttributeInfoFromLayouts(shaderLayout, bufferLayout, name1) {
    const shaderDeclaration = getAttributeFromShaderLayout(shaderLayout, name1);
    const bufferMapping = getAttributeFromBufferLayout(bufferLayout, name1);
    // TODO should no longer happen
    if (!shaderDeclaration) {
        //  || !bufferMapping
        return null;
    }
    const attributeTypeInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$attribute$2d$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeShaderAttributeType"])(shaderDeclaration.type);
    const vertexFormat = bufferMapping?.vertexFormat || attributeTypeInfo.defaultVertexFormat;
    const vertexFormatInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$vertex$2d$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVertexFormat"])(vertexFormat);
    return {
        attributeName: bufferMapping?.attributeName || shaderDeclaration.name,
        bufferName: bufferMapping?.bufferName || shaderDeclaration.name,
        location: shaderDeclaration.location,
        shaderType: shaderDeclaration.type,
        shaderDataType: attributeTypeInfo.dataType,
        shaderComponents: attributeTypeInfo.components,
        vertexFormat,
        bufferDataType: vertexFormatInfo.type,
        bufferComponents: vertexFormatInfo.components,
        // normalized is a property of the buffer's vertex format
        normalized: vertexFormatInfo.normalized,
        // integer is a property of the shader declaration
        integer: attributeTypeInfo.integer,
        stepMode: bufferMapping?.stepMode || shaderDeclaration.stepMode || 'vertex',
        byteOffset: bufferMapping?.byteOffset || 0,
        byteStride: bufferMapping?.byteStride || 0
    };
}
function getAttributeFromShaderLayout(shaderLayout, name1) {
    const attribute = shaderLayout.attributes.find((attr)=>attr.name === name1);
    if (!attribute) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`shader layout attribute "${name1}" not present in shader`);
    }
    return attribute || null;
}
function getAttributeFromBufferLayout(bufferLayouts, name1) {
    // Check that bufferLayouts are valid (each either has format or attribute)
    checkBufferLayouts(bufferLayouts);
    let bufferLayoutInfo = getAttributeFromShortHand(bufferLayouts, name1);
    if (bufferLayoutInfo) {
        return bufferLayoutInfo;
    }
    bufferLayoutInfo = getAttributeFromAttributesList(bufferLayouts, name1);
    if (bufferLayoutInfo) {
        return bufferLayoutInfo;
    }
    // Didn't find...
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`layout for attribute "${name1}" not present in buffer layout`);
    return null;
}
/** Check that bufferLayouts are valid (each either has format or attribute) */ function checkBufferLayouts(bufferLayouts) {
    for (const bufferLayout of bufferLayouts){
        if (bufferLayout.attributes && bufferLayout.format || !bufferLayout.attributes && !bufferLayout.format) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
        }
    }
}
/** Get attribute from format shorthand if specified */ function getAttributeFromShortHand(bufferLayouts, name1) {
    for (const bufferLayout of bufferLayouts){
        if (bufferLayout.format && bufferLayout.name === name1) {
            return {
                attributeName: bufferLayout.name,
                bufferName: name1,
                stepMode: bufferLayout.stepMode,
                vertexFormat: bufferLayout.format,
                // If offset is needed, use `attributes` field.
                byteOffset: 0,
                byteStride: bufferLayout.byteStride || 0
            };
        }
    }
    return null;
}
/**
 * Search attribute mappings (e.g. interleaved attributes) for buffer mapping.
 * Not the name of the buffer might be the same as one of the interleaved attributes.
 */ function getAttributeFromAttributesList(bufferLayouts, name1) {
    for (const bufferLayout of bufferLayouts){
        let byteStride = bufferLayout.byteStride;
        // Calculate a default byte stride if not provided
        if (typeof bufferLayout.byteStride !== 'number') {
            for (const attributeMapping of bufferLayout.attributes || []){
                const info = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$vertex$2d$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVertexFormat"])(attributeMapping.format);
                // @ts-ignore
                byteStride += info.byteLength;
            }
        }
        const attributeMapping = bufferLayout.attributes?.find((mapping)=>mapping.attribute === name1);
        if (attributeMapping) {
            return {
                attributeName: attributeMapping.attribute,
                bufferName: bufferLayout.name,
                stepMode: bufferLayout.stepMode,
                vertexFormat: attributeMapping.format,
                byteOffset: attributeMapping.byteOffset,
                // @ts-ignore
                byteStride
            };
        }
    }
    return null;
} //# sourceMappingURL=get-attribute-from-layouts.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/resources/vertex-array.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "VertexArray": (()=>VertexArray)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/resource.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$get$2d$attribute$2d$from$2d$layouts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter-utils/get-attribute-from-layouts.js [app-client] (ecmascript)");
;
;
class VertexArray extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"] {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"].defaultProps,
        renderPipeline: null
    };
    get [Symbol.toStringTag]() {
        return 'VertexArray';
    }
    /** Max number of vertex attributes */ maxVertexAttributes;
    /** Attribute infos indexed by location - TODO only needed by webgl module? */ attributeInfos;
    /** Index buffer */ indexBuffer = null;
    /** Attributes indexed by buffer slot */ attributes;
    constructor(device, props){
        super(device, props, VertexArray.defaultProps);
        this.maxVertexAttributes = device.limits.maxVertexAttributes;
        this.attributes = new Array(this.maxVertexAttributes).fill(null);
        const { shaderLayout, bufferLayout } = props.renderPipeline || {};
        if (!shaderLayout || !bufferLayout) {
            throw new Error('VertexArray');
        }
        this.attributeInfos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$get$2d$attribute$2d$from$2d$layouts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttributeInfosByLocation"])(shaderLayout, bufferLayout, this.maxVertexAttributes);
    }
    // DEPRECATED METHODS
    /** @deprecated Set constant attributes (WebGL only) */ setConstantWebGL(location, value) {
        throw new Error('constant attributes not supported');
    }
} //# sourceMappingURL=vertex-array.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/resources/transform-feedback.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "TransformFeedback": (()=>TransformFeedback)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/resource.js [app-client] (ecmascript)");
;
class TransformFeedback extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"] {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"].defaultProps,
        layout: undefined,
        buffers: {}
    };
    get [Symbol.toStringTag]() {
        return 'TransformFeedback';
    }
    constructor(device, props){
        super(device, props, TransformFeedback.defaultProps);
    }
} //# sourceMappingURL=transform-feedback.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/resources/query-set.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "QuerySet": (()=>QuerySet)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/resource.js [app-client] (ecmascript)");
;
class QuerySet extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"] {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"].defaultProps,
        type: undefined,
        count: undefined
    };
    get [Symbol.toStringTag]() {
        return 'QuerySet';
    }
    constructor(device, props){
        super(device, props, QuerySet.defaultProps);
    }
} //# sourceMappingURL=query-set.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/resources/render-pipeline.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// import {normalizeAttributeMap} from '../helpers/attribute-bindings';
__turbopack_esm__({
    "RenderPipeline": (()=>RenderPipeline)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/resource.js [app-client] (ecmascript)");
;
class RenderPipeline extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"] {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"].defaultProps,
        vs: null,
        vertexEntryPoint: 'vertexMain',
        vsConstants: {},
        fs: null,
        fragmentEntryPoint: 'fragmentMain',
        fsConstants: {},
        shaderLayout: null,
        bufferLayout: [],
        topology: 'triangle-list',
        parameters: {},
        // isInstanced: false,
        // instanceCount: 0,
        // vertexCount: 0,
        bindings: {},
        uniforms: {}
    };
    get [Symbol.toStringTag]() {
        return 'RenderPipeline';
    }
    /** The merged layout */ shaderLayout;
    /** Buffer map describing buffer interleaving etc */ bufferLayout;
    /** The linking status of the pipeline. 'pending' if linking is asynchronous, and on production */ linkStatus = 'pending';
    /** The hash of the pipeline */ hash = '';
    constructor(device, props){
        super(device, props, RenderPipeline.defaultProps);
        this.shaderLayout = this.props.shaderLayout;
        this.bufferLayout = this.props.bufferLayout || [];
    }
    // DEPRECATED METHODS
    /**
     * Uniforms
     * @deprecated Use uniforms buffers
     * @note textures, samplers and uniform buffers should be set via `setBindings()`, these are not considered uniforms.
     * @note In WebGL uniforms have a performance penalty, they are reset before each call to enable pipeline sharing.
     */ setUniformsWebGL(uniforms) {
        throw new Error('Use uniform blocks');
    }
} //# sourceMappingURL=render-pipeline.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/resources/render-pass.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// import {Binding} from '../types/shader-layout';
__turbopack_esm__({
    "RenderPass": (()=>RenderPass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/resource.js [app-client] (ecmascript)");
;
class RenderPass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"] {
    /** TODO - should be [0, 0, 0, 0], update once deck.gl tests run clean */ static defaultClearColor = [
        0,
        0,
        0,
        1
    ];
    /** Depth 1.0 represents the far plance */ static defaultClearDepth = 1;
    /** Clears all stencil bits */ static defaultClearStencil = 0;
    /** Default properties for RenderPass */ static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"].defaultProps,
        framebuffer: null,
        parameters: undefined,
        clearColor: RenderPass.defaultClearColor,
        clearColors: undefined,
        clearDepth: RenderPass.defaultClearDepth,
        clearStencil: RenderPass.defaultClearStencil,
        depthReadOnly: false,
        stencilReadOnly: false,
        discard: false,
        occlusionQuerySet: undefined,
        timestampQuerySet: undefined,
        beginTimestampIndex: undefined,
        endTimestampIndex: undefined
    };
    get [Symbol.toStringTag]() {
        return 'RenderPass';
    }
    constructor(device, props){
        props = RenderPass.normalizeProps(device, props);
        super(device, props, RenderPass.defaultProps);
    }
    static normalizeProps(device, props) {
        // Intended to override e.g. set default clear values to true
        const overriddenDefaultProps = device.props._resourceDefaults?.renderPass;
        const newProps = {
            ...overriddenDefaultProps,
            ...props
        };
        return newProps;
    }
} // TODO - Can we align WebGL implementation with WebGPU API?
 // In WebGPU the following methods are on the renderpass instead of the renderpipeline
 // luma.gl keeps them on the pipeline for now, but that has some issues.
 // abstract setPipeline(pipeline: RenderPipeline): void {}
 // abstract setIndexBuffer()
 // abstract setVertexBuffer(slot: number, buffer: Buffer, offset: number): void;
 // abstract setBindings(bindings: Record<string, Binding>): void;
 // abstract setParameters(parameters: RenderPassParameters);
 // abstract draw(options: {
 // abstract drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: number): void;
 // abstract drawIndexedIndirect(indirectBuffer: GPUBuffer, indirectOffset: number): void;
 //# sourceMappingURL=render-pass.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/resources/command-buffer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "CommandBuffer": (()=>CommandBuffer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/resource.js [app-client] (ecmascript)");
;
class CommandBuffer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"] {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"].defaultProps
    };
    get [Symbol.toStringTag]() {
        return 'CommandBuffer';
    }
    constructor(device, props){
        super(device, props, CommandBuffer.defaultProps);
    }
} //# sourceMappingURL=command-buffer.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/resources/command-encoder.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "CommandEncoder": (()=>CommandEncoder)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/resource.js [app-client] (ecmascript)");
;
class CommandEncoder extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"] {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"].defaultProps,
        measureExecutionTime: undefined
    };
    get [Symbol.toStringTag]() {
        return 'CommandEncoder';
    }
    constructor(device, props){
        super(device, props, CommandEncoder.defaultProps);
    }
} //# sourceMappingURL=command-encoder.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/adapter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 * Create and attach devices for a specific backend.
 */ __turbopack_esm__({
    "Adapter": (()=>Adapter)
});
class Adapter {
} //# sourceMappingURL=adapter.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/luma.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "Luma": (()=>Luma),
    "luma": (()=>luma)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@probe.gl/env/dist/lib/is-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/device.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$stats$2d$manager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/stats-manager.js [app-client] (ecmascript)");
;
;
;
;
const isPage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBrowser"])() && typeof document !== 'undefined';
const isPageLoaded = ()=>isPage && document.readyState === 'complete';
const STARTUP_MESSAGE = 'set luma.log.level=1 (or higher) to trace rendering';
const ERROR_MESSAGE = 'No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.';
class Luma {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Device"].defaultProps,
        type: 'best-available',
        adapters: undefined,
        waitForPageLoad: true
    };
    /**
     * Page load promise
     * Get a 'lazy' promise that resolves when the DOM is loaded.
     * @note Since there may be limitations on number of `load` event listeners,
     * it is recommended avoid calling this function until actually needed.
     * I.e. don't call it until you know that you will be looking up a string in the DOM.
     */ static pageLoaded = getPageLoadPromise().then(()=>{
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].probe(2, 'DOM is loaded')();
    });
    /** Global stats for all devices */ stats = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$stats$2d$manager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lumaStats"];
    /**
     * Global log
     *
     * Assign luma.log.level in console to control logging: \
     * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs
     * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;
     */ log = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"];
    /** Version of luma.gl */ VERSION = // Version detection using build plugin
    // @ts-expect-error no-undef
    typeof "9.1.2" !== 'undefined' ? "9.1.2" : 'running from source';
    spector;
    preregisteredAdapters = new Map();
    constructor(){
        if (globalThis.luma) {
            if (globalThis.luma.VERSION !== this.VERSION) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)();
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].error(`'yarn why @luma.gl/core' can help identify the source of the conflict`)();
                throw new Error(`luma.gl - multiple versions detected: see console log`);
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].error('This version of luma.gl has already been initialized')();
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].log(1, `${this.VERSION} - ${STARTUP_MESSAGE}`)();
        globalThis.luma = this;
    }
    registerAdapters(adapters) {
        for (const deviceClass of adapters){
            this.preregisteredAdapters.set(deviceClass.type, deviceClass);
        }
    }
    /** Get type strings for supported Devices */ getSupportedAdapters(adapters = []) {
        const adapterMap = this.getAdapterMap(adapters);
        return Array.from(adapterMap).map(([, adapter])=>adapter).filter((adapter)=>adapter.isSupported?.()).map((adapter)=>adapter.type);
    }
    /** Get type strings for best available Device */ getBestAvailableAdapter(adapters = []) {
        const adapterMap = this.getAdapterMap(adapters);
        if (adapterMap.get('webgpu')?.isSupported?.()) {
            return 'webgpu';
        }
        if (adapterMap.get('webgl')?.isSupported?.()) {
            return 'webgl';
        }
        return null;
    }
    setDefaultDeviceProps(props) {
        Object.assign(Luma.defaultProps, props);
    }
    /** Creates a device. Asynchronously. */ async createDevice(props = {}) {
        props = {
            ...Luma.defaultProps,
            ...props
        };
        if (props.waitForPageLoad) {
            // || props.createCanvasContext) {
            await Luma.pageLoaded;
        }
        const adapterMap = this.getAdapterMap(props.adapters);
        let type = props.type || '';
        if (type === 'best-available') {
            type = this.getBestAvailableAdapter(props.adapters) || type;
        }
        const adapters = this.getAdapterMap(props.adapters) || adapterMap;
        const adapter = adapters.get(type);
        const device = await adapter?.create?.(props);
        if (device) {
            return device;
        }
        throw new Error(ERROR_MESSAGE);
    }
    /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */ async attachDevice(props) {
        const adapters = this.getAdapterMap(props.adapters);
        // WebGL
        let type = '';
        if (props.handle instanceof WebGL2RenderingContext) {
            type = 'webgl';
        }
        if (props.createCanvasContext) {
            await Luma.pageLoaded;
        }
        // TODO - WebGPU does not yet have a stable API
        // if (props.handle instanceof GPUDevice) {
        //   const WebGPUDevice = adapters.get('webgpu') as any;
        //   if (WebGPUDevice) {
        //     return (await WebGPUDevice.attach(props.handle)) as Device;
        //   }
        // }
        // null
        if (props.handle === null) {
            type = 'unknown';
        }
        const adapter = adapters.get(type);
        const device = await adapter?.attach?.(null);
        if (device) {
            return device;
        }
        throw new Error(ERROR_MESSAGE);
    }
    /**
     * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.
     * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.
     */ enforceWebGL2(enforce = true, adapters = []) {
        const adapterMap = this.getAdapterMap(adapters);
        const webgl2Adapter = adapterMap.get('webgl');
        if (!webgl2Adapter) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn('enforceWebGL2: webgl adapter not found')();
        }
        webgl2Adapter?.enforceWebGL2?.(enforce);
    }
    /** Convert a list of adapters to a map */ getAdapterMap(adapters = []) {
        const map = new Map(this.preregisteredAdapters);
        for (const adapter of adapters){
            map.set(adapter.type, adapter);
        }
        return map;
    }
    // DEPRECATED
    /** @deprecated Use registerAdapters */ registerDevices(deviceClasses) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn('luma.registerDevices() is deprecated, use luma.registerAdapters() instead');
        for (const deviceClass of deviceClasses){
            const adapter = deviceClass.adapter;
            if (adapter) {
                this.preregisteredAdapters.set(adapter.type, adapter);
            }
        }
    }
}
const luma = new Luma();
// HELPER FUNCTIONS
/** Returns a promise that resolves when the page is loaded */ function getPageLoadPromise() {
    if (isPageLoaded() || typeof window === 'undefined') {
        return Promise.resolve();
    }
    return new Promise((resolve)=>{
        window.addEventListener('load', ()=>resolve());
    });
} //# sourceMappingURL=luma.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter/resources/compute-pipeline.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "ComputePipeline": (()=>ComputePipeline)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/resource.js [app-client] (ecmascript)");
;
class ComputePipeline extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"] {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resource"].defaultProps,
        shader: undefined,
        entryPoint: undefined,
        constants: {},
        shaderLayout: undefined
    };
    get [Symbol.toStringTag]() {
        return 'ComputePipeline';
    }
    hash = '';
    /** The merged shader layout */ shaderLayout;
    constructor(device, props){
        super(device, props, ComputePipeline.defaultProps);
        this.shaderLayout = props.shaderLayout;
    }
} //# sourceMappingURL=compute-pipeline.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/vertex-format-from-attribute.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "getDataTypeFromTypedArray": (()=>getDataTypeFromTypedArray),
    "getTypedArrayFromDataType": (()=>getTypedArrayFromDataType),
    "getVertexFormatFromAttribute": (()=>getVertexFormatFromAttribute)
});
function getDataTypeFromTypedArray(arrayOrType) {
    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch(type){
        case Float32Array:
            return 'float32';
        case Uint16Array:
            return 'uint16';
        case Uint32Array:
            return 'uint32';
        case Uint8Array:
        case Uint8ClampedArray:
            return 'uint8';
        case Int8Array:
            return 'sint8';
        case Int16Array:
            return 'sint16';
        case Int32Array:
            return 'sint32';
        default:
            // Failed to deduce data type from typed array
            throw new Error(type.constructor.name);
    }
}
function getTypedArrayFromDataType(dataType) {
    switch(dataType){
        case 'float32':
            return Float32Array;
        case 'uint32':
            return Uint32Array;
        case 'sint32':
            return Int32Array;
        case 'uint16':
        case 'unorm16':
            return Uint16Array;
        case 'sint16':
        case 'snorm16':
            return Int16Array;
        case 'uint8':
        case 'unorm8':
            return Uint8Array;
        case 'sint8':
        case 'snorm8':
            return Int8Array;
        default:
            // Failed to deduce typed array from data type
            throw new Error(dataType);
    }
}
function getVertexFormatFromAttribute(typedArray, size, normalized) {
    if (!size || size > 4) {
        throw new Error(`size ${size}`);
    }
    const components = size;
    let dataType = getDataTypeFromTypedArray(typedArray);
    // TODO - Special cases for WebGL (not supported on WebGPU), overrides the check below
    if (dataType === 'uint8' && normalized && components === 1) {
        return 'unorm8-webgl';
    }
    if (dataType === 'uint8' && normalized && components === 3) {
        return 'unorm8x3-webgl';
    }
    if (dataType === 'uint8' || dataType === 'sint8') {
        if (components === 1 || components === 3) {
            // WebGPU 8 bit formats must be aligned to 16 bit boundaries');
            throw new Error(`size: ${size}`);
        }
        if (normalized) {
            dataType = dataType.replace('int', 'norm');
        }
        return `${dataType}x${components}`;
    }
    if (dataType === 'uint16' || dataType === 'sint16') {
        if (components === 1 || components === 3) {
            // WebGPU 16 bit formats must be aligned to 32 bit boundaries
            throw new Error(`size: ${size}`);
        }
        if (normalized) {
            dataType = dataType.replace('int', 'norm');
        }
        return `${dataType}x${components}`;
    }
    if (components === 1) {
        return dataType;
    }
    return `${dataType}x${components}`;
} //# sourceMappingURL=vertex-format-from-attribute.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter-utils/buffer-layout-helper.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** BufferLayoutHelper is a helper class that should not be used directly by applications */ __turbopack_esm__({
    "BufferLayoutHelper": (()=>BufferLayoutHelper)
});
class BufferLayoutHelper {
    bufferLayouts;
    constructor(bufferLayouts){
        this.bufferLayouts = bufferLayouts;
    }
    getBufferLayout(name) {
        return this.bufferLayouts.find((layout)=>layout.name === name) || null;
    }
    /** Get attribute names from a BufferLayout */ getAttributeNamesForBuffer(bufferLayout) {
        return bufferLayout.attributes ? bufferLayout.attributes?.map((layout)=>layout.attribute) : [
            bufferLayout.name
        ];
    }
    mergeBufferLayouts(bufferLayouts1, bufferLayouts2) {
        const mergedLayouts = [
            ...bufferLayouts1
        ];
        for (const attribute of bufferLayouts2){
            const index = mergedLayouts.findIndex((attribute2)=>attribute2.name === attribute.name);
            if (index < 0) {
                mergedLayouts.push(attribute);
            } else {
                mergedLayouts[index] = attribute;
            }
        }
        return mergedLayouts;
    }
} //# sourceMappingURL=buffer-layout-helper.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/adapter-utils/buffer-layout-helper.js [app-client] (ecmascript) <export BufferLayoutHelper as _BufferLayoutHelper>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "_BufferLayoutHelper": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$buffer$2d$layout$2d$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferLayoutHelper"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$buffer$2d$layout$2d$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter-utils/buffer-layout-helper.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/decode-shader-types.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "alignTo": (()=>alignTo),
    "decodeShaderUniformType": (()=>decodeShaderUniformType)
});
const UNIFORM_FORMATS = {
    f32: {
        type: 'f32',
        components: 1
    },
    i32: {
        type: 'i32',
        components: 1
    },
    u32: {
        type: 'u32',
        components: 1
    },
    // 'bool-webgl': {type: 'bool-webgl', components: 1},
    'vec2<f32>': {
        type: 'f32',
        components: 2
    },
    'vec3<f32>': {
        type: 'f32',
        components: 3
    },
    'vec4<f32>': {
        type: 'f32',
        components: 4
    },
    'vec2<i32>': {
        type: 'i32',
        components: 2
    },
    'vec3<i32>': {
        type: 'i32',
        components: 3
    },
    'vec4<i32>': {
        type: 'i32',
        components: 4
    },
    'vec2<u32>': {
        type: 'u32',
        components: 2
    },
    'vec3<u32>': {
        type: 'u32',
        components: 3
    },
    'vec4<u32>': {
        type: 'u32',
        components: 4
    },
    'mat2x2<f32>': {
        type: 'f32',
        components: 4
    },
    'mat2x3<f32>': {
        type: 'f32',
        components: 6
    },
    'mat2x4<f32>': {
        type: 'f32',
        components: 8
    },
    'mat3x2<f32>': {
        type: 'f32',
        components: 6
    },
    'mat3x3<f32>': {
        type: 'f32',
        components: 9
    },
    'mat3x4<f32>': {
        type: 'f32',
        components: 12
    },
    'mat4x2<f32>': {
        type: 'f32',
        components: 8
    },
    'mat4x3<f32>': {
        type: 'f32',
        components: 12
    },
    'mat4x4<f32>': {
        type: 'f32',
        components: 16
    }
};
function decodeShaderUniformType(format) {
    const decoded = UNIFORM_FORMATS[format];
    return decoded;
}
function alignTo(size, count) {
    // prettier-ignore
    switch(count){
        case 1:
            return size; // Pad upwards to even multiple of 2
        case 2:
            return size + size % 2; // Pad upwards to even multiple of 2
        default:
            return size + (4 - size % 4) % 4; // Pad upwards to even multiple of 4
    }
} //# sourceMappingURL=decode-shader-types.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/utils/is-array.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 * Check is an array is a typed array
 * @param value value to be tested
 * @returns input as TypedArray, or null
 * @todo this should be provided by @math.gl/types
 */ __turbopack_esm__({
    "isNumberArray": (()=>isNumberArray),
    "isTypedArray": (()=>isTypedArray)
});
function isTypedArray(value) {
    return ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function isNumberArray(value) {
    if (Array.isArray(value)) {
        return value.length === 0 || typeof value[0] === 'number';
    }
    return isTypedArray(value);
} //# sourceMappingURL=is-array.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/portable/uniform-buffer-layout.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "UniformBufferLayout": (()=>UniformBufferLayout)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$shader$2d$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/decode-shader-types.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$array$2d$utils$2d$flat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/array-utils-flat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$is$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/is-array.js [app-client] (ecmascript)");
;
;
;
;
/**
 * Smallest buffer size that can be used for uniform buffers.
 * TODO - does this depend on device?
 */ const minBufferSize = 1024;
class UniformBufferLayout {
    layout = {};
    /** number of bytes needed for buffer allocation */ byteLength;
    /** Create a new UniformBufferLayout given a map of attributes. */ constructor(uniformTypes){
        /** number of 4 byte slots taken */ let size = 0;
        // Add layout (type, size and offset) definitions for each uniform in the layout
        for (const [key, uniformType] of Object.entries(uniformTypes)){
            const typeAndComponents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$shader$2d$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeShaderUniformType"])(uniformType);
            const { type, components: count } = typeAndComponents;
            // First, align (bump) current offset to an even multiple of current object (1, 2, 4)
            size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$shader$2d$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["alignTo"])(size, count);
            // Use the aligned size as the offset of the current uniform.
            const offset = size;
            // Then, add our object's padded size ((1, 2, multiple of 4) to the current offset
            size += count;
            this.layout[key] = {
                type,
                size: count,
                offset
            };
        }
        size += (4 - size % 4) % 4;
        const actualByteLength = size * 4;
        this.byteLength = Math.max(actualByteLength, minBufferSize);
    }
    /** Get the data for the complete buffer */ getData(uniformValues) {
        const bufferSize = Math.max(this.byteLength, minBufferSize);
        // Allocate three typed arrays pointing at same memory
        const arrayBuffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$array$2d$utils$2d$flat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getScratchArrayBuffer"])(bufferSize);
        const typedArrays = {
            i32: new Int32Array(arrayBuffer),
            u32: new Uint32Array(arrayBuffer),
            f32: new Float32Array(arrayBuffer),
            // TODO not implemented
            f16: new Uint16Array(arrayBuffer)
        };
        // TODO is this needed?
        // typedArrays.i32.fill(0);
        for (const [name, value] of Object.entries(uniformValues)){
            const uniformLayout = this.layout[name];
            if (!uniformLayout) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`Supplied uniform value ${name} not present in uniform block layout`)();
                continue;
            }
            const { type, size, offset } = uniformLayout;
            const typedArray = typedArrays[type];
            if (size === 1) {
                if (typeof value !== 'number' && typeof value !== 'boolean') {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`Supplied value for single component uniform ${name} is not a number: ${value}`)();
                    continue;
                }
                // single value -> just set it
                typedArray[offset] = Number(value);
            } else {
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$is$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberArray"])(value)) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`Supplied value for multi component / array uniform ${name} is not a numeric array: ${value}`)();
                    continue;
                }
                // vector/matrix -> copy the supplied (typed) array, starting from offset
                // TODO: we should limit or check size in case the supplied data overflows
                typedArray.set(value, offset);
            }
        }
        return new Uint8Array(arrayBuffer);
    }
    /** Does this layout have a field with specified name */ has(name) {
        return Boolean(this.layout[name]);
    }
    /** Get offset and size for a field with specified name */ get(name) {
        const layout = this.layout[name];
        return layout;
    }
} //# sourceMappingURL=uniform-buffer-layout.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/utils/array-equal.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "arrayCopy": (()=>arrayCopy),
    "arrayEqual": (()=>arrayEqual)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$is$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/is-array.js [app-client] (ecmascript)");
;
function arrayEqual(a, b, limit = 16) {
    if (a !== b) {
        return false;
    }
    const arrayA = a;
    const arrayB = b;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$is$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberArray"])(arrayA)) {
        return false;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$is$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberArray"])(arrayB) && arrayA.length === arrayB.length) {
        for(let i = 0; i < arrayA.length; ++i){
            if (arrayB[i] !== arrayA[i]) {
                return false;
            }
        }
    }
    return true;
}
function arrayCopy(a) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$is$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberArray"])(a)) {
        return a.slice();
    }
    return a;
} //# sourceMappingURL=array-equal.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/portable/uniform-block.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "UniformBlock": (()=>UniformBlock)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$array$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/array-equal.js [app-client] (ecmascript)");
;
class UniformBlock {
    name;
    uniforms = {};
    modifiedUniforms = {};
    modified = true;
    bindingLayout = {};
    needsRedraw = 'initialized';
    constructor(props){
        this.name = props?.name || 'unnamed';
        // TODO - Extract uniform layout from the shaderLayout object
        if (props?.name && props?.shaderLayout) {
            const binding = props?.shaderLayout.bindings?.find((binding_)=>binding_.type === 'uniform' && binding_.name === props?.name);
            if (!binding) {
                throw new Error(props?.name);
            }
            const uniformBlock = binding;
            for (const uniform of uniformBlock.uniforms || []){
                this.bindingLayout[uniform.name] = uniform;
            }
        }
    }
    /** Set a map of uniforms */ setUniforms(uniforms) {
        for (const [key, value] of Object.entries(uniforms)){
            this._setUniform(key, value);
            if (!this.needsRedraw) {
                this.setNeedsRedraw(`${this.name}.${key}=${value}`);
            }
        }
    }
    setNeedsRedraw(reason) {
        this.needsRedraw = this.needsRedraw || reason;
    }
    /** Returns all uniforms */ getAllUniforms() {
        // @ts-expect-error
        this.modifiedUniforms = {};
        this.needsRedraw = false;
        return this.uniforms || {};
    }
    /** Set a single uniform */ _setUniform(key, value) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$array$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayEqual"])(this.uniforms[key], value)) {
            return;
        }
        this.uniforms[key] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$array$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayCopy"])(value);
        this.modifiedUniforms[key] = true;
        this.modified = true;
    }
} //# sourceMappingURL=uniform-block.js.map
}}),
"[project]/node_modules/@luma.gl/core/dist/portable/uniform-store.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "UniformStore": (()=>UniformStore)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$portable$2f$uniform$2d$buffer$2d$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/portable/uniform-buffer-layout.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$portable$2f$uniform$2d$block$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/portable/uniform-block.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
;
;
;
;
class UniformStore {
    /** Stores the uniform values for each uniform block */ uniformBlocks = new Map();
    /** Can generate data for a uniform buffer for each block from data */ uniformBufferLayouts = new Map();
    /** Actual buffer for the blocks */ uniformBuffers = new Map();
    /**
     * Create a new UniformStore instance
     * @param blocks
     */ constructor(blocks){
        for (const [bufferName, block] of Object.entries(blocks)){
            const uniformBufferName = bufferName;
            // Create a layout object to help us generate correctly formatted binary uniform buffers
            const uniformBufferLayout = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$portable$2f$uniform$2d$buffer$2d$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UniformBufferLayout"](block.uniformTypes || {});
            this.uniformBufferLayouts.set(uniformBufferName, uniformBufferLayout);
            // Create a Uniform block to store the uniforms for each buffer.
            const uniformBlock = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$portable$2f$uniform$2d$block$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UniformBlock"]({
                name: bufferName
            });
            uniformBlock.setUniforms(block.defaultUniforms || {});
            this.uniformBlocks.set(uniformBufferName, uniformBlock);
        }
    }
    /** Destroy any managed uniform buffers */ destroy() {
        for (const uniformBuffer of this.uniformBuffers.values()){
            uniformBuffer.destroy();
        }
    }
    /**
     * Set uniforms
     * Makes all properties partial
     */ setUniforms(uniforms) {
        for (const [blockName, uniformValues] of Object.entries(uniforms)){
            this.uniformBlocks.get(blockName)?.setUniforms(uniformValues);
        // We leverage logging in updateUniformBuffers(), even though slightly less efficient
        // this.updateUniformBuffer(blockName);
        }
        this.updateUniformBuffers();
    }
    /** Get the required minimum length of the uniform buffer */ getUniformBufferByteLength(uniformBufferName) {
        return this.uniformBufferLayouts.get(uniformBufferName)?.byteLength || 0;
    }
    /** Get formatted binary memory that can be uploaded to a buffer */ getUniformBufferData(uniformBufferName) {
        const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms() || {};
        // @ts-ignore
        return this.uniformBufferLayouts.get(uniformBufferName)?.getData(uniformValues);
    }
    /**
     * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)
     * The new buffer is initialized with current / supplied values
     */ createUniformBuffer(device, uniformBufferName, uniforms) {
        if (uniforms) {
            this.setUniforms(uniforms);
        }
        const byteLength = this.getUniformBufferByteLength(uniformBufferName);
        const uniformBuffer = device.createBuffer({
            usage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].UNIFORM | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].COPY_DST,
            byteLength
        });
        // Note that this clears the needs redraw flag
        const uniformBufferData = this.getUniformBufferData(uniformBufferName);
        uniformBuffer.write(uniformBufferData);
        return uniformBuffer;
    }
    /** Get the managed uniform buffer. "managed" resources are destroyed when the uniformStore is destroyed. */ getManagedUniformBuffer(device, uniformBufferName) {
        if (!this.uniformBuffers.get(uniformBufferName)) {
            const byteLength = this.getUniformBufferByteLength(uniformBufferName);
            const uniformBuffer = device.createBuffer({
                usage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].UNIFORM | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].COPY_DST,
                byteLength
            });
            this.uniformBuffers.set(uniformBufferName, uniformBuffer);
        }
        // this.updateUniformBuffers();
        // @ts-ignore
        return this.uniformBuffers.get(uniformBufferName);
    }
    /** Updates all uniform buffers where values have changed */ updateUniformBuffers() {
        let reason = false;
        for (const uniformBufferName of this.uniformBlocks.keys()){
            const bufferReason = this.updateUniformBuffer(uniformBufferName);
            reason ||= bufferReason;
        }
        if (reason) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].log(3, `UniformStore.updateUniformBuffers(): ${reason}`)();
        }
        return reason;
    }
    /** Update one uniform buffer. Only updates if values have changed */ updateUniformBuffer(uniformBufferName) {
        const uniformBlock = this.uniformBlocks.get(uniformBufferName);
        let uniformBuffer = this.uniformBuffers.get(uniformBufferName);
        let reason = false;
        if (uniformBuffer && uniformBlock?.needsRedraw) {
            reason ||= uniformBlock.needsRedraw;
            // This clears the needs redraw flag
            const uniformBufferData = this.getUniformBufferData(uniformBufferName);
            uniformBuffer = this.uniformBuffers.get(uniformBufferName);
            uniformBuffer?.write(uniformBufferData);
            // logging - TODO - don't query the values unnecessarily
            const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].log(4, `Writing to uniform buffer ${String(uniformBufferName)}`, uniformBufferData, uniformValues)();
        }
        return reason;
    }
} //# sourceMappingURL=uniform-store.js.map
}}),
}]);

//# sourceMappingURL=node_modules_%40luma_gl_core_dist_f0a10f._.js.map