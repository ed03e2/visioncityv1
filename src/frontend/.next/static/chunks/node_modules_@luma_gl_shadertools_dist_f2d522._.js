(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@luma_gl_shadertools_dist_f2d522._.js", {

"[project]/node_modules/@luma.gl/shadertools/dist/modules/math/fp32/fp32.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// import {ShaderModule} from '../../types';
__turbopack_esm__({
    "fp32": (()=>fp32)
});
const fp32shader = /* glsl */ `\
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND

// All these functions are for substituting tan() function from Intel GPU only
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }

    // 2pi range reduction
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`;
const fp32 = {
    name: 'fp32',
    vs: fp32shader
}; //# sourceMappingURL=fp32.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/engine/picking/picking.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// cyan color
__turbopack_esm__({
    "picking": (()=>picking)
});
const DEFAULT_HIGHLIGHT_COLOR = [
    0,
    1,
    1,
    1
];
const vs = /* glsl */ `\
uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

out vec4 picking_vRGBcolor_Avalid;

// Normalize unsigned byte color to 0-1 range
vec3 picking_normalizeColor(vec3 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

// Normalize unsigned byte color to 0-1 range
vec4 picking_normalizeColor(vec4 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

bool picking_isColorZero(vec3 color) {
  return dot(color, vec3(1.0)) < 0.00001;
}

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.00001;
}

// Check if this vertex is highlighted 
bool isVertexHighlighted(vec3 vertexColor) {
  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
  return
    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}

// Set the current picking color
void picking_setPickingColor(vec3 pickingColor) {
  pickingColor = picking_normalizeColor(pickingColor);

  if (bool(picking.isActive)) {
    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!bool(picking.isAttribute)) {
      // Stores the picking color so that the fragment shader can render it during picking
      picking_vRGBcolor_Avalid.rgb = pickingColor;
    }
  } else {
    // Do the comparison with selected item color in vertex shader as it should mean fewer compares
    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.r = value;
  }
}

void picking_setPickingAttribute(vec2 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}

void picking_setPickingAttribute(vec3 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`;
const fs = /* glsl */ `\
uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

in vec4 picking_vRGBcolor_Avalid;

/*
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  // If we are still picking, we don't highlight
  if (picking.isActive > 0.5) {
    return color;
  }

  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    // Blend in highlight color based on its alpha value
    float highLightAlpha = picking.highlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
vec4 picking_filterPickingColor(vec4 color) {
  if (bool(picking.isActive)) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 highlightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highlightColor);
}
`;
const picking = {
    props: {},
    uniforms: {},
    name: 'picking',
    uniformTypes: {
        isActive: 'f32',
        isAttribute: 'f32',
        isHighlightActive: 'f32',
        useFloatColors: 'f32',
        highlightedObjectColor: 'vec3<f32>',
        highlightColor: 'vec4<f32>'
    },
    defaultUniforms: {
        isActive: false,
        isAttribute: false,
        isHighlightActive: false,
        useFloatColors: true,
        highlightedObjectColor: [
            0,
            0,
            0
        ],
        highlightColor: DEFAULT_HIGHLIGHT_COLOR
    },
    vs,
    fs,
    getUniforms
};
function getUniforms(opts = {}, prevUniforms) {
    const uniforms = {};
    if (opts.highlightedObjectColor === undefined) {
    // Unless highlightedObjectColor explicitly null or set, do not update state
    } else if (opts.highlightedObjectColor === null) {
        uniforms.isHighlightActive = false;
    } else {
        uniforms.isHighlightActive = true;
        const highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3);
        uniforms.highlightedObjectColor = highlightedObjectColor;
    }
    if (opts.highlightColor) {
        const color = Array.from(opts.highlightColor, (x)=>x / 255);
        if (!Number.isFinite(color[3])) {
            color[3] = 1;
        }
        uniforms.highlightColor = color;
    }
    if (opts.isActive !== undefined) {
        uniforms.isActive = Boolean(opts.isActive);
        uniforms.isAttribute = Boolean(opts.isAttribute);
    }
    if (opts.useFloatColors !== undefined) {
        uniforms.useFloatColors = Boolean(opts.useFloatColors);
    }
    return uniforms;
} //# sourceMappingURL=picking.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/module-injectors.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "MODULE_INJECTORS_FS": (()=>MODULE_INJECTORS_FS),
    "MODULE_INJECTORS_VS": (()=>MODULE_INJECTORS_VS)
});
const MODULE_INJECTORS_VS = /* glsl */ `\
#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`;
const MODULE_INJECTORS_FS = /* glsl */ `\
#ifdef MODULE_MATERIAL
  fragColor = material_filterColor(fragColor);
#endif

#ifdef MODULE_LIGHTING
  fragColor = lighting_filterColor(fragColor);
#endif

#ifdef MODULE_FOG
  fragColor = fog_filterColor(fragColor);
#endif

#ifdef MODULE_PICKING
  fragColor = picking_filterHighlightColor(fragColor);
  fragColor = picking_filterPickingColor(fragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`; //# sourceMappingURL=module-injectors.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/utils/assert.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Recommendation is to ignore message but current test suite checks agains the
// message so keep it for now.
__turbopack_esm__({
    "assert": (()=>assert)
});
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || 'shadertools: assertion failed.');
    }
} //# sourceMappingURL=assert.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-injections.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "DECLARATION_INJECT_MARKER": (()=>DECLARATION_INJECT_MARKER),
    "combineInjects": (()=>combineInjects),
    "injectShader": (()=>injectShader),
    "normalizeInjections": (()=>normalizeInjections)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$module$2d$injectors$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/module-injectors.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$utils$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/utils/assert.js [app-client] (ecmascript)");
;
;
// TODO - experimental
const MODULE_INJECTORS = {
    vertex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$module$2d$injectors$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MODULE_INJECTORS_VS"],
    fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$module$2d$injectors$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MODULE_INJECTORS_FS"]
};
const REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/; // Beginning of main
const REGEX_END_OF_MAIN = /}\n?[^{}]*$/; // End of main, assumes main is last function
const fragments = [];
const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__';
function normalizeInjections(injections) {
    const result = {
        vertex: {},
        fragment: {}
    };
    for(const hook in injections){
        let injection = injections[hook];
        const stage = getHookStage(hook);
        if (typeof injection === 'string') {
            injection = {
                order: 0,
                injection
            };
        }
        result[stage][hook] = injection;
    }
    return result;
}
function getHookStage(hook) {
    const type = hook.slice(0, 2);
    switch(type){
        case 'vs':
            return 'vertex';
        case 'fs':
            return 'fragment';
        default:
            throw new Error(type);
    }
}
function injectShader(source, stage, inject, injectStandardStubs = false) {
    const isVertex = stage === 'vertex';
    for(const key in inject){
        const fragmentData = inject[key];
        fragmentData.sort((a, b)=>a.order - b.order);
        fragments.length = fragmentData.length;
        for(let i = 0, len = fragmentData.length; i < len; ++i){
            fragments[i] = fragmentData[i].injection;
        }
        const fragmentString = `${fragments.join('\n')}\n`;
        switch(key){
            // declarations are injected before the main function
            case 'vs:#decl':
                if (isVertex) {
                    source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
                }
                break;
            // inject code at the beginning of the main function
            case 'vs:#main-start':
                if (isVertex) {
                    source = source.replace(REGEX_START_OF_MAIN, (match)=>match + fragmentString);
                }
                break;
            // inject code at the end of main function
            case 'vs:#main-end':
                if (isVertex) {
                    source = source.replace(REGEX_END_OF_MAIN, (match)=>fragmentString + match);
                }
                break;
            // declarations are injected before the main function
            case 'fs:#decl':
                if (!isVertex) {
                    source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
                }
                break;
            // inject code at the beginning of the main function
            case 'fs:#main-start':
                if (!isVertex) {
                    source = source.replace(REGEX_START_OF_MAIN, (match)=>match + fragmentString);
                }
                break;
            // inject code at the end of main function
            case 'fs:#main-end':
                if (!isVertex) {
                    source = source.replace(REGEX_END_OF_MAIN, (match)=>fragmentString + match);
                }
                break;
            default:
                // TODO(Tarek): I think this usage should be deprecated.
                // inject code after key, leaving key in place
                source = source.replace(key, (match)=>match + fragmentString);
        }
    }
    // Remove if it hasn't already been replaced
    source = source.replace(DECLARATION_INJECT_MARKER, '');
    // Finally, if requested, insert an automatic module injector chunk
    if (injectStandardStubs) {
        source = source.replace(/\}\s*$/, (match)=>match + MODULE_INJECTORS[stage]);
    }
    return source;
}
function combineInjects(injects) {
    const result = {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$utils$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(Array.isArray(injects) && injects.length > 1);
    injects.forEach((inject)=>{
        for(const key in inject){
            result[key] = result[key] ? `${result[key]}\n${inject[key]}` : inject[key];
        }
    });
    return result;
} //# sourceMappingURL=shader-injections.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/filters/prop-types.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "getValidatedProperties": (()=>getValidatedProperties),
    "makePropValidators": (()=>makePropValidators)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$utils$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/utils/assert.js [app-client] (ecmascript)");
;
/** Minimal validators for number and array types */ const DEFAULT_PROP_VALIDATORS = {
    number: {
        type: 'number',
        validate (value, propType) {
            return Number.isFinite(value) && typeof propType === 'object' && (propType.max === undefined || value <= propType.max) && (propType.min === undefined || value >= propType.min);
        }
    },
    array: {
        type: 'array',
        validate (value, propType) {
            return Array.isArray(value) || ArrayBuffer.isView(value);
        }
    }
};
function makePropValidators(propTypes) {
    const propValidators = {};
    for (const [name, propType] of Object.entries(propTypes)){
        propValidators[name] = makePropValidator(propType);
    }
    return propValidators;
}
function getValidatedProperties(properties, propValidators, errorMessage) {
    const validated = {};
    for (const [key, propsValidator] of Object.entries(propValidators)){
        if (properties && key in properties && !propsValidator.private) {
            if (propsValidator.validate) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$utils$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(propsValidator.validate(properties[key], propsValidator), `${errorMessage}: invalid ${key}`);
            }
            validated[key] = properties[key];
        } else {
            // property not supplied - use default value
            validated[key] = propsValidator.value;
        }
    }
    // TODO - warn for unused properties that don't match a validator?
    return validated;
}
/**
 * Creates a property validator for a prop type. Either contains:
 * - a valid prop type object ({type, ...})
 * - or just a default value, in which case type and name inference is used
 */ function makePropValidator(propType) {
    let type = getTypeOf(propType);
    if (type !== 'object') {
        return {
            value: propType,
            ...DEFAULT_PROP_VALIDATORS[type],
            type
        };
    }
    // Special handling for objects
    if (typeof propType === 'object') {
        if (!propType) {
            return {
                type: 'object',
                value: null
            };
        }
        if (propType.type !== undefined) {
            return {
                ...propType,
                ...DEFAULT_PROP_VALIDATORS[propType.type],
                type: propType.type
            };
        }
        // If no type and value this object is likely the value
        if (propType.value === undefined) {
            return {
                type: 'object',
                value: propType
            };
        }
        type = getTypeOf(propType.value);
        return {
            ...propType,
            ...DEFAULT_PROP_VALIDATORS[type],
            type
        };
    }
    throw new Error('props');
}
/**
 * "improved" version of javascript typeof that can distinguish arrays and null values
 */ function getTypeOf(value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
        return 'array';
    }
    return typeof value;
} //# sourceMappingURL=prop-types.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "checkShaderModuleDeprecations": (()=>checkShaderModuleDeprecations),
    "getShaderModuleUniforms": (()=>getShaderModuleUniforms),
    "initializeShaderModule": (()=>initializeShaderModule),
    "initializeShaderModules": (()=>initializeShaderModules)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$injections$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-injections.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$filters$2f$prop$2d$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/filters/prop-types.js [app-client] (ecmascript)");
;
;
function initializeShaderModules(modules) {
    modules.map((module)=>initializeShaderModule(module));
}
function initializeShaderModule(module) {
    if (module.instance) {
        return;
    }
    initializeShaderModules(module.dependencies || []);
    const { propTypes = {}, deprecations = [], // defines = {},
    inject = {} } = module;
    const instance = {
        normalizedInjections: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$injections$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeInjections"])(inject),
        parsedDeprecations: parseDeprecationDefinitions(deprecations)
    };
    if (propTypes) {
        instance.propValidators = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$filters$2f$prop$2d$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePropValidators"])(propTypes);
    }
    module.instance = instance;
    // TODO(ib) - we need to apply the original prop types to the default uniforms
    let defaultProps = {};
    if (propTypes) {
        defaultProps = Object.entries(propTypes).reduce((obj, [key, propType])=>{
            // @ts-expect-error
            const value = propType?.value;
            if (value) {
                // @ts-expect-error
                obj[key] = value;
            }
            return obj;
        }, {});
    }
    module.defaultUniforms = {
        ...module.defaultUniforms,
        ...defaultProps
    };
}
function getShaderModuleUniforms(module, props, oldUniforms) {
    initializeShaderModule(module);
    const uniforms = oldUniforms || {
        ...module.defaultUniforms
    };
    // If module has a getUniforms function, use it
    if (props && module.getUniforms) {
        return module.getUniforms(props, uniforms);
    }
    // Build uniforms from the uniforms array
    // @ts-expect-error
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$filters$2f$prop$2d$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getValidatedProperties"])(props, module.instance?.propValidators, module.name);
}
function checkShaderModuleDeprecations(shaderModule, shaderSource, log) {
    shaderModule.deprecations?.forEach((def)=>{
        if (def.regex?.test(shaderSource)) {
            if (def.deprecated) {
                log.deprecated(def.old, def.new)();
            } else {
                log.removed(def.old, def.new)();
            }
        }
    });
}
// HELPERS
function parseDeprecationDefinitions(deprecations) {
    deprecations.forEach((def)=>{
        switch(def.type){
            case 'function':
                def.regex = new RegExp(`\\b${def.old}\\(`);
                break;
            default:
                def.regex = new RegExp(`${def.type} ${def.old};`);
        }
    });
    return deprecations;
} //# sourceMappingURL=shader-module.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module-dependencies.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "getDependencyGraph": (()=>getDependencyGraph),
    "getShaderDependencies": (()=>getShaderDependencies),
    "getShaderModuleDependencies": (()=>getShaderModuleDependencies),
    "resolveModules": (()=>resolveModules)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module.js [app-client] (ecmascript)");
;
function getShaderModuleDependencies(modules) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initializeShaderModules"])(modules);
    const moduleMap = {};
    const moduleDepth = {};
    getDependencyGraph({
        modules,
        level: 0,
        moduleMap,
        moduleDepth
    });
    // Return a reverse sort so that dependencies come before the modules that use them
    const dependencies = Object.keys(moduleDepth).sort((a, b)=>moduleDepth[b] - moduleDepth[a]).map((name)=>moduleMap[name]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initializeShaderModules"])(dependencies);
    return dependencies;
}
function getDependencyGraph(options) {
    const { modules, level, moduleMap, moduleDepth } = options;
    if (level >= 5) {
        throw new Error('Possible loop in shader dependency graph');
    }
    // Update level on all current modules
    for (const module of modules){
        moduleMap[module.name] = module;
        if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {
            moduleDepth[module.name] = level;
        }
    }
    // Recurse
    for (const module of modules){
        if (module.dependencies) {
            getDependencyGraph({
                modules: module.dependencies,
                level: level + 1,
                moduleMap,
                moduleDepth
            });
        }
    }
}
function getShaderDependencies(modules) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initializeShaderModules"])(modules);
    const moduleMap = {};
    const moduleDepth = {};
    getDependencyGraph({
        modules,
        level: 0,
        moduleMap,
        moduleDepth
    });
    // Return a reverse sort so that dependencies come before the modules that use them
    modules = Object.keys(moduleDepth).sort((a, b)=>moduleDepth[b] - moduleDepth[a]).map((name)=>moduleMap[name]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initializeShaderModules"])(modules);
    return modules;
}
function resolveModules(modules) {
    return getShaderDependencies(modules);
} //# sourceMappingURL=shader-module-dependencies.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-hooks.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** Generate hook source code */ __turbopack_esm__({
    "getShaderHooks": (()=>getShaderHooks),
    "normalizeShaderHooks": (()=>normalizeShaderHooks)
});
function getShaderHooks(hookFunctions, hookInjections) {
    let result = '';
    for(const hookName in hookFunctions){
        const hookFunction = hookFunctions[hookName];
        result += `void ${hookFunction.signature} {\n`;
        if (hookFunction.header) {
            result += `  ${hookFunction.header}`;
        }
        if (hookInjections[hookName]) {
            const injections = hookInjections[hookName];
            injections.sort((a, b)=>a.order - b.order);
            for (const injection of injections){
                result += `  ${injection.injection}\n`;
            }
        }
        if (hookFunction.footer) {
            result += `  ${hookFunction.footer}`;
        }
        result += '}\n';
    }
    return result;
}
function normalizeShaderHooks(hookFunctions) {
    const result = {
        vertex: {},
        fragment: {}
    };
    for (const hookFunction of hookFunctions){
        let opts;
        let hook;
        if (typeof hookFunction !== 'string') {
            opts = hookFunction;
            hook = opts.hook;
        } else {
            opts = {};
            hook = hookFunction;
        }
        hook = hook.trim();
        const [shaderStage, signature] = hook.split(':');
        const name = hook.replace(/\(.+/, '');
        const normalizedHook = Object.assign(opts, {
            signature
        });
        switch(shaderStage){
            case 'vs':
                result.vertex[name] = normalizedHook;
                break;
            case 'fs':
                result.fragment[name] = normalizedHook;
                break;
            default:
                throw new Error(shaderStage);
        }
    }
    return result;
} //# sourceMappingURL=shader-hooks.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/get-shader-info.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** Extracts information from shader source code */ __turbopack_esm__({
    "getShaderInfo": (()=>getShaderInfo)
});
function getShaderInfo(source, defaultName) {
    return {
        name: getShaderName(source, defaultName),
        language: 'glsl',
        version: getShaderVersion(source)
    };
}
/** Extracts GLSLIFY style naming of shaders: `#define SHADER_NAME ...` */ function getShaderName(shader, defaultName = 'unnamed') {
    const SHADER_NAME_REGEXP = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/;
    const match = SHADER_NAME_REGEXP.exec(shader);
    return match ? match[1] : defaultName;
}
/** returns GLSL shader version of given shader string */ function getShaderVersion(source) {
    let version = 100;
    const words = source.match(/[^\s]+/g);
    if (words && words.length >= 2 && words[0] === '#version') {
        const parsedVersion = parseInt(words[1], 10);
        if (Number.isFinite(parsedVersion)) {
            version = parsedVersion;
        }
    }
    if (version !== 100 && version !== 300) {
        throw new Error(`Invalid GLSL version ${version}`);
    }
    return version;
} //# sourceMappingURL=get-shader-info.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/platform-defines.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** Adds defines to help identify GPU architecture / platform */ __turbopack_esm__({
    "getPlatformShaderDefines": (()=>getPlatformShaderDefines)
});
function getPlatformShaderDefines(platformInfo) {
    switch(platformInfo?.gpu.toLowerCase()){
        case 'apple':
            return /* glsl */ `\
#define APPLE_GPU
// Apple optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
        case 'nvidia':
            return /* glsl */ `\
#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;
        case 'intel':
            return /* glsl */ `\
#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
        case 'amd':
            // AMD Does not eliminate fp64 code
            return /* glsl */ `\
#define AMD_GPU
`;
        default:
            // We don't know what GPU it is, could be that the GPU driver or
            // browser is not implementing UNMASKED_RENDERER constant and not
            // reporting a correct name
            return /* glsl */ `\
#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Headless Chrome's software shader 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// If the GPU doesn't have full 32 bits precision, will causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
    }
} //# sourceMappingURL=platform-defines.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-transpiler/transpile-glsl-shader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// TRANSPILATION TABLES
/**
 * Transpiles GLSL 3.00 shader source code to target GLSL version (3.00 or 1.00)
 *
 * @note We always run transpiler even if same version e.g. 3.00 => 3.00
 * @note For texture sampling transpilation, apps need to use non-standard texture* calls in GLSL 3.00 source
 * RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md
 */ __turbopack_esm__({
    "transpileGLSLShader": (()=>transpileGLSLShader)
});
function transpileGLSLShader(source, stage) {
    const sourceGLSLVersion = Number(source.match(/^#version[ \t]+(\d+)/m)?.[1] || 100);
    if (sourceGLSLVersion !== 300) {
        // TODO - we splurge on a longer error message to help deck.gl custom layer developers
        throw new Error('luma.gl v9 only supports GLSL 3.00 shader sources');
    }
    switch(stage){
        case 'vertex':
            source = convertShader(source, ES300_VERTEX_REPLACEMENTS);
            return source;
        case 'fragment':
            source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);
            return source;
        default:
            // Unknown shader stage
            throw new Error(stage);
    }
}
/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */ const ES300_REPLACEMENTS = [
    // Fix poorly formatted version directive
    [
        /^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/,
        '#version 300 es\n'
    ],
    // The individual `texture...()` functions were replaced with `texture()` overloads
    [
        /\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g,
        'textureLod('
    ],
    [
        /\btexture(2D|2DProj|Cube)(EXT)?\(/g,
        'texture('
    ]
];
const ES300_VERTEX_REPLACEMENTS = [
    ...ES300_REPLACEMENTS,
    // `attribute` keyword replaced with `in`
    [
        makeVariableTextRegExp('attribute'),
        'in $1'
    ],
    // `varying` keyword replaced with `out`
    [
        makeVariableTextRegExp('varying'),
        'out $1'
    ]
];
/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */ const ES300_FRAGMENT_REPLACEMENTS = [
    ...ES300_REPLACEMENTS,
    // `varying` keyword replaced with `in`
    [
        makeVariableTextRegExp('varying'),
        'in $1'
    ]
];
function convertShader(source, replacements) {
    for (const [pattern, replacement] of replacements){
        source = source.replace(pattern, replacement);
    }
    return source;
}
/**
 * Creates a regexp that tests for a specific variable type
 * @example
 *   should match:
 *     in float weight;
 *     out vec4 positions[2];
 *   should not match:
 *     void f(out float a, in float b) {}
 */ function makeVariableTextRegExp(qualifier) {
    return new RegExp(`\\b${qualifier}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, 'g');
} //# sourceMappingURL=transpile-glsl-shader.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/assemble-shaders.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "assembleGLSLShaderPair": (()=>assembleGLSLShaderPair),
    "assembleGetUniforms": (()=>assembleGetUniforms),
    "assembleShaderWGSL": (()=>assembleShaderWGSL),
    "assembleWGSLShader": (()=>assembleWGSLShader),
    "getShaderModuleSource": (()=>getShaderModuleSource)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$injections$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-injections.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2d$dependencies$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module-dependencies.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$utils$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/utils/assert.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$hooks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-hooks.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$glsl$2d$utils$2f$get$2d$shader$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/get-shader-info.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$platform$2d$defines$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/platform-defines.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$transpiler$2f$transpile$2d$glsl$2d$shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-transpiler/transpile-glsl-shader.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
const INJECT_SHADER_DECLARATIONS = `\n\n${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$injections$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DECLARATION_INJECT_MARKER"]}\n`;
/**
 * Precision prologue to inject before functions are injected in shader
 * TODO - extract any existing prologue in the fragment source and move it up...
 */ const FRAGMENT_SHADER_PROLOGUE = /* glsl */ `\
precision highp float;
`;
function assembleWGSLShader(options) {
    const modules = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2d$dependencies$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getShaderModuleDependencies"])(options.modules || []);
    return {
        source: assembleShaderWGSL(options.platformInfo, {
            ...options,
            source: options.source,
            stage: 'vertex',
            modules
        }),
        getUniforms: assembleGetUniforms(modules)
    };
}
function assembleGLSLShaderPair(options) {
    const { vs, fs } = options;
    const modules = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2d$dependencies$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getShaderModuleDependencies"])(options.modules || []);
    return {
        vs: assembleShaderGLSL(options.platformInfo, {
            ...options,
            source: vs,
            stage: 'vertex',
            modules
        }),
        fs: assembleShaderGLSL(options.platformInfo, {
            ...options,
            // @ts-expect-error
            source: fs,
            stage: 'fragment',
            modules
        }),
        getUniforms: assembleGetUniforms(modules)
    };
}
function assembleShaderWGSL(platformInfo, options) {
    const { // id,
    source, stage, modules, // defines = {},
    hookFunctions = [], inject = {}, log } = options;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$utils$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(typeof source === 'string', 'shader source must be a string');
    // const isVertex = type === 'vs';
    // const sourceLines = source.split('\n');
    const coreSource = source;
    // Combine Module and Application Defines
    // const allDefines = {};
    // modules.forEach(module => {
    //   Object.assign(allDefines, module.getDefines());
    // });
    // Object.assign(allDefines, defines);
    // Add platform defines (use these to work around platform-specific bugs and limitations)
    // Add common defines (GLSL version compatibility, feature detection)
    // Add precision declaration for fragment shaders
    let assembledSource = '';
    //   prologue
    //     ? `\
    // ${getShaderNameDefine({id, source, type})}
    // ${getShaderType(type)}
    // ${getPlatformShaderDefines(platformInfo)}
    // ${getApplicationDefines(allDefines)}
    // ${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}
    // `
    // `;
    const hookFunctionMap = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$hooks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeShaderHooks"])(hookFunctions);
    // Add source of dependent modules in resolved order
    const hookInjections = {};
    const declInjections = {};
    const mainInjections = {};
    for(const key in inject){
        const injection = typeof inject[key] === 'string' ? {
            injection: inject[key],
            order: 0
        } : inject[key];
        const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
        if (match) {
            const hash = match[2];
            const name = match[3];
            if (hash) {
                if (name === 'decl') {
                    declInjections[key] = [
                        injection
                    ];
                } else {
                    mainInjections[key] = [
                        injection
                    ];
                }
            } else {
                hookInjections[key] = [
                    injection
                ];
            }
        } else {
            // Regex injection
            mainInjections[key] = [
                injection
            ];
        }
    }
    // TODO - hack until shadertool modules support WebGPU
    const modulesToInject = modules;
    for (const module of modulesToInject){
        if (log) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checkShaderModuleDeprecations"])(module, coreSource, log);
        }
        const moduleSource = getShaderModuleSource(module, 'wgsl');
        // Add the module source, and a #define that declares it presence
        assembledSource += moduleSource;
        const injections = module.injections?.[stage] || {};
        for(const key in injections){
            const match = /^(v|f)s:#([\w-]+)$/.exec(key);
            if (match) {
                const name = match[2];
                const injectionType = name === 'decl' ? declInjections : mainInjections;
                injectionType[key] = injectionType[key] || [];
                injectionType[key].push(injections[key]);
            } else {
                hookInjections[key] = hookInjections[key] || [];
                hookInjections[key].push(injections[key]);
            }
        }
    }
    // For injectShader
    assembledSource += INJECT_SHADER_DECLARATIONS;
    assembledSource = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$injections$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["injectShader"])(assembledSource, stage, declInjections);
    assembledSource += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$hooks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getShaderHooks"])(hookFunctionMap[stage], hookInjections);
    // Add the version directive and actual source of this shader
    assembledSource += coreSource;
    // Apply any requested shader injections
    assembledSource = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$injections$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["injectShader"])(assembledSource, stage, mainInjections);
    return assembledSource;
}
/**
 * Pulls together complete source code for either a vertex or a fragment shader
 * adding prologues, requested module chunks, and any final injections.
 * @param gl
 * @param options
 * @returns
 */ function assembleShaderGLSL(platformInfo, options) {
    const { id, source, stage, language = 'glsl', modules, defines = {}, hookFunctions = [], inject = {}, prologue = true, log } = options;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$utils$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(typeof source === 'string', 'shader source must be a string');
    const sourceVersion = language === 'glsl' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$glsl$2d$utils$2f$get$2d$shader$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getShaderInfo"])(source).version : -1;
    const targetVersion = platformInfo.shaderLanguageVersion;
    const sourceVersionDirective = sourceVersion === 100 ? '#version 100' : '#version 300 es';
    const sourceLines = source.split('\n');
    // TODO : keep all pre-processor statements at the beginning of the shader.
    const coreSource = sourceLines.slice(1).join('\n');
    // Combine Module and Application Defines
    const allDefines = {};
    modules.forEach((module)=>{
        Object.assign(allDefines, module.defines);
    });
    Object.assign(allDefines, defines);
    // Add platform defines (use these to work around platform-specific bugs and limitations)
    // Add common defines (GLSL version compatibility, feature detection)
    // Add precision declaration for fragment shaders
    let assembledSource = '';
    switch(language){
        case 'wgsl':
            break;
        case 'glsl':
            assembledSource = prologue ? `\
${sourceVersionDirective}

// ----- PROLOGUE -------------------------
${getShaderNameDefine({
                id,
                source,
                stage
            })}
${`#define SHADER_TYPE_${stage.toUpperCase()}`}

${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$platform$2d$defines$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPlatformShaderDefines"])(platformInfo)}
${stage === 'fragment' ? FRAGMENT_SHADER_PROLOGUE : ''}

// ----- APPLICATION DEFINES -------------------------

${getApplicationDefines(allDefines)}

` : `${sourceVersionDirective}
`;
            break;
    }
    const hookFunctionMap = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$hooks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeShaderHooks"])(hookFunctions);
    // Add source of dependent modules in resolved order
    const hookInjections = {};
    const declInjections = {};
    const mainInjections = {};
    for(const key in inject){
        const injection = typeof inject[key] === 'string' ? {
            injection: inject[key],
            order: 0
        } : inject[key];
        const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
        if (match) {
            const hash = match[2];
            const name = match[3];
            if (hash) {
                if (name === 'decl') {
                    declInjections[key] = [
                        injection
                    ];
                } else {
                    mainInjections[key] = [
                        injection
                    ];
                }
            } else {
                hookInjections[key] = [
                    injection
                ];
            }
        } else {
            // Regex injection
            mainInjections[key] = [
                injection
            ];
        }
    }
    for (const module of modules){
        if (log) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checkShaderModuleDeprecations"])(module, coreSource, log);
        }
        const moduleSource = getShaderModuleSource(module, stage);
        // Add the module source, and a #define that declares it presence
        assembledSource += moduleSource;
        const injections = module.instance?.normalizedInjections[stage] || {};
        for(const key in injections){
            const match = /^(v|f)s:#([\w-]+)$/.exec(key);
            if (match) {
                const name = match[2];
                const injectionType = name === 'decl' ? declInjections : mainInjections;
                injectionType[key] = injectionType[key] || [];
                injectionType[key].push(injections[key]);
            } else {
                hookInjections[key] = hookInjections[key] || [];
                hookInjections[key].push(injections[key]);
            }
        }
    }
    assembledSource += '// ----- MAIN SHADER SOURCE -------------------------';
    // For injectShader
    assembledSource += INJECT_SHADER_DECLARATIONS;
    assembledSource = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$injections$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["injectShader"])(assembledSource, stage, declInjections);
    assembledSource += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$hooks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getShaderHooks"])(hookFunctionMap[stage], hookInjections);
    // Add the version directive and actual source of this shader
    assembledSource += coreSource;
    // Apply any requested shader injections
    assembledSource = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$injections$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["injectShader"])(assembledSource, stage, mainInjections);
    if (language === 'glsl' && sourceVersion !== targetVersion) {
        assembledSource = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$transpiler$2f$transpile$2d$glsl$2d$shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transpileGLSLShader"])(assembledSource, stage);
    }
    return assembledSource.trim();
}
function assembleGetUniforms(modules) {
    return function getUniforms(opts) {
        const uniforms = {};
        for (const module of modules){
            // `modules` is already sorted by dependency level. This guarantees that
            // modules have access to the uniforms that are generated by their dependencies.
            const moduleUniforms = module.getUniforms?.(opts, uniforms);
            Object.assign(uniforms, moduleUniforms);
        }
        return uniforms;
    };
}
/**
 * Generate "glslify-compatible" SHADER_NAME defines
 * These are understood by the GLSL error parsing function
 * If id is provided and no SHADER_NAME constant is present in source, create one
 */ function getShaderNameDefine(options) {
    const { id, source, stage } = options;
    const injectShaderName = id && source.indexOf('SHADER_NAME') === -1;
    return injectShaderName ? `
#define SHADER_NAME ${id}_${stage}` : '';
}
/** Generates application defines from an object of key value pairs */ function getApplicationDefines(defines = {}) {
    let sourceText = '';
    for(const define in defines){
        const value = defines[define];
        if (value || Number.isFinite(value)) {
            sourceText += `#define ${define.toUpperCase()} ${defines[define]}\n`;
        }
    }
    return sourceText;
}
function getShaderModuleSource(module, stage) {
    let moduleSource;
    switch(stage){
        case 'vertex':
            moduleSource = module.vs || '';
            break;
        case 'fragment':
            moduleSource = module.fs || '';
            break;
        case 'wgsl':
            moduleSource = module.source || '';
            break;
        default:
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$utils$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(false);
    }
    if (!module.name) {
        throw new Error('Shader module must have a name');
    }
    const moduleName = module.name.toUpperCase().replace(/[^0-9a-z]/gi, '_');
    let source = `\
// ----- MODULE ${module.name} ---------------

`;
    if (stage !== 'wgsl') {
        source += `#define MODULE_${moduleName}\n`;
    }
    source += `${moduleSource}\n`;
    return source;
} /*
function getHookFunctions(
  hookFunctions: Record<string, HookFunction>,
  hookInjections: Record<string, Injection[]>
): string {
  let result = '';
  for (const hookName in hookFunctions) {
    const hookFunction = hookFunctions[hookName];
    result += `void ${hookFunction.signature} {\n`;
    if (hookFunction.header) {
      result += `  ${hookFunction.header}`;
    }
    if (hookInjections[hookName]) {
      const injections = hookInjections[hookName];
      injections.sort((a: {order: number}, b: {order: number}): number => a.order - b.order);
      for (const injection of injections) {
        result += `  ${injection.injection}\n`;
      }
    }
    if (hookFunction.footer) {
      result += `  ${hookFunction.footer}`;
    }
    result += '}\n';
  }

  return result;
}

function normalizeHookFunctions(hookFunctions: (string | HookFunction)[]): {
  vs: Record<string, HookFunction>;
  fs: Record<string, HookFunction>;
} {
  const result: {vs: Record<string, any>; fs: Record<string, any>} = {
    vs: {},
    fs: {}
  };

  hookFunctions.forEach((hookFunction: string | HookFunction) => {
    let opts: HookFunction;
    let hook: string;
    if (typeof hookFunction !== 'string') {
      opts = hookFunction;
      hook = opts.hook;
    } else {
      opts = {} as HookFunction;
      hook = hookFunction;
    }
    hook = hook.trim();
    const [stage, signature] = hook.split(':');
    const name = hook.replace(/\(.+/, '');
    if (stage !== 'vs' && stage !== 'fs') {
      throw new Error(stage);
    }
    result[stage][name] = Object.assign(opts, {signature});
  });

  return result;
}
*/  //# sourceMappingURL=assemble-shaders.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/preprocessor/preprocessor.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "preprocess": (()=>preprocess)
});
const IFDEF_REGEXP = /^\s*\#\s*ifdef\s*([a-zA-Z_]+)\s*$/;
const ENDIF_REGEXP = /^\s*\#\s*endif\s*$/;
function preprocess(source, options) {
    const lines = source.split('\n');
    const output = [];
    let conditional = true;
    let currentDefine = null;
    for (const line of lines){
        const matchIf = line.match(IFDEF_REGEXP);
        const matchEnd = line.match(ENDIF_REGEXP);
        if (matchIf) {
            currentDefine = matchIf[1];
            conditional = Boolean(options?.defines?.[currentDefine]);
        } else if (matchEnd) {
            conditional = true;
        } else if (conditional) {
            output.push(line);
        }
    }
    return output.join('\n');
} //# sourceMappingURL=preprocessor.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembler.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "ShaderAssembler": (()=>ShaderAssembler)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$assemble$2d$shaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/assemble-shaders.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$preprocessor$2f$preprocessor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/preprocessor/preprocessor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module.js [app-client] (ecmascript)");
;
;
;
class ShaderAssembler {
    /** Default ShaderAssembler instance */ static defaultShaderAssembler;
    /** Hook functions */ _hookFunctions = [];
    /** Shader modules */ _defaultModules = [];
    /**
     * A default shader assembler instance - the natural place to register default modules and hooks
     * @returns
     */ static getDefaultShaderAssembler() {
        ShaderAssembler.defaultShaderAssembler = ShaderAssembler.defaultShaderAssembler || new ShaderAssembler();
        return ShaderAssembler.defaultShaderAssembler;
    }
    /**
     * Add a default module that does not have to be provided with every call to assembleShaders()
     */ addDefaultModule(module) {
        if (!this._defaultModules.find((m)=>m.name === (typeof module === 'string' ? module : module.name))) {
            this._defaultModules.push(module);
        }
    }
    /**
     * Remove a default module
     */ removeDefaultModule(module) {
        const moduleName = typeof module === 'string' ? module : module.name;
        this._defaultModules = this._defaultModules.filter((m)=>m.name !== moduleName);
    }
    /**
     * Register a shader hook
     * @param hook
     * @param opts
     */ addShaderHook(hook, opts) {
        if (opts) {
            hook = Object.assign(opts, {
                hook
            });
        }
        this._hookFunctions.push(hook);
    }
    /**
     * Assemble a WGSL unified shader
     * @param platformInfo
     * @param props
     * @returns
     */ assembleWGSLShader(props) {
        const modules = this._getModuleList(props.modules); // Combine with default modules
        const hookFunctions = this._hookFunctions; // TODO - combine with default hook functions
        const { source, getUniforms } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$assemble$2d$shaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assembleWGSLShader"])({
            ...props,
            // @ts-expect-error
            source: props.source,
            modules,
            hookFunctions
        });
        // WGSL does not have built-in preprocessing support (just compile time constants)
        const preprocessedSource = props.platformInfo.shaderLanguage === 'wgsl' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$preprocessor$2f$preprocessor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["preprocess"])(source) : source;
        return {
            source: preprocessedSource,
            getUniforms,
            modules
        };
    }
    /**
     * Assemble a pair of shaders into a single shader program
     * @param platformInfo
     * @param props
     * @returns
     */ assembleGLSLShaderPair(props) {
        const modules = this._getModuleList(props.modules); // Combine with default modules
        const hookFunctions = this._hookFunctions; // TODO - combine with default hook functions
        const assembled = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$assemble$2d$shaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assembleGLSLShaderPair"])({
            ...props,
            // @ts-expect-error
            vs: props.vs,
            // @ts-expect-error
            fs: props.fs,
            modules,
            hookFunctions
        });
        return {
            ...assembled,
            modules
        };
    }
    /**
     * Dedupe and combine with default modules
     */ _getModuleList(appModules = []) {
        const modules = new Array(this._defaultModules.length + appModules.length);
        const seen = {};
        let count = 0;
        for(let i = 0, len = this._defaultModules.length; i < len; ++i){
            const module = this._defaultModules[i];
            const name = module.name;
            modules[count++] = module;
            seen[name] = true;
        }
        for(let i = 0, len = appModules.length; i < len; ++i){
            const module = appModules[i];
            const name = module.name;
            if (!seen[name]) {
                modules[count++] = module;
                seen[name] = true;
            }
        }
        modules.length = count;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initializeShaderModules"])(modules);
        return modules;
    }
} //# sourceMappingURL=shader-assembler.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/wgsl/get-shader-layout-wgsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "getShaderLayoutFromWGSL": (()=>getShaderLayoutFromWGSL)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wgsl_reflect$2f$wgsl_reflect$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/wgsl_reflect/wgsl_reflect.module.js [app-client] (ecmascript)");
;
;
function getShaderLayoutFromWGSL(source) {
    const shaderLayout = {
        attributes: [],
        bindings: []
    };
    let parsedWGSL;
    try {
        parsedWGSL = parseWGSL(source);
    } catch (error) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].error(error.message)();
        return shaderLayout;
    }
    for (const uniform of parsedWGSL.uniforms){
        const members = [];
        for (const attribute of uniform.type?.members || []){
            members.push({
                name: attribute.name,
                type: getType(attribute.type)
            });
        }
        shaderLayout.bindings.push({
            type: 'uniform',
            name: uniform.name,
            group: uniform.group,
            location: uniform.binding,
            // @ts-expect-error TODO - unused for now but needs fixing
            members
        });
    }
    for (const texture of parsedWGSL.textures){
        shaderLayout.bindings.push({
            type: 'texture',
            name: texture.name,
            group: texture.group,
            location: texture.binding
        });
    }
    for (const sampler of parsedWGSL.samplers){
        shaderLayout.bindings.push({
            type: 'sampler',
            name: sampler.name,
            group: sampler.group,
            location: sampler.binding
        });
    }
    const vertex = parsedWGSL.entry.vertex[0]; // "main"
    // Vertex shader inputs
    const attributeCount = vertex?.inputs.length || 0; // inputs to "main"
    for(let i = 0; i < attributeCount; i++){
        const wgslAttribute = vertex.inputs[i];
        // locationType can be "builtin"
        if (wgslAttribute.locationType === 'location') {
            const type = getType(wgslAttribute.type);
            shaderLayout.attributes.push({
                name: wgslAttribute.name,
                location: Number(wgslAttribute.location),
                type
            });
        }
    }
    return shaderLayout;
}
/** Get a valid shader attribute type string from a wgsl-reflect type */ function getType(type) {
    return type.format ? `${type.name}<${type.format.name}>` : type.name;
}
function parseWGSL(source) {
    try {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wgsl_reflect$2f$wgsl_reflect$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WgslReflect"](source);
    } catch (error) {
        if (error instanceof Error) {
            throw error;
        }
        let message = 'WGSL parse error';
        if (typeof error === 'object' && error?.message) {
            message += `: ${error.message} `;
        }
        if (typeof error === 'object' && error?.token) {
            message += error.token.line || '';
        }
        throw new Error(message, {
            cause: error
        });
    }
} //# sourceMappingURL=get-shader-layout-wgsl.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/shader-utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "convertToVec4": (()=>convertToVec4),
    "getPassthroughFS": (()=>getPassthroughFS),
    "getQualifierDetails": (()=>getQualifierDetails),
    "typeToChannelCount": (()=>typeToChannelCount),
    "typeToChannelSuffix": (()=>typeToChannelSuffix)
});
const FS_GLES = /* glsl */ `\
out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`;
const FS300 = `#version 300 es\n${FS_GLES}`;
function getQualifierDetails(line, qualifiers) {
    qualifiers = Array.isArray(qualifiers) ? qualifiers : [
        qualifiers
    ];
    const words = line.replace(/^\s+/, '').split(/\s+/);
    // TODO add support for precession qualifiers (highp, mediump and lowp)
    const [qualifier, type, definition] = words;
    if (!qualifiers.includes(qualifier) || !type || !definition) {
        return null;
    }
    const name = definition.split(';')[0];
    return {
        qualifier,
        type,
        name
    };
}
function getPassthroughFS(options) {
    const { input, inputChannels, output } = options || {};
    if (!input) {
        // Default shader
        return FS300;
    }
    if (!inputChannels) {
        throw new Error('inputChannels');
    }
    const inputType = channelCountToType(inputChannels);
    const outputValue = convertToVec4(input, inputChannels);
    return `\
#version 300 es
in ${inputType} ${input};
out vec4 ${output};
void main() {
  ${output} = ${outputValue};
}`;
}
function typeToChannelSuffix(type) {
    // prettier-ignore
    switch(type){
        case 'float':
            return 'x';
        case 'vec2':
            return 'xy';
        case 'vec3':
            return 'xyz';
        case 'vec4':
            return 'xyzw';
        default:
            throw new Error(type);
    }
}
function typeToChannelCount(type) {
    // prettier-ignore
    switch(type){
        case 'float':
            return 1;
        case 'vec2':
            return 2;
        case 'vec3':
            return 3;
        case 'vec4':
            return 4;
        default:
            throw new Error(type);
    }
}
function channelCountToType(channels) {
    // prettier-ignore
    switch(channels){
        case 1:
            return 'float';
        case 2:
            return 'vec2';
        case 3:
            return 'vec3';
        case 4:
            return 'vec4';
        default:
            throw new Error(`invalid channels: ${channels}`);
    }
}
function convertToVec4(variable, channels) {
    // prettier-ignore
    switch(channels){
        case 1:
            return `vec4(${variable}, 0.0, 0.0, 1.0)`;
        case 2:
            return `vec4(${variable}, 0.0, 1.0)`;
        case 3:
            return `vec4(${variable}, 1.0)`;
        case 4:
            return variable;
        default:
            throw new Error(`invalid channels: ${channels}`);
    }
} //# sourceMappingURL=shader-utils.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-arithmetic-glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "fp64arithmeticShader": (()=>fp64arithmeticShader)
});
const fp64arithmeticShader = /* glsl */ `\

uniform fp64arithmeticUniforms {
  uniform float ONE;
} fp64;

/*
About LUMA_FP64_CODE_ELIMINATION_WORKAROUND

The purpose of this workaround is to prevent shader compilers from
optimizing away necessary arithmetic operations by swapping their sequences
or transform the equation to some 'equivalent' form.

The method is to multiply an artifical variable, ONE, which will be known to
the compiler to be 1 only at runtime. The whole expression is then represented
as a polynomial with respective to ONE. In the coefficients of all terms, only one a
and one b should appear

err = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE
*/

// Divide float number to high and low floats to extend fraction bits
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * fp64.ONE - (t - a);
  float a_lo = a * fp64.ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}

// Divide float number again when high float uses too many fraction bits
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}

// Special sum operation when a > b
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * fp64.ONE;
  float err = b - (sum - a) * fp64.ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}

// General sum operation
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *
    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  // y component is for the error
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`; //# sourceMappingURL=fp64-arithmetic-glsl.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 * Calculate WebGL 64 bit float
 * @param a  - the input float number
 * @param out - the output array. If not supplied, a new array is created.
 * @param startIndex - the index in the output array to fill from. Default 0.
 * @returns - the fp64 representation of the input number
 */ __turbopack_esm__({
    "fp64LowPart": (()=>fp64LowPart),
    "fp64ify": (()=>fp64ify),
    "fp64ifyMatrix4": (()=>fp64ifyMatrix4)
});
function fp64ify(a, out = [], startIndex = 0) {
    const hiPart = Math.fround(a);
    const loPart = a - hiPart;
    out[startIndex] = hiPart;
    out[startIndex + 1] = loPart;
    return out;
}
function fp64LowPart(a) {
    return a - Math.fround(a);
}
function fp64ifyMatrix4(matrix) {
    // Transpose the projection matrix to column major for GLSL.
    const matrixFP64 = new Float32Array(32);
    for(let i = 0; i < 4; ++i){
        for(let j = 0; j < 4; ++j){
            const index = i * 4 + j;
            fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);
        }
    }
    return matrixFP64;
} //# sourceMappingURL=fp64-utils.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-functions-glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "fp64functionShader": (()=>fp64functionShader)
});
const fp64functionShader = /* glsl */ `\
const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);
const vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);
const vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);
const vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);
const vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);
const vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);
const vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);
const vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);
const vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);
const vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);

const vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);
const vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);
const vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);
const vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);

const vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);
const vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);
const vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);
const vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);

const vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09); // 1/3!
const vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09); // 1/4!
const vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10); // 1/5!
const vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11); // 1/6!
const vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12); // 1/7!
const vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13); // 1/8!
const vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14); // 1/9!
const vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15); // 1/10!

float nint(float d) {
    if (d == floor(d)) return d;
    return floor(d + 0.5);
}

vec2 nint_fp64(vec2 a) {
    float hi = nint(a.x);
    float lo;
    vec2 tmp;
    if (hi == a.x) {
        lo = nint(a.y);
        tmp = quickTwoSum(hi, lo);
    } else {
        lo = 0.0;
        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {
            hi -= 1.0;
        }
        tmp = vec2(hi, lo);
    }
    return tmp;
}

/* k_power controls how much range reduction we would like to have
Range reduction uses the following method:
assume a = k_power * r + m * log(2), k and m being integers.
Set k_power = 4 (we can choose other k to trade accuracy with performance.
we only need to calculate exp(r) and using exp(a) = 2^m * exp(r)^k_power;
*/

vec2 exp_fp64(vec2 a) {
  // We need to make sure these two numbers match
  // as bit-wise shift is not available in GLSL 1.0
  const int k_power = 4;
  const float k = 16.0;

  const float inv_k = 1.0 / k;

  if (a.x <= -88.0) return vec2(0.0, 0.0);
  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);
  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);
  if (a.x == 1.0 && a.y == 0.0) return E_FP64;

  float m = floor(a.x / LOG2_FP64.x + 0.5);
  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;
  vec2 s, t, p;

  p = mul_fp64(r, r);
  s = sum_fp64(r, p * 0.5);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);

  s = sum_fp64(s, t);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);

  s = sum_fp64(s, t);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);

  // s = sum_fp64(s, t);
  // p = mul_fp64(p, r);
  // t = mul_fp64(p, INVERSE_FACTORIAL_6_FP64);

  // s = sum_fp64(s, t);
  // p = mul_fp64(p, r);
  // t = mul_fp64(p, INVERSE_FACTORIAL_7_FP64);

  s = sum_fp64(s, t);


  // At this point, s = exp(r) - 1; but after following 4 recursions, we will get exp(r) ^ 512 - 1.
  for (int i = 0; i < k_power; i++) {
    s = sum_fp64(s * 2.0, mul_fp64(s, s));
  }

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
  s = sum_fp64(s, vec2(fp64.ONE, 0.0));
#else
  s = sum_fp64(s, vec2(1.0, 0.0));
#endif

  return s * pow(2.0, m);
//   return r;
}

vec2 log_fp64(vec2 a)
{
  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
  vec2 x = vec2(log(a.x), 0.0);
  vec2 s;
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
  s = vec2(fp64.ONE, 0.0);
#else
  s = vec2(1.0, 0.0);
#endif

  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);
  return x;
}

vec2 sin_taylor_fp64(vec2 a) {
  vec2 r, s, t, x;

  if (a.x == 0.0 && a.y == 0.0) {
    return vec2(0.0, 0.0);
  }

  x = -mul_fp64(a, a);
  s = a;
  r = a;

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);
  s = sum_fp64(s, t);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);
  s = sum_fp64(s, t);

  /* keep the following commented code in case we need them
  for extra accuracy from the Taylor expansion*/

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_7_FP64);
  // s = sum_fp64(s, t);

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_9_FP64);
  // s = sum_fp64(s, t);

  return s;
}

vec2 cos_taylor_fp64(vec2 a) {
  vec2 r, s, t, x;

  if (a.x == 0.0 && a.y == 0.0) {
    return vec2(1.0, 0.0);
  }

  x = -mul_fp64(a, a);
  r = x;
  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);
  s = sum_fp64(s, t);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);
  s = sum_fp64(s, t);

  /* keep the following commented code in case we need them
  for extra accuracy from the Taylor expansion*/

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_8_FP64);
  // s = sum_fp64(s, t);

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_10_FP64);
  // s = sum_fp64(s, t);

  return s;
}

void sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {
  if (a.x == 0.0 && a.y == 0.0) {
    sin_t = vec2(0.0, 0.0);
    cos_t = vec2(1.0, 0.0);
  }

  sin_t = sin_taylor_fp64(a);
  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));
}

vec2 sin_fp64(vec2 a) {
    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(0.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);

    if (k == 0) {
        if (j == 0) {
            return sin_taylor_fp64(t);
        } else if (j == 1) {
            return cos_taylor_fp64(t);
        } else if (j == -1) {
            return -cos_taylor_fp64(t);
        } else {
            return -sin_taylor_fp64(t);
        }
    }

    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }

    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
    if (abs(float(abs_k) - 1.0) < 0.5) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs(float(abs_k) - 2.0) < 0.5) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs(float(abs_k) - 3.0) < 0.5) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs(float(abs_k) - 4.0) < 0.5) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#else
    if (abs_k == 1) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs_k == 2) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs_k == 3) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs_k == 4) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#endif

    vec2 sin_t, cos_t;
    sincos_taylor_fp64(t, sin_t, cos_t);



    vec2 result = vec2(0.0, 0.0);
    if (j == 0) {
        if (k > 0) {
            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        }
    } else if (j == 1) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    } else if (j == -1) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        } else {
            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        }
    } else {
        if (k > 0) {
            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
        }
    }

    return result;
}

vec2 cos_fp64(vec2 a) {
    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(1.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);

    if (k == 0) {
        if (j == 0) {
            return cos_taylor_fp64(t);
        } else if (j == 1) {
            return -sin_taylor_fp64(t);
        } else if (j == -1) {
            return sin_taylor_fp64(t);
        } else {
            return -cos_taylor_fp64(t);
        }
    }

    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }

    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
    if (abs(float(abs_k) - 1.0) < 0.5) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs(float(abs_k) - 2.0) < 0.5) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs(float(abs_k) - 3.0) < 0.5) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs(float(abs_k) - 4.0) < 0.5) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#else
    if (abs_k == 1) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs_k == 2) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs_k == 3) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs_k == 4) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#endif

    vec2 sin_t, cos_t;
    sincos_taylor_fp64(t, sin_t, cos_t);

    vec2 result = vec2(0.0, 0.0);
    if (j == 0) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    } else if (j == 1) {
        if (k > 0) {
            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
        }
    } else if (j == -1) {
        if (k > 0) {
            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        }
    } else {
        if (k > 0) {
            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        } else {
            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    }

    return result;
}

vec2 tan_fp64(vec2 a) {
    vec2 sin_a;
    vec2 cos_a;

    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(0.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);


    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    // We just can't get PI/16 * 3.0 very accurately.
    // so let's just store it
    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }


    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

    vec2 sin_t, cos_t;
    vec2 s, c;
    sincos_taylor_fp64(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0_FP64;
            v = SIN_TABLE_0_FP64;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1_FP64;
            v = SIN_TABLE_1_FP64;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2_FP64;
            v = SIN_TABLE_2_FP64;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3_FP64;
            v = SIN_TABLE_3_FP64;
        }
#else
        if (abs_k == 1) {
            u = COS_TABLE_0_FP64;
            v = SIN_TABLE_0_FP64;
        } else if (abs_k == 2) {
            u = COS_TABLE_1_FP64;
            v = SIN_TABLE_1_FP64;
        } else if (abs_k == 3) {
            u = COS_TABLE_2_FP64;
            v = SIN_TABLE_2_FP64;
        } else if (abs_k == 4) {
            u = COS_TABLE_3_FP64;
            v = SIN_TABLE_3_FP64;
        }
#endif
        if (k > 0) {
            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return div_fp64(sin_a, cos_a);
}

vec2 radians_fp64(vec2 degree) {
  return mul_fp64(degree, PI_180_FP64);
}

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

// Vector functions
// vec2 functions
void vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = sum_fp64(a[0], b[0]);
    out_val[1] = sum_fp64(a[1], b[1]);
}

void vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = sub_fp64(a[0], b[0]);
    out_val[1] = sub_fp64(a[1], b[1]);
}

void vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = mul_fp64(a[0], b[0]);
    out_val[1] = mul_fp64(a[1], b[1]);
}

void vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = div_fp64(a[0], b[0]);
    out_val[1] = div_fp64(a[1], b[1]);
}

void vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {
  vec2 range[2];
  vec2_sub_fp64(y, x, range);
  vec2 portion[2];
  portion[0] = range[0] * a;
  portion[1] = range[1] * a;
  vec2_sum_fp64(x, portion, out_val);
}

vec2 vec2_length_fp64(vec2 x[2]) {
  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));
}

void vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {
  vec2 length = vec2_length_fp64(x);
  vec2 length_vec2[2];
  length_vec2[0] = length;
  length_vec2[1] = length;

  vec2_div_fp64(x, length_vec2, out_val);
}

vec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {
  vec2 diff[2];
  vec2_sub_fp64(x, y, diff);
  return vec2_length_fp64(diff);
}

vec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {
  vec2 v[2];

  v[0] = mul_fp64(a[0], b[0]);
  v[1] = mul_fp64(a[1], b[1]);

  return sum_fp64(v[0], v[1]);
}

// vec3 functions
void vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
  for (int i = 0; i < 3; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

void vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
  for (int i = 0; i < 3; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

vec2 vec3_length_fp64(vec2 x[3]) {
  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),
    mul_fp64(x[2], x[2])));
}

vec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {
  vec2 diff[3];
  vec3_sub_fp64(x, y, diff);
  return vec3_length_fp64(diff);
}

// vec4 functions
void vec4_fp64(vec4 a, out vec2 out_val[4]) {
  out_val[0].x = a[0];
  out_val[0].y = 0.0;

  out_val[1].x = a[1];
  out_val[1].y = 0.0;

  out_val[2].x = a[2];
  out_val[2].y = 0.0;

  out_val[3].x = a[3];
  out_val[3].y = 0.0;
}

void vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {
  out_val[0] = mul_fp64(a[0], b);
  out_val[1] = mul_fp64(a[1], b);
  out_val[2] = mul_fp64(a[2], b);
  out_val[3] = mul_fp64(a[3], b);
}

void vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {
  for (int i = 0; i < 4; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

void vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {
  vec2 v[4];

  v[0] = mul_fp64(a[0], b[0]);
  v[1] = mul_fp64(a[1], b[1]);
  v[2] = mul_fp64(a[2], b[2]);
  v[3] = mul_fp64(a[3], b[3]);

  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));
}

void mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {
  vec2 tmp[4];

  for (int i = 0; i < 4; i++)
  {
    for (int j = 0; j < 4; j++)
    {
      tmp[j] = b[j + i * 4];
    }
    vec4_dot_fp64(a, tmp, out_val[i]);
  }
}
`; //# sourceMappingURL=fp64-functions-glsl.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "fp64": (()=>fp64),
    "fp64arithmetic": (()=>fp64arithmetic)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$arithmetic$2d$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-arithmetic-glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$functions$2d$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-functions-glsl.js [app-client] (ecmascript)");
;
;
;
const defaultUniforms = {
    // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND
    ONE: 1.0
};
const fp64arithmetic = {
    name: 'fp64arithmetic',
    vs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$arithmetic$2d$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fp64arithmeticShader"],
    defaultUniforms,
    uniformTypes: {
        ONE: 'f32'
    },
    // Additional Functions
    fp64ify: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fp64ify"],
    fp64LowPart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fp64LowPart"],
    fp64ifyMatrix4: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fp64ifyMatrix4"]
};
const fp64 = {
    name: 'fp64',
    vs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$functions$2d$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fp64functionShader"],
    dependencies: [
        fp64arithmetic
    ],
    // Additional Functions
    fp64ify: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fp64ify"],
    fp64LowPart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fp64LowPart"],
    fp64ifyMatrix4: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fp64ifyMatrix4"]
};
;
 //# sourceMappingURL=fp64.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "PHONG_FS": (()=>PHONG_FS),
    "PHONG_VS": (()=>PHONG_VS)
});
const PHONG_VS = /* glsl */ `\
uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;
`;
const PHONG_FS = /* glsl */ `\
uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
  vec3 halfway_direction = normalize(light_direction + view_direction);
  float lambertian = dot(light_direction, normal_worldspace);
  float specular = 0.0;
  if (lambertian > 0.0) {
    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  vec3 view_direction = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  for (int i = 0; i < lighting.pointLightCount; i++) {
    PointLight pointLight = lighting_getPointLight(i);
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);
  }

  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);
  for (int i = lighting.pointLightCount; i < totalLights; i++) {
    DirectionalLight directionalLight = lighting_getDirectionalLight(i);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
}
`; //# sourceMappingURL=phong-shaders-glsl.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-uniforms-wgsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "lightingUniformsWGSL": (()=>lightingUniformsWGSL)
});
const lightingUniformsWGSL = /* wgsl */ `\
// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  color: vec3<f32>,
};

struct PointLight {
  color: vec3<f32>,
  position: vec3<f32>,
  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  color: vec3<f32>,
  direction: vec3<f32>,
};

struct lightingUniforms {
  enabled: i32,
  poightCount: i32,
  directionalLightCount: i32,

  ambientColor: vec3<f32>,

  // TODO - support multiple lights by uncommenting arrays below
  lightType: i32,
  lightColor: vec3<f32>,
  lightDirection: vec3<f32>,
  lightPosition: vec3<f32>,
  lightAttenuation: vec3<f32>,

  // AmbientLight ambientLight;
  // PointLight pointLight[MAX_LIGHTS];
  // DirectionalLight directionalLight[MAX_LIGHTS];
};

// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)
@binding(1) @group(0) var<uniform> lighting : lightingUniforms;

fn lighting_getPointLight(index: i32) -> PointLight {
  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}

fn lighting_getDirectionalLight(index: i32) -> DirectionalLight {
  return DirectionalLight(lighting.lightColor, lighting.lightDirection);
} 

fn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}
`; //# sourceMappingURL=lighting-uniforms-wgsl.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-uniforms-glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "lightingUniformsGLSL": (()=>lightingUniformsGLSL)
});
const lightingUniformsGLSL = /* glsl */ `\
precision highp int;

// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  vec3 color;
};

struct PointLight {
  vec3 color;
  vec3 position;
  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform lightingUniforms {
  int enabled;
  int lightType;

  int directionalLightCount;
  int pointLightCount;

  vec3 ambientColor;

  vec3 lightColor0;
  vec3 lightPosition0;
  vec3 lightDirection0;
  vec3 lightAttenuation0;

  vec3 lightColor1;
  vec3 lightPosition1;
  vec3 lightDirection1;
  vec3 lightAttenuation1;

  vec3 lightColor2;
  vec3 lightPosition2;
  vec3 lightDirection2;
  vec3 lightAttenuation2;
} lighting;

PointLight lighting_getPointLight(int index) {
  switch (index) {
    case 0:
      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);
    case 1:
      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);
    case 2:
    default:  
      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);
  }
}

DirectionalLight lighting_getDirectionalLight(int index) {
  switch (index) {
    case 0:
      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);
    case 1:
      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);
    case 2:
    default:   
      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);
  }
} 

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

// #endif
`; //# sourceMappingURL=lighting-uniforms-glsl.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "LIGHT_TYPE": (()=>LIGHT_TYPE),
    "lighting": (()=>lighting)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$lights$2f$lighting$2d$uniforms$2d$wgsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-uniforms-wgsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$lights$2f$lighting$2d$uniforms$2d$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-uniforms-glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
;
;
;
/** Max number of supported lights (in addition to ambient light */ const MAX_LIGHTS = 3;
/** Whether to divide */ const COLOR_FACTOR = 255.0;
var LIGHT_TYPE;
(function(LIGHT_TYPE) {
    LIGHT_TYPE[LIGHT_TYPE["POINT"] = 0] = "POINT";
    LIGHT_TYPE[LIGHT_TYPE["DIRECTIONAL"] = 1] = "DIRECTIONAL";
})(LIGHT_TYPE || (LIGHT_TYPE = {}));
const lighting = {
    props: {},
    uniforms: {},
    name: 'lighting',
    defines: {
        MAX_LIGHTS
    },
    uniformTypes: {
        enabled: 'i32',
        lightType: 'i32',
        directionalLightCount: 'i32',
        pointLightCount: 'i32',
        ambientLightColor: 'vec3<f32>',
        // TODO define as arrays once we have appropriate uniformTypes
        lightColor0: 'vec3<f32>',
        lightPosition0: 'vec3<f32>',
        // TODO - could combine direction and attenuation
        lightDirection0: 'vec3<f32>',
        lightAttenuation0: 'vec3<f32>',
        lightColor1: 'vec3<f32>',
        lightPosition1: 'vec3<f32>',
        lightDirection1: 'vec3<f32>',
        lightAttenuation1: 'vec3<f32>',
        lightColor2: 'vec3<f32>',
        lightPosition2: 'vec3<f32>',
        lightDirection2: 'vec3<f32>',
        lightAttenuation2: 'vec3<f32>'
    },
    defaultUniforms: {
        enabled: 1,
        lightType: LIGHT_TYPE.POINT,
        directionalLightCount: 0,
        pointLightCount: 0,
        ambientLightColor: [
            0.1,
            0.1,
            0.1
        ],
        lightColor0: [
            1,
            1,
            1
        ],
        lightPosition0: [
            1,
            1,
            2
        ],
        // TODO - could combine direction and attenuation
        lightDirection0: [
            1,
            1,
            1
        ],
        lightAttenuation0: [
            1,
            0,
            0
        ],
        lightColor1: [
            1,
            1,
            1
        ],
        lightPosition1: [
            1,
            1,
            2
        ],
        lightDirection1: [
            1,
            1,
            1
        ],
        lightAttenuation1: [
            1,
            0,
            0
        ],
        lightColor2: [
            1,
            1,
            1
        ],
        lightPosition2: [
            1,
            1,
            2
        ],
        lightDirection2: [
            1,
            1,
            1
        ],
        lightAttenuation2: [
            1,
            0,
            0
        ]
    },
    source: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$lights$2f$lighting$2d$uniforms$2d$wgsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lightingUniformsWGSL"],
    vs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$lights$2f$lighting$2d$uniforms$2d$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lightingUniformsGLSL"],
    fs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$lights$2f$lighting$2d$uniforms$2d$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lightingUniformsGLSL"],
    getUniforms
};
function getUniforms(props, prevUniforms = {}) {
    // Copy props so we can modify
    props = props ? {
        ...props
    } : props;
    // TODO legacy
    if (!props) {
        return {
            ...lighting.defaultUniforms
        };
    }
    // Support for array of lights. Type of light is detected by type field
    if (props.lights) {
        props = {
            ...props,
            ...extractLightTypes(props.lights),
            lights: undefined
        };
    }
    // Specify lights separately
    const { ambientLight, pointLights, directionalLights } = props || {};
    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
    // TODO - this may not be the correct decision
    if (!hasLights) {
        return {
            ...lighting.defaultUniforms,
            enabled: 0
        };
    }
    const uniforms = {
        ...lighting.defaultUniforms,
        ...prevUniforms,
        ...getLightSourceUniforms({
            ambientLight,
            pointLights,
            directionalLights
        })
    };
    if (props.enabled !== undefined) {
        uniforms.enabled = props.enabled ? 1 : 0;
    }
    return uniforms;
}
function getLightSourceUniforms({ ambientLight, pointLights = [], directionalLights = [] }) {
    const lightSourceUniforms = {};
    lightSourceUniforms.ambientLightColor = convertColor(ambientLight);
    let currentLight = 0;
    for (const pointLight of pointLights){
        lightSourceUniforms.lightType = LIGHT_TYPE.POINT;
        const i = currentLight;
        lightSourceUniforms[`lightColor${i}`] = convertColor(pointLight);
        lightSourceUniforms[`lightPosition${i}`] = pointLight.position;
        lightSourceUniforms[`lightAttenuation${i}`] = pointLight.attenuation || [
            1,
            0,
            0
        ];
        currentLight++;
    }
    for (const directionalLight of directionalLights){
        lightSourceUniforms.lightType = LIGHT_TYPE.DIRECTIONAL;
        const i = currentLight;
        lightSourceUniforms[`lightColor${i}`] = convertColor(directionalLight);
        lightSourceUniforms[`lightDirection${i}`] = directionalLight.direction;
        currentLight++;
    }
    if (currentLight > MAX_LIGHTS) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn('MAX_LIGHTS exceeded')();
    }
    lightSourceUniforms.directionalLightCount = directionalLights.length;
    lightSourceUniforms.pointLightCount = pointLights.length;
    return lightSourceUniforms;
}
function extractLightTypes(lights) {
    const lightSources = {
        pointLights: [],
        directionalLights: []
    };
    for (const light of lights || []){
        switch(light.type){
            case 'ambient':
                // Note: Only uses last ambient light
                // TODO - add ambient light sources on CPU?
                lightSources.ambientLight = light;
                break;
            case 'directional':
                lightSources.directionalLights?.push(light);
                break;
            case 'point':
                lightSources.pointLights?.push(light);
                break;
            default:
        }
    }
    return lightSources;
}
/** Take color 0-255 and intensity as input and output 0.0-1.0 range */ function convertColor(colorDef = {}) {
    const { color = [
        0,
        0,
        0
    ], intensity = 1.0 } = colorDef;
    return color.map((component)=>component * intensity / COLOR_FACTOR);
} //# sourceMappingURL=lighting.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/gouraud-material/gouraud-material.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "gouraudMaterial": (()=>gouraudMaterial)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$phong$2d$material$2f$phong$2d$shaders$2d$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$lights$2f$lighting$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting.js [app-client] (ecmascript)");
;
;
const gouraudMaterial = {
    props: {},
    name: 'gouraudMaterial',
    // Note these are switched between phong and gouraud
    vs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$phong$2d$material$2f$phong$2d$shaders$2d$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHONG_FS"].replace('phongMaterial', 'gouraudMaterial'),
    fs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$phong$2d$material$2f$phong$2d$shaders$2d$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHONG_VS"].replace('phongMaterial', 'gouraudMaterial'),
    defines: {
        LIGHTING_VERTEX: 1
    },
    dependencies: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$lights$2f$lighting$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lighting"]
    ],
    uniformTypes: {
        ambient: 'f32',
        diffuse: 'f32',
        shininess: 'f32',
        specularColor: 'vec3<f32>'
    },
    defaultUniforms: {
        ambient: 0.35,
        diffuse: 0.6,
        shininess: 32,
        specularColor: [
            0.15,
            0.15,
            0.15
        ]
    },
    getUniforms (props) {
        const uniforms = {
            ...props
        };
        if (uniforms.specularColor) {
            uniforms.specularColor = uniforms.specularColor.map((x)=>x / 255);
        }
        return {
            ...gouraudMaterial.defaultUniforms,
            ...uniforms
        };
    }
}; //# sourceMappingURL=gouraud-material.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-wgsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "PHONG_WGSL": (()=>PHONG_WGSL)
});
const PHONG_WGSL = /* wgsl */ `\
struct phongMaterialUniforms {
  ambient: f32,
  diffuse: f32,
  shininess: f32,
  specularColor: vec3<f32>,
};

@binding(2) @group(0) var<uniform> material : phongMaterialUniforms;

fn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {
  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);
  var lambertian: f32 = dot(light_direction, normal_worldspace);
  var specular: f32 = 0.0;
  if (lambertian > 0.0) {
    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

fn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {
  var lightColor: vec3<f32> = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  if (lighting.lightType == 0) {
    let pointLight: PointLight  = lighting_getPointLight(0);
    let light_position_worldspace: vec3<f32> = pointLight.position;
    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  } else if (lighting.lightType == 1) {
    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
  /*
  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.pointLightCount) {
      break;
    }
    PointLight pointLight = lighting.pointLight[i];
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  }

  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.directionalLightCount) {
      break;
    }
    DirectionalLight directionalLight = lighting.directionalLight[i];
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  */
}

fn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{
  var lightColor = vec3<f32>(0, 0, 0);
  let surfaceColor = vec3<f32>(0, 0, 0);

  if (lighting.enabled == 0) {
    let view_direction = normalize(cameraPosition - position_worldspace);

    switch (lighting.lightType) {
      case 0, default: {
        let pointLight: PointLight = lighting_getPointLight(0);
        let light_position_worldspace: vec3<f32> = pointLight.position;
        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
      }
      case 1: {
        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
      }
    }
  }
  return lightColor;
}
`; // TODO - handle multiple lights
 /**
    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting.pointLightCount) {
        break;
      }
      PointLight pointLight = lighting_getPointLight(i);
      vec3 light_position_worldspace = pointLight.position;
      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
    }

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting.directionalLightCount) {
        break;
      }
      PointLight pointLight = lighting_getDirectionalLight(i);
      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
    }
  }
    /**
    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting.pointLightCount) {
        break;
      }
      PointLight pointLight = lighting_getPointLight(i);
      vec3 light_position_worldspace = pointLight.position;
      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
    }

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting.directionalLightCount) {
        break;
      }
      PointLight pointLight = lighting_getDirectionalLight(i);
      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
    }
  }
  */  //# sourceMappingURL=phong-shaders-wgsl.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-material.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "phongMaterial": (()=>phongMaterial)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$lights$2f$lighting$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$phong$2d$material$2f$phong$2d$shaders$2d$wgsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-wgsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$phong$2d$material$2f$phong$2d$shaders$2d$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-glsl.js [app-client] (ecmascript)");
;
;
;
const phongMaterial = {
    name: 'phongMaterial',
    dependencies: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$lights$2f$lighting$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lighting"]
    ],
    // Note these are switched between phong and gouraud
    source: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$phong$2d$material$2f$phong$2d$shaders$2d$wgsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHONG_WGSL"],
    vs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$phong$2d$material$2f$phong$2d$shaders$2d$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHONG_VS"],
    fs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$phong$2d$material$2f$phong$2d$shaders$2d$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHONG_FS"],
    defines: {
        LIGHTING_FRAGMENT: 1
    },
    uniformTypes: {
        ambient: 'f32',
        diffuse: 'f32',
        shininess: 'f32',
        specularColor: 'vec3<f32>'
    },
    defaultUniforms: {
        ambient: 0.35,
        diffuse: 0.6,
        shininess: 32,
        specularColor: [
            0.15,
            0.15,
            0.15
        ]
    },
    getUniforms (props) {
        const uniforms = {
            ...props
        };
        if (uniforms.specularColor) {
            uniforms.specularColor = uniforms.specularColor.map((x)=>x / 255);
        }
        return {
            ...phongMaterial.defaultUniforms,
            ...uniforms
        };
    }
}; //# sourceMappingURL=phong-material.js.map
}}),
}]);

//# sourceMappingURL=node_modules_%40luma_gl_shadertools_dist_f2d522._.js.map