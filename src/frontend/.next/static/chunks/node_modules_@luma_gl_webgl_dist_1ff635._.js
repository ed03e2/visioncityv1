(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@luma_gl_webgl_dist_1ff635._.js", {

"[project]/node_modules/@luma.gl/webgl/dist/utils/uid.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "uid": (()=>uid)
});
const uidCounters = {};
function uid(id = 'id') {
    uidCounters[id] = uidCounters[id] || 1;
    const count = uidCounters[id]++;
    return `${id}-${count}`;
} //# sourceMappingURL=uid.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/context/helpers/webgl-extensions.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** Ensure extensions are only requested once */ __turbopack_esm__({
    "getWebGLExtension": (()=>getWebGLExtension)
});
function getWebGLExtension(gl, name, extensions) {
    if (extensions[name] === undefined) {
        extensions[name] = gl.getExtension(name) || null;
    }
    return extensions[name];
} //# sourceMappingURL=webgl-extensions.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/converters/vertex-formats.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "getGLFromVertexType": (()=>getGLFromVertexType),
    "getVertexFormatFromGL": (()=>getVertexFormatFromGL),
    "getVertexTypeFromGL": (()=>getVertexTypeFromGL)
});
;
function getVertexFormatFromGL(type, components) {
    const base = getVertexTypeFromGL(type);
    // prettier-ignore
    switch(components){
        // @ts-expect-error TODO deal with lack of formats
        case 1:
            return base;
        case 2:
            return `${base}x2`;
        // @ts-expect-error TODO deal with lack of formats
        case 3:
            return `${base}x3`;
        case 4:
            return `${base}x4`;
    }
    // @ts-ignore unreachable
    throw new Error(String(components));
}
function getVertexTypeFromGL(type, normalized = false) {
    // prettier-ignore
    switch(type){
        // WebGPU does not support normalized 32 bit integer attributes
        case 5124:
            return normalized ? 'sint32' : 'sint32';
        case 5125:
            return normalized ? 'uint32' : 'uint32';
        case 5122:
            return normalized ? 'sint16' : 'unorm16';
        case 5123:
            return normalized ? 'uint16' : 'unorm16';
        case 5120:
            return normalized ? 'sint8' : 'snorm16';
        case 5121:
            return normalized ? 'uint8' : 'unorm8';
        case 5126:
            return 'float32';
        case 5131:
            return 'float16';
    }
    // @ts-ignore unreachable
    throw new Error(String(type));
}
function getGLFromVertexType(dataType) {
    // prettier-ignore
    switch(dataType){
        case 'uint8':
            return 5121;
        case 'sint8':
            return 5120;
        case 'unorm8':
            return 5121;
        case 'snorm8':
            return 5120;
        case 'uint16':
            return 5123;
        case 'sint16':
            return 5122;
        case 'unorm16':
            return 5123;
        case 'snorm16':
            return 5122;
        case 'uint32':
            return 5125;
        case 'sint32':
            return 5124;
        // WebGPU does not support normalized 32 bit integer attributes
        // case 'unorm32': return GL.UNSIGNED_INT;
        // case 'snorm32': return GL.INT;
        case 'float16':
            return 5131;
        case 'float32':
            return 5126;
    }
    // @ts-ignore unreachable
    throw new Error(String(dataType));
} //# sourceMappingURL=vertex-formats.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/converters/webgl-texture-table.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "TEXTURE_FEATURES": (()=>TEXTURE_FEATURES),
    "WEBGL_TEXTURE_FORMATS": (()=>WEBGL_TEXTURE_FORMATS),
    "checkTextureFeature": (()=>checkTextureFeature),
    "getDepthStencilAttachmentWebGL": (()=>getDepthStencilAttachmentWebGL),
    "getTextureFormatBytesPerPixel": (()=>getTextureFormatBytesPerPixel),
    "getTextureFormatCapabilitiesWebGL": (()=>getTextureFormatCapabilitiesWebGL),
    "getTextureFormatWebGL": (()=>getTextureFormatWebGL),
    "getWebGLPixelDataFormat": (()=>getWebGLPixelDataFormat),
    "isTextureFeature": (()=>isTextureFeature),
    "isWebGLTextureFormatCapabilitiesed": (()=>isWebGLTextureFormatCapabilitiesed)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$helpers$2f$webgl$2d$extensions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/helpers/webgl-extensions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$texture$2d$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/decode-texture-format.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$vertex$2d$formats$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/converters/vertex-formats.js [app-client] (ecmascript)");
;
;
;
;
/* eslint-disable camelcase */ // TEXTURE FEATURES
// Define local webgl extension strings to optimize minification
const X_S3TC = 'WEBGL_compressed_texture_s3tc'; // BC1, BC2, BC3
const X_S3TC_SRGB = 'WEBGL_compressed_texture_s3tc_srgb'; // BC1, BC2, BC3
const X_RGTC = 'EXT_texture_compression_rgtc'; // BC4, BC5
const X_BPTC = 'EXT_texture_compression_bptc'; // BC6, BC7
const X_ETC2 = 'WEBGL_compressed_texture_etc'; // Renamed from 'WEBGL_compressed_texture_es3'
const X_ASTC = 'WEBGL_compressed_texture_astc';
const X_ETC1 = 'WEBGL_compressed_texture_etc1';
const X_PVRTC = 'WEBGL_compressed_texture_pvrtc';
const X_ATC = 'WEBGL_compressed_texture_atc';
// Define local webgl extension strings to optimize minification
const EXT_texture_norm16 = 'EXT_texture_norm16';
const EXT_render_snorm = 'EXT_render_snorm';
const EXT_color_buffer_float = 'EXT_color_buffer_float';
const TEXTURE_FEATURES = {
    'float32-renderable-webgl': [
        'EXT_color_buffer_float'
    ],
    'float16-renderable-webgl': [
        'EXT_color_buffer_half_float'
    ],
    'rgb9e5ufloat-renderable-webgl': [
        'WEBGL_render_shared_exponent'
    ],
    'snorm8-renderable-webgl': [
        EXT_render_snorm
    ],
    'norm16-renderable-webgl': [
        EXT_texture_norm16
    ],
    'snorm16-renderable-webgl': [
        EXT_texture_norm16,
        EXT_render_snorm
    ],
    'float32-filterable': [
        'OES_texture_float_linear'
    ],
    'float16-filterable-webgl': [
        'OES_texture_half_float_linear'
    ],
    'texture-filterable-anisotropic-webgl': [
        'EXT_texture_filter_anisotropic'
    ],
    'texture-blend-float-webgl': [
        'EXT_float_blend'
    ],
    'texture-compression-bc': [
        X_S3TC,
        X_S3TC_SRGB,
        X_RGTC,
        X_BPTC
    ],
    // 'texture-compression-bc3-srgb-webgl': [X_S3TC_SRGB],
    // 'texture-compression-bc3-webgl': [X_S3TC],
    'texture-compression-bc5-webgl': [
        X_RGTC
    ],
    'texture-compression-bc7-webgl': [
        X_BPTC
    ],
    'texture-compression-etc2': [
        X_ETC2
    ],
    'texture-compression-astc': [
        X_ASTC
    ],
    'texture-compression-etc1-webgl': [
        X_ETC1
    ],
    'texture-compression-pvrtc-webgl': [
        X_PVRTC
    ],
    'texture-compression-atc-webgl': [
        X_ATC
    ]
};
function isTextureFeature(feature) {
    return feature in TEXTURE_FEATURES;
}
function checkTextureFeature(gl, feature, extensions) {
    const textureExtensions = TEXTURE_FEATURES[feature] || [];
    return textureExtensions.every((extension)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$helpers$2f$webgl$2d$extensions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWebGLExtension"])(gl, extension, extensions));
}
const WEBGL_TEXTURE_FORMATS = {
    // 8-bit formats
    'r8unorm': {
        gl: 33321,
        rb: true
    },
    'r8snorm': {
        gl: 36756
    },
    'r8uint': {
        gl: 33330,
        rb: true
    },
    'r8sint': {
        gl: 33329,
        rb: true
    },
    // 16-bit formats
    'rg8unorm': {
        gl: 33323,
        rb: true
    },
    'rg8snorm': {
        gl: 36757
    },
    'rg8uint': {
        gl: 33336,
        rb: true
    },
    'rg8sint': {
        gl: 33335,
        rb: true
    },
    'r16uint': {
        gl: 33332,
        rb: true
    },
    'r16sint': {
        gl: 33331,
        rb: true
    },
    'r16float': {
        gl: 33325,
        rb: true
    },
    'r16unorm-webgl': {
        gl: 33322,
        rb: true
    },
    'r16snorm-webgl': {
        gl: 36760
    },
    // Packed 16-bit formats
    'rgba4unorm-webgl': {
        gl: 32854,
        rb: true
    },
    'rgb565unorm-webgl': {
        gl: 36194,
        rb: true
    },
    'rgb5a1unorm-webgl': {
        gl: 32855,
        rb: true
    },
    // 24-bit formats
    'rgb8unorm-webgl': {
        gl: 32849
    },
    'rgb8snorm-webgl': {
        gl: 36758
    },
    // 32-bit formats  
    'rgba8unorm': {
        gl: 32856
    },
    'rgba8unorm-srgb': {
        gl: 35907
    },
    'rgba8snorm': {
        gl: 36759
    },
    'rgba8uint': {
        gl: 36220
    },
    'rgba8sint': {
        gl: 36238
    },
    // reverse colors, webgpu only
    'bgra8unorm': {},
    'bgra8unorm-srgb': {},
    'rg16uint': {
        gl: 33338
    },
    'rg16sint': {
        gl: 33337
    },
    'rg16float': {
        gl: 33327,
        rb: true
    },
    'rg16unorm-webgl': {
        gl: 33324
    },
    'rg16snorm-webgl': {
        gl: 36761
    },
    'r32uint': {
        gl: 33334,
        rb: true
    },
    'r32sint': {
        gl: 33333,
        rb: true
    },
    'r32float': {
        gl: 33326
    },
    // Packed 32-bit formats
    'rgb9e5ufloat': {
        gl: 35901
    },
    'rg11b10ufloat': {
        gl: 35898,
        rb: true
    },
    'rgb10a2unorm': {
        gl: 32857,
        rb: true
    },
    'rgb10a2uint-webgl': {
        gl: 36975,
        rb: true
    },
    // 48-bit formats
    'rgb16unorm-webgl': {
        gl: 32852
    },
    'rgb16snorm-webgl': {
        gl: 36762
    },
    // 64-bit formats
    'rg32uint': {
        gl: 33340,
        rb: true
    },
    'rg32sint': {
        gl: 33339,
        rb: true
    },
    'rg32float': {
        gl: 33328,
        rb: true
    },
    'rgba16uint': {
        gl: 36214,
        rb: true
    },
    'rgba16sint': {
        gl: 36232,
        rb: true
    },
    'rgba16float': {
        gl: 34842
    },
    'rgba16unorm-webgl': {
        gl: 32859,
        rb: true
    },
    'rgba16snorm-webgl': {
        gl: 36763
    },
    // 96-bit formats (deprecated!)
    'rgb32float-webgl': {
        gl: 34837,
        x: EXT_color_buffer_float,
        dataFormat: 6407,
        types: [
            5126
        ]
    },
    // 128-bit formats
    'rgba32uint': {
        gl: 36208,
        rb: true
    },
    'rgba32sint': {
        gl: 36226,
        rb: true
    },
    'rgba32float': {
        gl: 34836,
        rb: true
    },
    // Depth and stencil formats
    'stencil8': {
        gl: 36168,
        rb: true
    },
    'depth16unorm': {
        gl: 33189,
        dataFormat: 6402,
        types: [
            5123
        ],
        rb: true
    },
    'depth24plus': {
        gl: 33190,
        dataFormat: 6402,
        types: [
            5125
        ]
    },
    'depth32float': {
        gl: 36012,
        dataFormat: 6402,
        types: [
            5126
        ],
        rb: true
    },
    // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
    'depth24plus-stencil8': {
        gl: 35056,
        rb: true,
        depthTexture: true,
        dataFormat: 34041,
        types: [
            34042
        ]
    },
    // "depth32float-stencil8" feature - TODO below is render buffer only?
    'depth32float-stencil8': {
        gl: 36013,
        dataFormat: 34041,
        types: [
            36269
        ],
        rb: true
    },
    // BC compressed formats: check device.features.has("texture-compression-bc");
    'bc1-rgb-unorm-webgl': {
        gl: 33776,
        x: X_S3TC
    },
    'bc1-rgb-unorm-srgb-webgl': {
        gl: 35916,
        x: X_S3TC_SRGB
    },
    'bc1-rgba-unorm': {
        gl: 33777,
        x: X_S3TC
    },
    'bc1-rgba-unorm-srgb': {
        gl: 35916,
        x: X_S3TC_SRGB
    },
    'bc2-rgba-unorm': {
        gl: 33778,
        x: X_S3TC
    },
    'bc2-rgba-unorm-srgb': {
        gl: 35918,
        x: X_S3TC_SRGB
    },
    'bc3-rgba-unorm': {
        gl: 33779,
        x: X_S3TC
    },
    'bc3-rgba-unorm-srgb': {
        gl: 35919,
        x: X_S3TC_SRGB
    },
    'bc4-r-unorm': {
        gl: 36283,
        x: X_RGTC
    },
    'bc4-r-snorm': {
        gl: 36284,
        x: X_RGTC
    },
    'bc5-rg-unorm': {
        gl: 36285,
        x: X_RGTC
    },
    'bc5-rg-snorm': {
        gl: 36286,
        x: X_RGTC
    },
    'bc6h-rgb-ufloat': {
        gl: 36495,
        x: X_BPTC
    },
    'bc6h-rgb-float': {
        gl: 36494,
        x: X_BPTC
    },
    'bc7-rgba-unorm': {
        gl: 36492,
        x: X_BPTC
    },
    'bc7-rgba-unorm-srgb': {
        gl: 36493,
        x: X_BPTC
    },
    // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
    // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
    'etc2-rgb8unorm': {
        gl: 37492
    },
    'etc2-rgb8unorm-srgb': {
        gl: 37494
    },
    'etc2-rgb8a1unorm': {
        gl: 37496
    },
    'etc2-rgb8a1unorm-srgb': {
        gl: 37497
    },
    'etc2-rgba8unorm': {
        gl: 37493
    },
    'etc2-rgba8unorm-srgb': {
        gl: 37495
    },
    'eac-r11unorm': {
        gl: 37488
    },
    'eac-r11snorm': {
        gl: 37489
    },
    'eac-rg11unorm': {
        gl: 37490
    },
    'eac-rg11snorm': {
        gl: 37491
    },
    // X_ASTC compressed formats: device.features.has("texture-compression-astc")
    'astc-4x4-unorm': {
        gl: 37808
    },
    'astc-4x4-unorm-srgb': {
        gl: 37840
    },
    'astc-5x4-unorm': {
        gl: 37809
    },
    'astc-5x4-unorm-srgb': {
        gl: 37841
    },
    'astc-5x5-unorm': {
        gl: 37810
    },
    'astc-5x5-unorm-srgb': {
        gl: 37842
    },
    'astc-6x5-unorm': {
        gl: 37811
    },
    'astc-6x5-unorm-srgb': {
        gl: 37843
    },
    'astc-6x6-unorm': {
        gl: 37812
    },
    'astc-6x6-unorm-srgb': {
        gl: 37844
    },
    'astc-8x5-unorm': {
        gl: 37813
    },
    'astc-8x5-unorm-srgb': {
        gl: 37845
    },
    'astc-8x6-unorm': {
        gl: 37814
    },
    'astc-8x6-unorm-srgb': {
        gl: 37846
    },
    'astc-8x8-unorm': {
        gl: 37815
    },
    'astc-8x8-unorm-srgb': {
        gl: 37847
    },
    'astc-10x5-unorm': {
        gl: 37819
    },
    'astc-10x5-unorm-srgb': {
        gl: 37851
    },
    'astc-10x6-unorm': {
        gl: 37817
    },
    'astc-10x6-unorm-srgb': {
        gl: 37849
    },
    'astc-10x8-unorm': {
        gl: 37818
    },
    'astc-10x8-unorm-srgb': {
        gl: 37850
    },
    'astc-10x10-unorm': {
        gl: 37819
    },
    'astc-10x10-unorm-srgb': {
        gl: 37851
    },
    'astc-12x10-unorm': {
        gl: 37820
    },
    'astc-12x10-unorm-srgb': {
        gl: 37852
    },
    'astc-12x12-unorm': {
        gl: 37821
    },
    'astc-12x12-unorm-srgb': {
        gl: 37853
    },
    // WEBGL_compressed_texture_pvrtc
    'pvrtc-rgb4unorm-webgl': {
        gl: 35840
    },
    'pvrtc-rgba4unorm-webgl': {
        gl: 35842
    },
    'pvrtc-rbg2unorm-webgl': {
        gl: 35841
    },
    'pvrtc-rgba2unorm-webgl': {
        gl: 35843
    },
    // WEBGL_compressed_texture_etc1
    'etc1-rbg-unorm-webgl': {
        gl: 36196
    },
    // WEBGL_compressed_texture_atc
    'atc-rgb-unorm-webgl': {
        gl: 35986
    },
    'atc-rgba-unorm-webgl': {
        gl: 35986
    },
    'atc-rgbai-unorm-webgl': {
        gl: 34798
    }
};
function isWebGLTextureFormatCapabilitiesed(gl, format, extensions) {
    const webglTextureInfo = WEBGL_TEXTURE_FORMATS[format];
    // Check that we have a GL constant
    if (!webglTextureInfo?.gl) {
        return false;
    }
    // Check extensions
    const extension = webglTextureInfo.x;
    if (extension) {
        return Boolean((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$helpers$2f$webgl$2d$extensions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWebGLExtension"])(gl, extension, extensions));
    }
    return true;
}
function getTextureFormatCapabilitiesWebGL(gl, formatSupport, extensions) {
    let supported = formatSupport.create;
    const webglFormatInfo = WEBGL_TEXTURE_FORMATS[formatSupport.format];
    // Support Check that we have a GL constant
    if (webglFormatInfo?.gl === undefined) {
        supported = false;
    }
    if (webglFormatInfo?.x) {
        supported = supported && Boolean((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$helpers$2f$webgl$2d$extensions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWebGLExtension"])(gl, webglFormatInfo.x, extensions));
    }
    return {
        format: formatSupport.format,
        // @ts-ignore
        create: supported && formatSupport.create,
        // @ts-ignore
        render: supported && formatSupport.render,
        // @ts-ignore
        filter: supported && formatSupport.filter,
        // @ts-ignore
        blend: supported && formatSupport.blend,
        // @ts-ignore
        store: supported && formatSupport.store
    };
}
function getTextureFormatWebGL(format) {
    const formatData = WEBGL_TEXTURE_FORMATS[format];
    const webglFormat = convertTextureFormatToGL(format);
    const decoded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$texture$2d$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeTextureFormat"])(format);
    return {
        internalFormat: webglFormat,
        format: formatData?.dataFormat || getWebGLPixelDataFormat(decoded.channels, decoded.integer, decoded.normalized, webglFormat),
        // depth formats don't have a type
        type: decoded.dataType ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$vertex$2d$formats$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGLFromVertexType"])(decoded.dataType) : formatData?.types?.[0] || 5121,
        compressed: decoded.compressed || false
    };
}
function getDepthStencilAttachmentWebGL(format) {
    const formatInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$texture$2d$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeTextureFormat"])(format);
    switch(formatInfo.attachment){
        case 'depth':
            return 36096;
        case 'stencil':
            return 36128;
        case 'depth-stencil':
            return 33306;
        default:
            throw new Error(`Not a depth stencil format: ${format}`);
    }
}
function getTextureFormatBytesPerPixel(format) {
    const formatInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$decode$2d$texture$2d$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeTextureFormat"])(format);
    return formatInfo.bytesPerPixel;
}
function getWebGLPixelDataFormat(channels, integer, normalized, format) {
    // WebGL1 formats use same internalFormat
    if (format === 6408 || format === 6407) {
        return format;
    }
    // prettier-ignore
    switch(channels){
        case 'r':
            return integer && !normalized ? 36244 : 6403;
        case 'rg':
            return integer && !normalized ? 33320 : 33319;
        case 'rgb':
            return integer && !normalized ? 36248 : 6407;
        case 'rgba':
            return integer && !normalized ? 36249 : 6408;
        case 'bgra':
            throw new Error('bgra pixels not supported by WebGL');
        default:
            return 6408;
    }
}
/**
 * Map WebGPU style texture format strings to GL constants
 */ function convertTextureFormatToGL(format) {
    const formatInfo = WEBGL_TEXTURE_FORMATS[format];
    const webglFormat = formatInfo?.gl;
    if (webglFormat === undefined) {
        throw new Error(`Unsupported texture format ${format}`);
    }
    return webglFormat;
} //# sourceMappingURL=webgl-texture-table.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-framebuffer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "WEBGLFramebuffer": (()=>WEBGLFramebuffer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$webgl$2d$texture$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/converters/webgl-texture-table.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/framebuffer.js [app-client] (ecmascript)");
;
;
;
class WEBGLFramebuffer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Framebuffer"] {
    device;
    gl;
    handle;
    colorAttachments = [];
    depthStencilAttachment = null;
    constructor(device, props){
        super(device, props);
        // WebGL default framebuffer handle is null
        const isDefaultFramebuffer = props.handle === null;
        this.device = device;
        this.gl = device.gl;
        this.handle = this.props.handle || isDefaultFramebuffer ? this.props.handle : this.gl.createFramebuffer();
        if (!isDefaultFramebuffer) {
            // default framebuffer handle is null, so we can't set spector metadata...
            device.setSpectorMetadata(this.handle, {
                id: this.props.id,
                props: this.props
            });
            // Auto create textures for attachments if needed
            this.autoCreateAttachmentTextures();
            this.updateAttachments();
        }
    }
    /** destroys any auto created resources etc. */ destroy() {
        super.destroy(); // destroys owned resources etc.
        if (!this.destroyed && this.handle !== null) {
            this.gl.deleteFramebuffer(this.handle);
        // this.handle = null;
        }
    }
    updateAttachments() {
        /** Attach from a map of attachments */ // @ts-expect-error native bindFramebuffer is overridden by our state tracker
        const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
        // Walk the attachments
        for(let i = 0; i < this.colorAttachments.length; ++i){
            const attachment = this.colorAttachments[i];
            if (attachment) {
                const attachmentPoint = 36064 + i;
                this._attachTextureView(attachmentPoint, attachment);
            }
        }
        if (this.depthStencilAttachment) {
            const attachmentPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$webgl$2d$texture$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDepthStencilAttachmentWebGL"])(this.depthStencilAttachment.props.format);
            this._attachTextureView(attachmentPoint, this.depthStencilAttachment);
        }
        /** Check the status */ if (this.device.props.debug) {
            const status = this.gl.checkFramebufferStatus(36160);
            if (status !== 36053) {
                throw new Error(`Framebuffer ${_getFrameBufferStatus(status)}`);
            }
        }
        this.gl.bindFramebuffer(36160, prevHandle);
    }
    // PRIVATE
    /** In WebGL we must use renderbuffers for depth/stencil attachments (unless we have extensions) */ // protected override createDepthStencilTexture(format: TextureFormat): Texture {
    //   // return new WEBGLRenderbuffer(this.device, {
    //   return new WEBGLTexture(this.device, {
    //     id: `${this.id}-depth-stencil`,
    //     format,
    //     width: this.width,
    //     height: this.height,
    //     mipmaps: false
    //   });
    // }
    /**
     * @param attachment
     * @param texture
     * @param layer = 0 - index into WEBGLTextureArray and Texture3D or face for `TextureCubeMap`
     * @param level = 0 - mipmapLevel
     */ _attachTextureView(attachment, textureView) {
        const { gl } = this.device;
        const { texture } = textureView;
        const level = textureView.props.baseMipLevel;
        const layer = textureView.props.baseArrayLayer;
        gl.bindTexture(texture.glTarget, texture.handle);
        switch(texture.glTarget){
            case 35866:
            case 32879:
                gl.framebufferTextureLayer(36160, attachment, texture.handle, level, layer);
                break;
            case 34067:
                // layer must be a cubemap face (or if index, converted to cube map face)
                const face = mapIndexToCubeMapFace(layer);
                gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
                break;
            case 3553:
                gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
                break;
            default:
                throw new Error('Illegal texture type');
        }
        gl.bindTexture(texture.glTarget, null);
    }
}
// Helper functions
// Map an index to a cube map face constant
function mapIndexToCubeMapFace(layer) {
    // TEXTURE_CUBE_MAP_POSITIVE_X is a big value (0x8515)
    // if smaller assume layer is index, otherwise assume it is already a cube map face constant
    return layer < 34069 ? layer + 34069 : layer;
}
// Helper METHODS
// Get a string describing the framebuffer error if installed
function _getFrameBufferStatus(status) {
    switch(status){
        case 36053:
            return 'success';
        case 36054:
            return 'Mismatched attachments';
        case 36055:
            return 'No attachments';
        case 36057:
            return 'Height/width mismatch';
        case 36061:
            return 'Unsupported or split attachments';
        // WebGL2
        case 36182:
            return 'Samples mismatch';
        // OVR_multiview2 extension
        // case GL.FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR: return 'baseViewIndex mismatch';
        default:
            return `${status}`;
    }
} /**
 * Attachment resize is expected to be a noop if size is same
 *
protected override resizeAttachments(width: number, height: number): this {
  // for default framebuffer, just update the stored size
  if (this.handle === null) {
    // assert(width === undefined && height === undefined);
    this.width = this.gl.drawingBufferWidth;
    this.height = this.gl.drawingBufferHeight;
    return this;
  }

  if (width === undefined) {
    width = this.gl.drawingBufferWidth;
  }
  if (height === undefined) {
    height = this.gl.drawingBufferHeight;
  }

  // TODO Not clear that this is better than default destroy/create implementation

  for (const colorAttachment of this.colorAttachments) {
    colorAttachment.texture.clone({width, height});
  }
  if (this.depthStencilAttachment) {
    this.depthStencilAttachment.texture.resize({width, height});
  }
  return this;
}
*/  //# sourceMappingURL=webgl-framebuffer.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/webgl-canvas-context.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "WebGLCanvasContext": (()=>WebGLCanvasContext)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-framebuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$canvas$2d$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/canvas-context.js [app-client] (ecmascript)");
;
;
class WebGLCanvasContext extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$canvas$2d$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CanvasContext"] {
    device;
    format = 'rgba8unorm';
    depthStencilFormat = 'depth24plus';
    presentationSize;
    _framebuffer = null;
    get [Symbol.toStringTag]() {
        return 'WebGLCanvasContext';
    }
    constructor(device, props){
        // Note: Base class creates / looks up the canvas (unless under Node.js)
        super(props);
        this.device = device;
        this.presentationSize = [
            -1,
            -1
        ];
        this._setAutoCreatedCanvasId(`${this.device.id}-canvas`);
        this.update();
    }
    getCurrentFramebuffer() {
        this.update();
        // Setting handle to null returns a reference to the default framebuffer
        this._framebuffer = this._framebuffer || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLFramebuffer"](this.device, {
            handle: null
        });
        return this._framebuffer;
    }
    /** Resizes and updates render targets if necessary */ update() {
        const size = this.getPixelSize();
        const sizeChanged = size[0] !== this.presentationSize[0] || size[1] !== this.presentationSize[1];
        if (sizeChanged) {
            this.presentationSize = size;
            this.resize();
        }
    }
    /**
     * Resize the canvas' drawing buffer.
     *
     * Can match the canvas CSS size, and optionally also consider devicePixelRatio
     * Can be called every frame
     *
     * Regardless of size, the drawing buffer will always be scaled to the viewport, but
     * for best visual results, usually set to either:
     *  canvas CSS width x canvas CSS height
     *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio
     * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
     */ resize(options) {
        if (!this.device.gl) return;
        // Resize browser context .
        if (this.canvas) {
            const devicePixelRatio = this.getDevicePixelRatio(options?.useDevicePixels);
            this.setDevicePixelRatio(devicePixelRatio, options);
            return;
        }
    }
    commit() {
    // gl.commit was ultimately removed from the WebGL standard??
    // if (this.offScreen && this.gl.commit) {
    //   // @ts-expect-error gl.commit is not officially part of WebGL2RenderingContext
    //   this.gl.commit();
    // }
    }
} //# sourceMappingURL=webgl-canvas-context.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/context/helpers/create-browser-context.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 * Create a WebGL context for a canvas
 * Note calling this multiple time on the same canvas does return the same context
 * @param canvas A canvas element or offscreen canvas
 */ __turbopack_esm__({
    "createBrowserContext": (()=>createBrowserContext)
});
function createBrowserContext(canvas, props, webglContextAttributes) {
    // Try to extract any extra information about why context creation failed
    let errorMessage = '';
    // const onCreateError = error => (errorMessage = error.statusMessage || errorMessage);
    // Avoid multiple listeners?
    // canvas.removeEventListener('webglcontextcreationerror', onCreateError, false);
    // canvas.addEventListener('webglcontextcreationerror', onCreateError, false);
    const webglProps = {
        preserveDrawingBuffer: true,
        // failIfMajorPerformanceCaveat: true,
        ...webglContextAttributes
    };
    // Create the desired context
    let gl = null;
    // Create a webgl2 context
    gl ||= canvas.getContext('webgl2', webglProps);
    if (webglProps.failIfMajorPerformanceCaveat) {
        errorMessage ||= 'Only software GPU is available. Set `failIfMajorPerformanceCaveat: false` to allow.';
    }
    // Creation failed with failIfMajorPerformanceCaveat - Try a Software GPU
    if (!gl && !webglContextAttributes.failIfMajorPerformanceCaveat) {
        webglProps.failIfMajorPerformanceCaveat = false;
        gl = canvas.getContext('webgl2', webglProps);
        // @ts-expect-error
        gl.luma ||= {};
        // @ts-expect-error
        gl.luma.softwareRenderer = true;
    }
    if (!gl) {
        gl = canvas.getContext('webgl', {});
        if (gl) {
            gl = null;
            errorMessage ||= 'Your browser only supports WebGL1';
        }
    }
    if (!gl) {
        errorMessage ||= 'Your browser does not support WebGL';
        throw new Error(`Failed to create WebGL context: ${errorMessage}`);
    }
    // Carefully extract and wrap callbacks to prevent addEventListener from rebinding them.
    const { onContextLost, onContextRestored } = props;
    canvas.addEventListener('webglcontextlost', (event)=>onContextLost(event), false);
    canvas.addEventListener('webglcontextrestored', (event)=>onContextRestored(event), false);
    // @ts-expect-error
    gl.luma ||= {};
    return gl;
} /* TODO - can we call this asynchronously to catch the error events?
export async function createBrowserContextAsync(canvas: HTMLCanvasElement | OffscreenCanvas, props: ContextProps): Promise<WebGL2RenderingContext> {
  props = {...DEFAULT_CONTEXT_PROPS, ...props};

 // Try to extract any extra information about why context creation failed
 let errorMessage = null;
 const onCreateError = (error) => (errorMessage = error.statusMessage || errorMessage);
 canvas.addEventListener('webglcontextcreationerror', onCreateError, false);

 const gl = createBrowserContext(canvas, props);

 // Give the listener a chance to fire
 await new Promise(resolve => setTimeout(resolve, 0));

 canvas.removeEventListener('webglcontextcreationerror', onCreateError, false);

 return gl;
}
*/  //# sourceMappingURL=create-browser-context.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/utils/load-script.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 * Load a script (identified by an url). When the url returns, the
 * content of this file is added into a new script element, attached to the DOM (body element)
 * @param scriptUrl defines the url of the script to laod
 * @param scriptId defines the id of the script element
 */ __turbopack_esm__({
    "loadScript": (()=>loadScript)
});
async function loadScript(scriptUrl, scriptId) {
    const head = document.getElementsByTagName('head')[0];
    if (!head) {
        throw new Error('loadScript');
    }
    const script = document.createElement('script');
    script.setAttribute('type', 'text/javascript');
    script.setAttribute('src', scriptUrl);
    if (scriptId) {
        script.id = scriptId;
    }
    return new Promise((resolve, reject)=>{
        script.onload = resolve;
        script.onerror = (error)=>reject(new Error(`Unable to load script '${scriptUrl}': ${error}`));
        head.appendChild(script);
    });
} //# sourceMappingURL=load-script.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/context/debug/spector.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "DEFAULT_SPECTOR_PROPS": (()=>DEFAULT_SPECTOR_PROPS),
    "initializeSpectorJS": (()=>initializeSpectorJS),
    "loadSpectorJS": (()=>loadSpectorJS)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$utils$2f$load$2d$script$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/utils/load-script.js [app-client] (ecmascript)");
;
;
const LOG_LEVEL = 1;
let spector = null;
let initialized = false;
const DEFAULT_SPECTOR_PROPS = {
    debugSpectorJS: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].get('debug-spectorjs'),
    // https://github.com/BabylonJS/Spector.js#basic-usage
    // https://forum.babylonjs.com/t/spectorcdn-is-temporarily-off/48241
    // spectorUrl: 'https://spectorcdn.babylonjs.com/spector.bundle.js';
    debugSpectorJSUrl: 'https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js',
    gl: undefined
};
async function loadSpectorJS(props) {
    if (!globalThis.SPECTOR) {
        try {
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$utils$2f$load$2d$script$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["loadScript"])(props.debugSpectorJSUrl || DEFAULT_SPECTOR_PROPS.debugSpectorJSUrl);
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(String(error));
        }
    }
}
function initializeSpectorJS(props) {
    props = {
        ...DEFAULT_SPECTOR_PROPS,
        ...props
    };
    if (!props.debugSpectorJS) {
        return null;
    }
    if (!spector && globalThis.SPECTOR && !globalThis.luma?.spector) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].probe(LOG_LEVEL, 'SPECTOR found and initialized. Start with `luma.spector.displayUI()`')();
        const { Spector: SpectorJS } = globalThis.SPECTOR;
        spector = new SpectorJS();
        if (globalThis.luma) {
            globalThis.luma.spector = spector;
        }
    }
    if (!spector) {
        return null;
    }
    if (!initialized) {
        initialized = true;
        // enables recording some extra information merged in the capture like texture memory sizes and formats
        spector.spyCanvases();
        // A callback when results are ready
        spector?.onCaptureStarted.add((capture)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].info('Spector capture started:', capture)());
        spector?.onCapture.add((capture)=>{
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].info('Spector capture complete:', capture)();
            // Use undocumented Spector API to open the UI with our capture
            // See https://github.com/BabylonJS/Spector.js/blob/767ad1195a25b85a85c381f400eb50a979239eca/src/spector.ts#L124
            spector?.getResultUI();
            // @ts-expect-error private
            spector?.resultView.display();
            // @ts-expect-error private
            spector?.resultView.addCapture(capture);
        });
    }
    if (props.gl) {
        // capture startup
        const gl = props.gl;
        // @ts-expect-error
        const device = gl.device;
        spector?.startCapture(props.gl, 500); // 500 commands
        // @ts-expect-error
        gl.device = device;
        new Promise((resolve)=>setTimeout(resolve, 2000)).then((_)=>{
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].info('Spector capture stopped after 2 seconds')();
            spector?.stopCapture();
        // spector?.displayUI();
        });
    }
    return spector;
} //# sourceMappingURL=spector.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-info.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "getDeviceInfo": (()=>getDeviceInfo)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$helpers$2f$webgl$2d$extensions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/helpers/webgl-extensions.js [app-client] (ecmascript)");
;
;
function getDeviceInfo(gl, extensions) {
    // "Masked" info is always available, but don't contain much useful information
    const vendorMasked = gl.getParameter(7936);
    const rendererMasked = gl.getParameter(7937);
    // If we are lucky, unmasked info is available
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_debug_renderer_info/
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$helpers$2f$webgl$2d$extensions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWebGLExtension"])(gl, 'WEBGL_debug_renderer_info', extensions);
    const ext = extensions.WEBGL_debug_renderer_info;
    const vendorUnmasked = gl.getParameter(ext ? ext.UNMASKED_VENDOR_WEBGL : 7936);
    const rendererUnmasked = gl.getParameter(ext ? ext.UNMASKED_RENDERER_WEBGL : 7937);
    const vendor = vendorUnmasked || vendorMasked;
    const renderer = rendererUnmasked || rendererMasked;
    // Driver version
    const version = gl.getParameter(7938);
    // "Sniff" the GPU type and backend from the info. This works best if unmasked info is available.
    const gpu = identifyGPUVendor(vendor, renderer);
    const gpuBackend = identifyGPUBackend(vendor, renderer);
    const gpuType = identifyGPUType(vendor, renderer);
    // Determine GLSL version
    // For now, skip parsing of the long version string, just use context type below to deduce version
    // const version = gl.getParameter(GL.SHADING_LANGUAGE_VERSION) as string;
    // const shadingLanguageVersion = parseGLSLVersion(version);
    const shadingLanguage = 'glsl';
    const shadingLanguageVersion = 300;
    return {
        type: 'webgl',
        gpu,
        gpuType,
        gpuBackend,
        vendor,
        renderer,
        version,
        shadingLanguage,
        shadingLanguageVersion
    };
}
/** "Sniff" the GPU type from the info. This works best if unmasked info is available. */ function identifyGPUVendor(vendor, renderer) {
    if (/NVIDIA/i.exec(vendor) || /NVIDIA/i.exec(renderer)) {
        return 'nvidia';
    }
    if (/INTEL/i.exec(vendor) || /INTEL/i.exec(renderer)) {
        return 'intel';
    }
    if (/Apple/i.exec(vendor) || /Apple/i.exec(renderer)) {
        return 'apple';
    }
    if (/AMD/i.exec(vendor) || /AMD/i.exec(renderer) || /ATI/i.exec(vendor) || /ATI/i.exec(renderer)) {
        return 'amd';
    }
    if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
        return 'software';
    }
    return 'unknown';
}
/** "Sniff" the GPU backend from the info. This works best if unmasked info is available. */ function identifyGPUBackend(vendor, renderer) {
    if (/Metal/i.exec(vendor) || /Metal/i.exec(renderer)) {
        return 'metal';
    }
    if (/ANGLE/i.exec(vendor) || /ANGLE/i.exec(renderer)) {
        return 'opengl';
    }
    return 'unknown';
}
function identifyGPUType(vendor, renderer) {
    if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
        return 'cpu';
    }
    const gpuVendor = identifyGPUVendor(vendor, renderer);
    switch(gpuVendor){
        case 'intel':
            return 'integrated';
        case 'software':
            return 'cpu';
        case 'unknown':
            return 'unknown';
        default:
            return 'discrete';
    }
} //# sourceMappingURL=webgl-device-info.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-limits.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "WebGLDeviceLimits": (()=>WebGLDeviceLimits)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/device.js [app-client] (ecmascript)");
;
;
class WebGLDeviceLimits extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DeviceLimits"] {
    get maxTextureDimension1D() {
        return 0;
    }
    get maxTextureDimension2D() {
        return this.getParameter(3379);
    }
    get maxTextureDimension3D() {
        return this.getParameter(32883);
    }
    get maxTextureArrayLayers() {
        return this.getParameter(35071);
    }
    get maxBindGroups() {
        return 0;
    }
    get maxDynamicUniformBuffersPerPipelineLayout() {
        return 0;
    }
    get maxDynamicStorageBuffersPerPipelineLayout() {
        return 0;
    }
    get maxSampledTexturesPerShaderStage() {
        return this.getParameter(35660);
    }
    get maxSamplersPerShaderStage() {
        return this.getParameter(35661);
    }
    get maxStorageBuffersPerShaderStage() {
        return 0;
    }
    get maxStorageTexturesPerShaderStage() {
        return 0;
    }
    get maxUniformBuffersPerShaderStage() {
        return this.getParameter(35375);
    }
    get maxUniformBufferBindingSize() {
        return this.getParameter(35376);
    }
    get maxStorageBufferBindingSize() {
        return 0;
    }
    get minUniformBufferOffsetAlignment() {
        return this.getParameter(35380);
    }
    get minStorageBufferOffsetAlignment() {
        return 0;
    }
    get maxVertexBuffers() {
        return 16;
    }
    get maxVertexAttributes() {
        return this.getParameter(34921);
    }
    get maxVertexBufferArrayStride() {
        return 2048;
    }
    get maxInterStageShaderComponents() {
        return this.getParameter(35659);
    }
    get maxComputeWorkgroupStorageSize() {
        return 0;
    }
    get maxComputeInvocationsPerWorkgroup() {
        return 0;
    }
    get maxComputeWorkgroupSizeX() {
        return 0;
    }
    get maxComputeWorkgroupSizeY() {
        return 0;
    }
    get maxComputeWorkgroupSizeZ() {
        return 0;
    }
    get maxComputeWorkgroupsPerDimension() {
        return 0;
    }
    // PRIVATE
    gl;
    limits = {};
    constructor(gl){
        super();
        this.gl = gl;
    }
    getParameter(parameter) {
        if (this.limits[parameter] === undefined) {
            this.limits[parameter] = this.gl.getParameter(parameter);
        }
        return this.limits[parameter] || 0;
    }
} //# sourceMappingURL=webgl-device-limits.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-features.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Feature detection for WebGL
// Provides a function that enables simple checking of which WebGL features are
__turbopack_esm__({
    "WebGLDeviceFeatures": (()=>WebGLDeviceFeatures)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$helpers$2f$webgl$2d$extensions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/helpers/webgl-extensions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$webgl$2d$texture$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/converters/webgl-texture-table.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/device.js [app-client] (ecmascript)");
;
;
;
/**
 * Defines luma.gl "feature" names and semantics
 * when value is 'string' it is the name of the extension that enables this feature
 */ const WEBGL_FEATURES = {
    // optional WebGPU features
    'depth-clip-control': 'EXT_depth_clamp',
    // 'timestamp-query' // GPUQueryType "timestamp-query"
    // "indirect-first-instance"
    // Textures are handled by getTextureFeatures()
    // 'depth32float-stencil8' // GPUTextureFormat 'depth32float-stencil8'
    // optional WebGL features
    'timer-query-webgl': 'EXT_disjoint_timer_query_webgl2',
    'compilation-status-async-webgl': 'KHR_parallel_shader_compile',
    'polygon-mode-webgl': 'WEBGL_polygon_mode',
    'provoking-vertex-webgl': 'WEBGL_provoking_vertex',
    'shader-clip-cull-distance-webgl': 'WEBGL_clip_cull_distance',
    'shader-noperspective-interpolation-webgl': 'NV_shader_noperspective_interpolation',
    'shader-conservative-depth-webgl': 'EXT_conservative_depth'
};
class WebGLDeviceFeatures extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DeviceFeatures"] {
    gl;
    extensions;
    testedFeatures = new Set();
    constructor(gl, extensions, disabledFeatures){
        super([], disabledFeatures);
        this.gl = gl;
        this.extensions = extensions;
        // TODO - is this really needed?
        // Enable EXT_float_blend first: https://developer.mozilla.org/en-US/docs/Web/API/EXT_float_blend
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$helpers$2f$webgl$2d$extensions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWebGLExtension"])(gl, 'EXT_color_buffer_float', extensions);
    }
    *[Symbol.iterator]() {
        const features = this.getFeatures();
        for (const feature of features){
            if (this.has(feature)) {
                yield feature;
            }
        }
        return [];
    }
    has(feature) {
        if (this.disabledFeatures?.[feature]) {
            return false;
        }
        // We have already tested this feature
        if (!this.testedFeatures.has(feature)) {
            this.testedFeatures.add(feature);
            // Check the feature once
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$webgl$2d$texture$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextureFeature"])(feature) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$webgl$2d$texture$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checkTextureFeature"])(this.gl, feature, this.extensions)) {
                this.features.add(feature);
            }
            if (this.getWebGLFeature(feature)) {
                this.features.add(feature);
            }
        }
        return this.features.has(feature);
    }
    // FOR DEVICE
    initializeFeatures() {
        // Initialize all features by checking them.
        // Except WEBGL_polygon_mode since Chrome logs ugly console warnings
        const features = this.getFeatures().filter((feature)=>feature !== 'polygon-mode-webgl');
        for (const feature of features){
            this.has(feature);
        }
    }
    // IMPLEMENTATION
    getFeatures() {
        return [
            ...Object.keys(WEBGL_FEATURES),
            ...Object.keys(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$webgl$2d$texture$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TEXTURE_FEATURES"])
        ];
    }
    /** Extract all WebGL features */ getWebGLFeature(feature) {
        const featureInfo = WEBGL_FEATURES[feature];
        // string value requires checking the corresponding WebGL extension
        const isSupported = typeof featureInfo === 'string' ? Boolean((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$helpers$2f$webgl$2d$extensions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWebGLExtension"])(this.gl, featureInfo, this.extensions)) : Boolean(featureInfo);
        return isSupported;
    }
} //# sourceMappingURL=webgl-device-features.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/context/parameters/webgl-parameter-tables.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Tables describing WebGL parameters
__turbopack_esm__({
    "GL_COMPOSITE_PARAMETER_SETTERS": (()=>GL_COMPOSITE_PARAMETER_SETTERS),
    "GL_HOOKED_SETTERS": (()=>GL_HOOKED_SETTERS),
    "GL_PARAMETER_DEFAULTS": (()=>GL_PARAMETER_DEFAULTS),
    "GL_PARAMETER_GETTERS": (()=>GL_PARAMETER_GETTERS),
    "GL_PARAMETER_SETTERS": (()=>GL_PARAMETER_SETTERS),
    "NON_CACHE_PARAMETERS": (()=>NON_CACHE_PARAMETERS)
});
;
const GL_PARAMETER_DEFAULTS = {
    [3042]: false,
    [32773]: new Float32Array([
        0,
        0,
        0,
        0
    ]),
    [32777]: 32774,
    [34877]: 32774,
    [32969]: 1,
    [32968]: 0,
    [32971]: 1,
    [32970]: 0,
    [3106]: new Float32Array([
        0,
        0,
        0,
        0
    ]),
    [3107]: [
        true,
        true,
        true,
        true
    ],
    [2884]: false,
    [2885]: 1029,
    [2929]: false,
    [2931]: 1,
    [2932]: 513,
    [2928]: new Float32Array([
        0,
        1
    ]),
    [2930]: true,
    [3024]: true,
    [35725]: null,
    // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
    [36006]: null,
    [36007]: null,
    [34229]: null,
    [34964]: null,
    [2886]: 2305,
    [33170]: 4352,
    [2849]: 1,
    [32823]: false,
    [32824]: 0,
    [10752]: 0,
    [32926]: false,
    [32928]: false,
    [32938]: 1.0,
    [32939]: false,
    [3089]: false,
    // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
    [3088]: new Int32Array([
        0,
        0,
        1024,
        1024
    ]),
    [2960]: false,
    [2961]: 0,
    [2968]: 0xffffffff,
    [36005]: 0xffffffff,
    [2962]: 519,
    [2967]: 0,
    [2963]: 0xffffffff,
    [34816]: 519,
    [36003]: 0,
    [36004]: 0xffffffff,
    [2964]: 7680,
    [2965]: 7680,
    [2966]: 7680,
    [34817]: 7680,
    [34818]: 7680,
    [34819]: 7680,
    // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
    [2978]: [
        0,
        0,
        1024,
        1024
    ],
    [36389]: null,
    [36662]: null,
    [36663]: null,
    [35053]: null,
    [35055]: null,
    [35723]: 4352,
    [36010]: null,
    [35977]: false,
    [3333]: 4,
    [3317]: 4,
    [37440]: false,
    [37441]: false,
    [37443]: 37444,
    [3330]: 0,
    [3332]: 0,
    [3331]: 0,
    [3314]: 0,
    [32878]: 0,
    [3316]: 0,
    [3315]: 0,
    [32877]: 0
};
// SETTER TABLES - ENABLES SETTING ANY PARAMETER WITH A COMMON API
const enable = (gl, value, key)=>value ? gl.enable(key) : gl.disable(key);
const hint = (gl, value, key)=>gl.hint(key, value);
const pixelStorei = (gl, value, key)=>gl.pixelStorei(key, value);
const bindFramebuffer = (gl, value, key)=>{
    const target = key === 36006 ? 36009 : 36008;
    return gl.bindFramebuffer(target, value);
};
const bindBuffer = (gl, value, key)=>{
    const bindingMap = {
        [34964]: 34962,
        [36662]: 36662,
        [36663]: 36663,
        [35053]: 35051,
        [35055]: 35052
    };
    const glTarget = bindingMap[key];
    gl.bindBuffer(glTarget, value);
};
// Utility
function isArray(array) {
    return Array.isArray(array) || ArrayBuffer.isView(array) && !(array instanceof DataView);
}
const GL_PARAMETER_SETTERS = {
    [3042]: enable,
    [32773]: (gl, value)=>gl.blendColor(...value),
    [32777]: 'blendEquation',
    [34877]: 'blendEquation',
    [32969]: 'blendFunc',
    [32968]: 'blendFunc',
    [32971]: 'blendFunc',
    [32970]: 'blendFunc',
    [3106]: (gl, value)=>gl.clearColor(...value),
    [3107]: (gl, value)=>gl.colorMask(...value),
    [2884]: enable,
    [2885]: (gl, value)=>gl.cullFace(value),
    [2929]: enable,
    [2931]: (gl, value)=>gl.clearDepth(value),
    [2932]: (gl, value)=>gl.depthFunc(value),
    [2928]: (gl, value)=>gl.depthRange(...value),
    [2930]: (gl, value)=>gl.depthMask(value),
    [3024]: enable,
    [35723]: hint,
    [35725]: (gl, value)=>gl.useProgram(value),
    [36007]: (gl, value)=>gl.bindRenderbuffer(36161, value),
    [36389]: (gl, value)=>gl.bindTransformFeedback?.(36386, value),
    [34229]: (gl, value)=>gl.bindVertexArray(value),
    // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
    [36006]: bindFramebuffer,
    [36010]: bindFramebuffer,
    // Buffers
    [34964]: bindBuffer,
    [36662]: bindBuffer,
    [36663]: bindBuffer,
    [35053]: bindBuffer,
    [35055]: bindBuffer,
    [2886]: (gl, value)=>gl.frontFace(value),
    [33170]: hint,
    [2849]: (gl, value)=>gl.lineWidth(value),
    [32823]: enable,
    [32824]: 'polygonOffset',
    [10752]: 'polygonOffset',
    [35977]: enable,
    [32926]: enable,
    [32928]: enable,
    [32938]: 'sampleCoverage',
    [32939]: 'sampleCoverage',
    [3089]: enable,
    [3088]: (gl, value)=>gl.scissor(...value),
    [2960]: enable,
    [2961]: (gl, value)=>gl.clearStencil(value),
    [2968]: (gl, value)=>gl.stencilMaskSeparate(1028, value),
    [36005]: (gl, value)=>gl.stencilMaskSeparate(1029, value),
    [2962]: 'stencilFuncFront',
    [2967]: 'stencilFuncFront',
    [2963]: 'stencilFuncFront',
    [34816]: 'stencilFuncBack',
    [36003]: 'stencilFuncBack',
    [36004]: 'stencilFuncBack',
    [2964]: 'stencilOpFront',
    [2965]: 'stencilOpFront',
    [2966]: 'stencilOpFront',
    [34817]: 'stencilOpBack',
    [34818]: 'stencilOpBack',
    [34819]: 'stencilOpBack',
    [2978]: (gl, value)=>gl.viewport(...value),
    // WEBGL2 EXTENSIONS
    // EXT_depth_clamp https://registry.khronos.org/webgl/extensions/EXT_depth_clamp/
    [34383]: enable,
    // WEBGL_provoking_vertex https://registry.khronos.org/webgl/extensions/WEBGL_provoking_vertex/
    // [GL.PROVOKING_VERTEX_WEBL]: TODO - extension function needed
    // WEBGL_polygon_mode https://registry.khronos.org/webgl/extensions/WEBGL_polygon_mode/
    // POLYGON_MODE_WEBGL  TODO - extension function needed
    [10754]: enable,
    // WEBGL_clip_cull_distance https://registry.khronos.org/webgl/extensions/WEBGL_clip_cull_distance/
    [12288]: enable,
    [12289]: enable,
    [12290]: enable,
    [12291]: enable,
    [12292]: enable,
    [12293]: enable,
    [12294]: enable,
    [12295]: enable,
    // PIXEL PACK/UNPACK MODES
    [3333]: pixelStorei,
    [3317]: pixelStorei,
    [37440]: pixelStorei,
    [37441]: pixelStorei,
    [37443]: pixelStorei,
    [3330]: pixelStorei,
    [3332]: pixelStorei,
    [3331]: pixelStorei,
    [3314]: pixelStorei,
    [32878]: pixelStorei,
    [3316]: pixelStorei,
    [3315]: pixelStorei,
    [32877]: pixelStorei,
    // Function-style setters
    framebuffer: (gl, framebuffer)=>{
        // accepts 1) a WebGLFramebuffer 2) null (default framebuffer), or 3) luma.gl Framebuffer class
        // framebuffer is null when restoring to default framebuffer, otherwise use the WebGL handle.
        const handle = framebuffer && 'handle' in framebuffer ? framebuffer.handle : framebuffer;
        return gl.bindFramebuffer(36160, handle);
    },
    blend: (gl, value)=>value ? gl.enable(3042) : gl.disable(3042),
    blendColor: (gl, value)=>gl.blendColor(...value),
    blendEquation: (gl, args)=>{
        const separateModes = typeof args === 'number' ? [
            args,
            args
        ] : args;
        gl.blendEquationSeparate(...separateModes);
    },
    blendFunc: (gl, args)=>{
        const separateFuncs = args?.length === 2 ? [
            ...args,
            ...args
        ] : args;
        gl.blendFuncSeparate(...separateFuncs);
    },
    clearColor: (gl, value)=>gl.clearColor(...value),
    clearDepth: (gl, value)=>gl.clearDepth(value),
    clearStencil: (gl, value)=>gl.clearStencil(value),
    colorMask: (gl, value)=>gl.colorMask(...value),
    cull: (gl, value)=>value ? gl.enable(2884) : gl.disable(2884),
    cullFace: (gl, value)=>gl.cullFace(value),
    depthTest: (gl, value)=>value ? gl.enable(2929) : gl.disable(2929),
    depthFunc: (gl, value)=>gl.depthFunc(value),
    depthMask: (gl, value)=>gl.depthMask(value),
    depthRange: (gl, value)=>gl.depthRange(...value),
    dither: (gl, value)=>value ? gl.enable(3024) : gl.disable(3024),
    derivativeHint: (gl, value)=>{
        // gl1: 'OES_standard_derivatives'
        gl.hint(35723, value);
    },
    frontFace: (gl, value)=>gl.frontFace(value),
    mipmapHint: (gl, value)=>gl.hint(33170, value),
    lineWidth: (gl, value)=>gl.lineWidth(value),
    polygonOffsetFill: (gl, value)=>value ? gl.enable(32823) : gl.disable(32823),
    polygonOffset: (gl, value)=>gl.polygonOffset(...value),
    sampleCoverage: (gl, value)=>gl.sampleCoverage(value[0], value[1] || false),
    scissorTest: (gl, value)=>value ? gl.enable(3089) : gl.disable(3089),
    scissor: (gl, value)=>gl.scissor(...value),
    stencilTest: (gl, value)=>value ? gl.enable(2960) : gl.disable(2960),
    stencilMask: (gl, value)=>{
        value = isArray(value) ? value : [
            value,
            value
        ];
        const [mask, backMask] = value;
        gl.stencilMaskSeparate(1028, mask);
        gl.stencilMaskSeparate(1029, backMask);
    },
    stencilFunc: (gl, args)=>{
        args = isArray(args) && args.length === 3 ? [
            ...args,
            ...args
        ] : args;
        const [func, ref, mask, backFunc, backRef, backMask] = args;
        gl.stencilFuncSeparate(1028, func, ref, mask);
        gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
    },
    stencilOp: (gl, args)=>{
        args = isArray(args) && args.length === 3 ? [
            ...args,
            ...args
        ] : args;
        const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
        gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
        gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
    },
    viewport: (gl, value)=>gl.viewport(...value)
};
function getValue(glEnum, values, cache) {
    return values[glEnum] !== undefined ? values[glEnum] : cache[glEnum];
}
const GL_COMPOSITE_PARAMETER_SETTERS = {
    blendEquation: (gl, values, cache)=>gl.blendEquationSeparate(getValue(32777, values, cache), getValue(34877, values, cache)),
    blendFunc: (gl, values, cache)=>gl.blendFuncSeparate(getValue(32969, values, cache), getValue(32968, values, cache), getValue(32971, values, cache), getValue(32970, values, cache)),
    polygonOffset: (gl, values, cache)=>gl.polygonOffset(getValue(32824, values, cache), getValue(10752, values, cache)),
    sampleCoverage: (gl, values, cache)=>gl.sampleCoverage(getValue(32938, values, cache), getValue(32939, values, cache)),
    stencilFuncFront: (gl, values, cache)=>gl.stencilFuncSeparate(1028, getValue(2962, values, cache), getValue(2967, values, cache), getValue(2963, values, cache)),
    stencilFuncBack: (gl, values, cache)=>gl.stencilFuncSeparate(1029, getValue(34816, values, cache), getValue(36003, values, cache), getValue(36004, values, cache)),
    stencilOpFront: (gl, values, cache)=>gl.stencilOpSeparate(1028, getValue(2964, values, cache), getValue(2965, values, cache), getValue(2966, values, cache)),
    stencilOpBack: (gl, values, cache)=>gl.stencilOpSeparate(1029, getValue(34817, values, cache), getValue(34818, values, cache), getValue(34819, values, cache))
};
const GL_HOOKED_SETTERS = {
    // GENERIC SETTERS
    enable: (update, capability)=>update({
            [capability]: true
        }),
    disable: (update, capability)=>update({
            [capability]: false
        }),
    pixelStorei: (update, pname, value)=>update({
            [pname]: value
        }),
    hint: (update, pname, value)=>update({
            [pname]: value
        }),
    // SPECIFIC SETTERS
    useProgram: (update, value)=>update({
            [35725]: value
        }),
    bindRenderbuffer: (update, target, value)=>update({
            [36007]: value
        }),
    bindTransformFeedback: (update, target, value)=>update({
            [36389]: value
        }),
    bindVertexArray: (update, value)=>update({
            [34229]: value
        }),
    bindFramebuffer: (update, target, framebuffer)=>{
        switch(target){
            case 36160:
                return update({
                    [36006]: framebuffer,
                    [36010]: framebuffer
                });
            case 36009:
                return update({
                    [36006]: framebuffer
                });
            case 36008:
                return update({
                    [36010]: framebuffer
                });
            default:
                return null;
        }
    },
    bindBuffer: (update, target, buffer)=>{
        const pname = {
            [34962]: [
                34964
            ],
            [36662]: [
                36662
            ],
            [36663]: [
                36663
            ],
            [35051]: [
                35053
            ],
            [35052]: [
                35055
            ]
        }[target];
        if (pname) {
            return update({
                [pname]: buffer
            });
        }
        // targets that should not be cached
        return {
            valueChanged: true
        };
    },
    blendColor: (update, r, g, b, a)=>update({
            [32773]: new Float32Array([
                r,
                g,
                b,
                a
            ])
        }),
    blendEquation: (update, mode)=>update({
            [32777]: mode,
            [34877]: mode
        }),
    blendEquationSeparate: (update, modeRGB, modeAlpha)=>update({
            [32777]: modeRGB,
            [34877]: modeAlpha
        }),
    blendFunc: (update, src, dst)=>update({
            [32969]: src,
            [32968]: dst,
            [32971]: src,
            [32970]: dst
        }),
    blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha)=>update({
            [32969]: srcRGB,
            [32968]: dstRGB,
            [32971]: srcAlpha,
            [32970]: dstAlpha
        }),
    clearColor: (update, r, g, b, a)=>update({
            [3106]: new Float32Array([
                r,
                g,
                b,
                a
            ])
        }),
    clearDepth: (update, depth)=>update({
            [2931]: depth
        }),
    clearStencil: (update, s)=>update({
            [2961]: s
        }),
    colorMask: (update, r, g, b, a)=>update({
            [3107]: [
                r,
                g,
                b,
                a
            ]
        }),
    cullFace: (update, mode)=>update({
            [2885]: mode
        }),
    depthFunc: (update, func)=>update({
            [2932]: func
        }),
    depthRange: (update, zNear, zFar)=>update({
            [2928]: new Float32Array([
                zNear,
                zFar
            ])
        }),
    depthMask: (update, mask)=>update({
            [2930]: mask
        }),
    frontFace: (update, face)=>update({
            [2886]: face
        }),
    lineWidth: (update, width)=>update({
            [2849]: width
        }),
    polygonOffset: (update, factor, units)=>update({
            [32824]: factor,
            [10752]: units
        }),
    sampleCoverage: (update, value, invert)=>update({
            [32938]: value,
            [32939]: invert
        }),
    scissor: (update, x, y, width, height)=>update({
            [3088]: new Int32Array([
                x,
                y,
                width,
                height
            ])
        }),
    stencilMask: (update, mask)=>update({
            [2968]: mask,
            [36005]: mask
        }),
    stencilMaskSeparate: (update, face, mask)=>update({
            [face === 1028 ? 2968 : 36005]: mask
        }),
    stencilFunc: (update, func, ref, mask)=>update({
            [2962]: func,
            [2967]: ref,
            [2963]: mask,
            [34816]: func,
            [36003]: ref,
            [36004]: mask
        }),
    stencilFuncSeparate: (update, face, func, ref, mask)=>update({
            [face === 1028 ? 2962 : 34816]: func,
            [face === 1028 ? 2967 : 36003]: ref,
            [face === 1028 ? 2963 : 36004]: mask
        }),
    stencilOp: (update, fail, zfail, zpass)=>update({
            [2964]: fail,
            [2965]: zfail,
            [2966]: zpass,
            [34817]: fail,
            [34818]: zfail,
            [34819]: zpass
        }),
    stencilOpSeparate: (update, face, fail, zfail, zpass)=>update({
            [face === 1028 ? 2964 : 34817]: fail,
            [face === 1028 ? 2965 : 34818]: zfail,
            [face === 1028 ? 2966 : 34819]: zpass
        }),
    viewport: (update, x, y, width, height)=>update({
            [2978]: [
                x,
                y,
                width,
                height
            ]
        })
};
// GETTER TABLE - FOR READING OUT AN ENTIRE CONTEXT
const isEnabled = (gl, key)=>gl.isEnabled(key);
const GL_PARAMETER_GETTERS = {
    [3042]: isEnabled,
    [2884]: isEnabled,
    [2929]: isEnabled,
    [3024]: isEnabled,
    [32823]: isEnabled,
    [32926]: isEnabled,
    [32928]: isEnabled,
    [3089]: isEnabled,
    [2960]: isEnabled,
    [35977]: isEnabled
};
const NON_CACHE_PARAMETERS = new Set([
    34016,
    36388,
    36387,
    35983,
    35368,
    34965,
    35739,
    35738,
    3074,
    34853,
    34854,
    34855,
    34856,
    34857,
    34858,
    34859,
    34860,
    34861,
    34862,
    34863,
    34864,
    34865,
    34866,
    34867,
    34868,
    35097,
    32873,
    35869,
    32874,
    34068
]); //# sourceMappingURL=webgl-parameter-tables.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/context/parameters/unified-parameter-api.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "getGLParameters": (()=>getGLParameters),
    "resetGLParameters": (()=>resetGLParameters),
    "setGLParameters": (()=>setGLParameters)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$webgl$2d$parameter$2d$tables$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/parameters/webgl-parameter-tables.js [app-client] (ecmascript)");
;
function setGLParameters(gl, parameters) {
    if (isObjectEmpty(parameters)) {
        return;
    }
    const compositeSetters = {};
    // HANDLE PRIMITIVE SETTERS (and make note of any composite setters)
    for(const key in parameters){
        const glConstant = Number(key);
        const setter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$webgl$2d$parameter$2d$tables$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GL_PARAMETER_SETTERS"][key];
        if (setter) {
            // Composite setters should only be called once, so save them
            if (typeof setter === 'string') {
                compositeSetters[setter] = true;
            } else {
                // if (gl[glConstant] !== undefined) {
                // TODO - added above check since this is being called on WebGL2 parameters in WebGL1...
                // TODO - deep equal on values? only call setter if value has changed?
                // NOTE - the setter will automatically update this.state
                setter(gl, parameters[key], glConstant);
            }
        }
    }
    // HANDLE COMPOSITE SETTERS
    // NOTE: any non-provided values needed by composite setters are filled in from state cache
    // The cache parameter is automatically retrieved from the context
    // This depends on `trackContextState`, which is technically a "circular" dependency.
    // But it is too inconvenient to always require a cache parameter here.
    // This is the ONLY external dependency in this module/
    // @ts-expect-error
    const cache = gl.state && gl.state.cache;
    if (cache) {
        for(const key in compositeSetters){
            // TODO - avoid calling composite setters if values have not changed.
            const compositeSetter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$webgl$2d$parameter$2d$tables$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GL_COMPOSITE_PARAMETER_SETTERS"][key];
            // Note - if `trackContextState` has been called,
            // the setter will automatically update this.state.cache
            compositeSetter(gl, parameters, cache);
        }
    }
// Add a log for the else case?
}
function getGLParameters(gl, parameters = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$webgl$2d$parameter$2d$tables$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GL_PARAMETER_DEFAULTS"]) {
    // support both arrays of parameters and objects (keys represent parameters)
    if (typeof parameters === 'number') {
        // single GL enum
        const key = parameters;
        const getter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$webgl$2d$parameter$2d$tables$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GL_PARAMETER_GETTERS"][key];
        return getter ? getter(gl, key) : gl.getParameter(key);
    }
    const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
    const state = {};
    for (const key of parameterKeys){
        const getter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$webgl$2d$parameter$2d$tables$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GL_PARAMETER_GETTERS"][key];
        state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
    }
    return state;
}
function resetGLParameters(gl) {
    setGLParameters(gl, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$webgl$2d$parameter$2d$tables$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GL_PARAMETER_DEFAULTS"]);
}
// Helpers
// Returns true if given object is empty, false otherwise.
function isObjectEmpty(object) {
    // @ts-ignore dummy key variable
    for(const key in object){
        return false;
    }
    return true;
} //# sourceMappingURL=unified-parameter-api.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/context/state-tracker/deep-array-equal.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** deeply compare two arrays */ __turbopack_esm__({
    "deepArrayEqual": (()=>deepArrayEqual)
});
function deepArrayEqual(x, y) {
    if (x === y) {
        return true;
    }
    const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
    const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);
    // @ts-expect-error TODO fix
    if (isArrayX && isArrayY && x.length === y.length) {
        // @ts-expect-error TODO fix
        for(let i = 0; i < x.length; ++i){
            if (x[i] !== y[i]) {
                return false;
            }
        }
        return true;
    }
    return false;
} //# sourceMappingURL=deep-array-equal.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/context/state-tracker/webgl-state-tracker.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "WebGLStateTracker": (()=>WebGLStateTracker)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$unified$2d$parameter$2d$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/parameters/unified-parameter-api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$webgl$2d$parameter$2d$tables$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/parameters/webgl-parameter-tables.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$state$2d$tracker$2f$deep$2d$array$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/state-tracker/deep-array-equal.js [app-client] (ecmascript)");
;
;
;
class WebGLStateTracker {
    static get(gl) {
        // @ts-expect-error
        return gl.state;
    }
    gl;
    program = null;
    stateStack = [];
    enable = true;
    cache = null;
    log;
    initialized = false;
    constructor(gl, props){
        this.gl = gl;
        this.log = props?.log || (()=>{});
        this._updateCache = this._updateCache.bind(this);
        Object.seal(this);
    }
    push(values = {}) {
        this.stateStack.push({});
    }
    pop() {
        // assert(this.stateStack.length > 0);
        // Use the saved values in the state stack to restore parameters
        const oldValues = this.stateStack[this.stateStack.length - 1];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$unified$2d$parameter$2d$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setGLParameters"])(this.gl, oldValues);
        // Don't pop until we have reset parameters (to make sure other "stack frames" are not affected)
        this.stateStack.pop();
    }
    /**
     * Initialize WebGL state caching on a context
     * can be called multiple times to enable/disable
     *
     * @note After calling this function, context state will be cached
     * .push() and .pop() will be available for saving,
     * temporarily modifying, and then restoring state.
     */ trackState(gl, options) {
        this.cache = options.copyState ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$unified$2d$parameter$2d$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGLParameters"])(gl) : Object.assign({}, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$webgl$2d$parameter$2d$tables$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GL_PARAMETER_DEFAULTS"]);
        if (this.initialized) {
            throw new Error('WebGLStateTracker');
        }
        this.initialized = true;
        // @ts-expect-error
        this.gl.state = this;
        installProgramSpy(gl);
        // intercept all setter functions in the table
        for(const key in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$webgl$2d$parameter$2d$tables$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GL_HOOKED_SETTERS"]){
            const setter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$webgl$2d$parameter$2d$tables$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GL_HOOKED_SETTERS"][key];
            installSetterSpy(gl, key, setter);
        }
        // intercept all getter functions in the table
        installGetterOverride(gl, 'getParameter');
        installGetterOverride(gl, 'isEnabled');
    }
    /**
    // interceptor for context set functions - update our cache and our stack
    // values (Object) - the key values for this setter
     * @param values
     * @returns
     */ _updateCache(values) {
        let valueChanged = false;
        let oldValue; // = undefined
        const oldValues = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
        for(const key in values){
            // assert(key !== undefined);
            const value = values[key];
            const cached = this.cache[key];
            // Check that value hasn't already been shadowed
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$state$2d$tracker$2f$deep$2d$array$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepArrayEqual"])(value, cached)) {
                valueChanged = true;
                oldValue = cached;
                // First, save current value being shadowed
                // If a state stack frame is active, save the current parameter values for pop
                // but first check that value hasn't already been shadowed and saved
                if (oldValues && !(key in oldValues)) {
                    oldValues[key] = cached;
                }
                // Save current value being shadowed
                this.cache[key] = value;
            }
        }
        return {
            valueChanged,
            oldValue
        };
    }
}
// HELPER FUNCTIONS - INSTALL GET/SET INTERCEPTORS (SPYS) ON THE CONTEXT
/**
// Overrides a WebGL2RenderingContext state "getter" function
// to return values directly from cache
 * @param gl
 * @param functionName
 */ function installGetterOverride(gl, functionName) {
    // Get the original function from the WebGL2RenderingContext
    const originalGetterFunc = gl[functionName].bind(gl);
    // Wrap it with a spy so that we can update our state cache when it gets called
    gl[functionName] = function get(pname) {
        if (pname === undefined || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$webgl$2d$parameter$2d$tables$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NON_CACHE_PARAMETERS"].has(pname)) {
            // Invalid or blacklisted parameter, do not cache
            return originalGetterFunc(pname);
        }
        const glState = WebGLStateTracker.get(gl);
        if (!(pname in glState.cache)) {
            // WebGL limits are not prepopulated in the cache, call the original getter when first queried.
            glState.cache[pname] = originalGetterFunc(pname);
        }
        // Optionally call the original function to do a "hard" query from the WebGL2RenderingContext
        return glState.enable ? glState.cache[pname] : originalGetterFunc(pname);
    };
    // Set the name of this anonymous function to help in debugging and profiling
    Object.defineProperty(gl[functionName], 'name', {
        value: `${functionName}-from-cache`,
        configurable: false
    });
}
/**
// Overrides a WebGL2RenderingContext state "setter" function
// to call a setter spy before the actual setter. Allows us to keep a cache
// updated with a copy of the WebGL context state.
 * @param gl
 * @param functionName
 * @param setter
 * @returns
 */ function installSetterSpy(gl, functionName, setter) {
    // Get the original function from the WebGL2RenderingContext
    if (!gl[functionName]) {
        // TODO - remove?
        // This could happen if we try to intercept WebGL2 method on a WebGL1 context
        return;
    }
    const originalSetterFunc = gl[functionName].bind(gl);
    // Wrap it with a spy so that we can update our state cache when it gets called
    gl[functionName] = function set(...params) {
        // Update the value
        // Call the setter with the state cache and the params so that it can store the parameters
        const glState = WebGLStateTracker.get(gl);
        // eslint-disable-next-line @typescript-eslint/unbound-method
        const { valueChanged, oldValue } = setter(glState._updateCache, ...params);
        // Call the original WebGL2RenderingContext func to make sure the context actually gets updated
        if (valueChanged) {
            originalSetterFunc(...params);
        }
        // Note: if the original function fails to set the value, our state cache will be bad
        // No solution for this at the moment, but assuming that this is unlikely to be a real problem
        // We could call the setter after the originalSetterFunc. Concern is that this would
        // cause different behavior in debug mode, where originalSetterFunc can throw exceptions
        return oldValue;
    };
    // Set the name of this anonymous function to help in debugging and profiling
    Object.defineProperty(gl[functionName], 'name', {
        value: `${functionName}-to-cache`,
        configurable: false
    });
}
function installProgramSpy(gl) {
    const originalUseProgram = gl.useProgram.bind(gl);
    gl.useProgram = function useProgramLuma(handle) {
        const glState = WebGLStateTracker.get(gl);
        if (glState.program !== handle) {
            originalUseProgram(handle);
            glState.program = handle;
        }
    };
} //# sourceMappingURL=webgl-state-tracker.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/context/debug/webgl-developer-tools.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "loadWebGLDeveloperTools": (()=>loadWebGLDeveloperTools),
    "makeDebugContext": (()=>makeDebugContext)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@probe.gl/env/dist/lib/is-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$utils$2f$load$2d$script$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/utils/load-script.js [app-client] (ecmascript)");
// Rename constant to prevent inlining. We need the full set of constants for generating debug strings.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$constants$2f$dist$2f$webgl$2d$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/constants/dist/webgl-constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
;
;
;
;
const WEBGL_DEBUG_CDN_URL = 'https://unpkg.com/webgl-debug@2.0.1/index.js';
// Helper to get shared context data
function getWebGLContextData(gl) {
    gl.luma = gl.luma || {};
    return gl.luma;
}
async function loadWebGLDeveloperTools() {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBrowser"])() && !globalThis.WebGLDebugUtils) {
        globalThis.global = globalThis.global || globalThis;
        // @ts-expect-error Developer tools expects global to be set
        globalThis.global.module = {};
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$utils$2f$load$2d$script$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["loadScript"])(WEBGL_DEBUG_CDN_URL);
    }
}
function makeDebugContext(gl, props = {}) {
    return props.debugWebGL || props.traceWebGL ? getDebugContext(gl, props) : getRealContext(gl);
}
// Returns the real context from either of the real/debug contexts
function getRealContext(gl) {
    const data = getWebGLContextData(gl);
    // If the context has a realContext member, it is a debug context so return the realContext
    return data.realContext ? data.realContext : gl;
}
// Returns the debug context from either of the real/debug contexts
function getDebugContext(gl, props) {
    if (!globalThis.WebGLDebugUtils) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn('webgl-debug not loaded')();
        return gl;
    }
    const data = getWebGLContextData(gl);
    // If this already has a debug context, return it.
    if (data.debugContext) {
        return data.debugContext;
    }
    // Create a new debug context
    globalThis.WebGLDebugUtils.init({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$constants$2f$dist$2f$webgl$2d$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GL"],
        ...gl
    });
    const glDebug = globalThis.WebGLDebugUtils.makeDebugContext(gl, onGLError.bind(null, props), onValidateGLFunc.bind(null, props));
    // Make sure we have all WebGL2 and extension constants (todo dynamic import to circumvent minification?)
    for(const key in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$constants$2f$dist$2f$webgl$2d$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GL"]){
        if (!(key in glDebug) && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$constants$2f$dist$2f$webgl$2d$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GL"][key] === 'number') {
            glDebug[key] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$constants$2f$dist$2f$webgl$2d$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GL"][key];
        }
    }
    // Ensure we have a clean prototype on the instrumented object
    // Note: setPrototypeOf does come with perf warnings, but we already take a bigger perf reduction
    // by synchronizing the WebGL errors after each WebGL call.
    class WebGLDebugContext {
    }
    Object.setPrototypeOf(glDebug, Object.getPrototypeOf(gl));
    Object.setPrototypeOf(WebGLDebugContext, glDebug);
    const debugContext = Object.create(WebGLDebugContext);
    // Store the debug context
    data.realContext = gl;
    data.debugContext = debugContext;
    debugContext.debug = true;
    // Return it
    return debugContext;
}
// DEBUG TRACING
function getFunctionString(functionName, functionArgs) {
    // Cover bug in webgl-debug-tools
    functionArgs = Array.from(functionArgs).map((arg)=>arg === undefined ? 'undefined' : arg);
    let args = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, functionArgs);
    args = `${args.slice(0, 100)}${args.length > 100 ? '...' : ''}`;
    return `gl.${functionName}(${args})`;
}
function onGLError(props, err, functionName, args) {
    // Cover bug in webgl-debug-tools
    args = Array.from(args).map((arg)=>arg === undefined ? 'undefined' : arg);
    const errorMessage = globalThis.WebGLDebugUtils.glEnumToString(err);
    const functionArgs = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, args);
    const message = `${errorMessage} in gl.${functionName}(${functionArgs})`;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].error(message)();
    debugger; // eslint-disable-line
// throw new Error(message);
}
// Don't generate function string until it is needed
function onValidateGLFunc(props, functionName, functionArgs) {
    let functionString = '';
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].level >= 1) {
        functionString = getFunctionString(functionName, functionArgs);
        if (props.traceWebGL) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].log(1, functionString)();
        }
    }
    for (const arg of functionArgs){
        if (arg === undefined) {
            functionString = functionString || getFunctionString(functionName, functionArgs);
            debugger; // eslint-disable-line
        // throw new Error(`Undefined argument: ${functionString}`);
        }
    }
} //# sourceMappingURL=webgl-developer-tools.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-buffer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "WEBGLBuffer": (()=>WEBGLBuffer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/buffer.js [app-client] (ecmascript)");
;
;
class WEBGLBuffer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] {
    device;
    gl;
    handle;
    /** Target in OpenGL defines the type of buffer */ glTarget;
    /** Usage is a hint on how frequently the buffer will be updates */ glUsage;
    /** Index type is needed when issuing draw calls, so we pre-compute it */ glIndexType = 5123;
    /** Number of bytes allocated on the GPU for this buffer */ byteLength;
    /** Number of bytes used */ bytesUsed;
    constructor(device, props = {}){
        super(device, props);
        this.device = device;
        this.gl = this.device.gl;
        const handle = typeof props === 'object' ? props.handle : undefined;
        this.handle = handle || this.gl.createBuffer();
        device.setSpectorMetadata(this.handle, {
            ...this.props,
            data: typeof this.props.data
        });
        // - In WebGL1, need to make sure we use GL.ELEMENT_ARRAY_BUFFER when initializing element buffers
        //   otherwise buffer type will lock to generic (non-element) buffer
        // - In WebGL2, we can use GL.COPY_READ_BUFFER which avoids locking the type here
        this.glTarget = getWebGLTarget(this.props.usage);
        this.glUsage = getWebGLUsage(this.props.usage);
        this.glIndexType = this.props.indexType === 'uint32' ? 5125 : 5123;
        // Set data: (re)initializes the buffer
        if (props.data) {
            this._initWithData(props.data, props.byteOffset, props.byteLength);
        } else {
            this._initWithByteLength(props.byteLength || 0);
        }
    }
    // PRIVATE METHODS
    /** Allocate a new buffer and initialize to contents of typed array */ _initWithData(data, byteOffset = 0, byteLength = data.byteLength + byteOffset) {
        // const glTarget = this.device.isWebGL2 ? GL.COPY_WRITE_BUFFER : this.glTarget;
        const glTarget = this.glTarget;
        this.gl.bindBuffer(glTarget, this.handle);
        this.gl.bufferData(glTarget, byteLength, this.glUsage);
        this.gl.bufferSubData(glTarget, byteOffset, data);
        this.gl.bindBuffer(glTarget, null);
        this.bytesUsed = byteLength;
        this.byteLength = byteLength;
        this._setDebugData(data, byteOffset, byteLength);
        this.trackAllocatedMemory(byteLength);
    }
    // Allocate a GPU buffer of specified size.
    _initWithByteLength(byteLength) {
        // assert(byteLength >= 0);
        // Workaround needed for Safari (#291):
        // gl.bufferData with size equal to 0 crashes. Instead create zero sized array.
        let data = byteLength;
        if (byteLength === 0) {
            // @ts-expect-error
            data = new Float32Array(0);
        }
        // const glTarget = this.device.isWebGL2 ? GL.COPY_WRITE_BUFFER : this.glTarget;
        const glTarget = this.glTarget;
        this.gl.bindBuffer(glTarget, this.handle);
        this.gl.bufferData(glTarget, data, this.glUsage);
        this.gl.bindBuffer(glTarget, null);
        this.bytesUsed = byteLength;
        this.byteLength = byteLength;
        this._setDebugData(null, 0, byteLength);
        this.trackAllocatedMemory(byteLength);
        return this;
    }
    destroy() {
        if (!this.destroyed && this.handle) {
            this.removeStats();
            this.trackDeallocatedMemory();
            this.gl.deleteBuffer(this.handle);
            this.destroyed = true;
            // @ts-expect-error
            this.handle = null;
        }
    }
    write(data, byteOffset = 0) {
        const srcOffset = 0;
        const byteLength = undefined; // data.byteLength;
        // Create the buffer - binding it here for the first time locks the type
        // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type
        const glTarget = 36663;
        this.gl.bindBuffer(glTarget, this.handle);
        // WebGL2: subData supports additional srcOffset and length parameters
        if (srcOffset !== 0 || byteLength !== undefined) {
            this.gl.bufferSubData(glTarget, byteOffset, data, srcOffset, byteLength);
        } else {
            this.gl.bufferSubData(glTarget, byteOffset, data);
        }
        this.gl.bindBuffer(glTarget, null);
        this._setDebugData(data, byteOffset, data.byteLength);
    }
    /** Asynchronously read data from the buffer */ async readAsync(byteOffset = 0, byteLength) {
        return this.readSyncWebGL(byteOffset, byteLength);
    }
    /** Synchronously read data from the buffer. WebGL only. */ readSyncWebGL(byteOffset = 0, byteLength) {
        byteLength = byteLength ?? this.byteLength - byteOffset;
        const data = new Uint8Array(byteLength);
        const dstOffset = 0;
        // Use GL.COPY_READ_BUFFER to avoid disturbing other targets and locking type
        this.gl.bindBuffer(36662, this.handle);
        this.gl.getBufferSubData(36662, byteOffset, data, dstOffset, byteLength);
        this.gl.bindBuffer(36662, null);
        // Update local `data` if offsets are 0
        this._setDebugData(data, byteOffset, byteLength);
        return data;
    }
}
/**
 * Returns a WebGL buffer target
 *
 * @param usage
 * static MAP_READ = 0x01;
 * static MAP_WRITE = 0x02;
 * static COPY_SRC = 0x0004;
 * static COPY_DST = 0x0008;
 * static INDEX = 0x0010;
 * static VERTEX = 0x0020;
 * static UNIFORM = 0x0040;
 * static STORAGE = 0x0080;
 * static INDIRECT = 0x0100;
 * static QUERY_RESOLVE = 0x0200;
 *
 * @returns WebGL buffer targe
 *
 * Buffer bind points in WebGL2
 * gl.COPY_READ_BUFFER: Buffer for copying from one buffer object to another.
 * gl.COPY_WRITE_BUFFER: Buffer for copying from one buffer object to another.
 * gl.TRANSFORM_FEEDBACK_BUFFER: Buffer for transform feedback operations.
 * gl.PIXEL_PACK_BUFFER: Buffer used for pixel transfer operations.
 * gl.PIXEL_UNPACK_BUFFER: Buffer used for pixel transfer operations.
 */ function getWebGLTarget(usage) {
    if (usage & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].INDEX) {
        return 34963;
    }
    if (usage & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].VERTEX) {
        return 34962;
    }
    if (usage & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].UNIFORM) {
        return 35345;
    }
    // Binding a buffer for the first time locks the type
    // In WebGL2, we can use GL.COPY_WRITE_BUFFER to avoid locking the type
    return 34962;
}
/** @todo usage is not passed correctly */ function getWebGLUsage(usage) {
    if (usage & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].INDEX) {
        return 35044;
    }
    if (usage & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].VERTEX) {
        return 35044;
    }
    if (usage & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].UNIFORM) {
        return 35048;
    }
    return 35044;
} //# sourceMappingURL=webgl-buffer.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/context/state-tracker/with-parameters.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "withGLParameters": (()=>withGLParameters)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$state$2d$tracker$2f$webgl$2d$state$2d$tracker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/state-tracker/webgl-state-tracker.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$unified$2d$parameter$2d$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/parameters/unified-parameter-api.js [app-client] (ecmascript)");
;
;
function withGLParameters(gl, parameters, func) {
    if (isObjectEmpty(parameters)) {
        // Avoid setting state if no parameters provided. Just call and return
        return func(gl);
    }
    const { nocatch = true } = parameters;
    const webglState = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$state$2d$tracker$2f$webgl$2d$state$2d$tracker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLStateTracker"].get(gl);
    webglState.push();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$unified$2d$parameter$2d$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setGLParameters"])(gl, parameters);
    // Setup is done, call the function
    let value;
    if (nocatch) {
        // Avoid try catch to minimize stack size impact for safe execution paths
        value = func(gl);
        webglState.pop();
    } else {
        // Wrap in a try-catch to ensure that parameters are restored on exceptions
        try {
            value = func(gl);
        } finally{
            webglState.pop();
        }
    }
    return value;
}
// Helpers
// Returns true if given object is empty, false otherwise.
function isObjectEmpty(object) {
    // @ts-ignore - dummy key variable
    for(const key in object){
        return false;
    }
    return true;
} //# sourceMappingURL=with-parameters.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/typed-array-utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "flipRows": (()=>flipRows),
    "getGLTypeFromTypedArray": (()=>getGLTypeFromTypedArray),
    "getTypedArrayFromGLType": (()=>getTypedArrayFromGLType),
    "scalePixels": (()=>scalePixels)
});
;
const ERR_TYPE_DEDUCTION = 'Failed to deduce GL constant from typed array';
function getGLTypeFromTypedArray(arrayOrType) {
    // If typed array, look up constructor
    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch(type){
        case Float32Array:
            return 5126;
        case Uint16Array:
            return 5123;
        case Uint32Array:
            return 5125;
        case Uint8Array:
            return 5121;
        case Uint8ClampedArray:
            return 5121;
        case Int8Array:
            return 5120;
        case Int16Array:
            return 5122;
        case Int32Array:
            return 5124;
        default:
            throw new Error(ERR_TYPE_DEDUCTION);
    }
}
function getTypedArrayFromGLType(glType, options) {
    const { clamped = true } = options || {};
    // Sorted in some order of likelihood to reduce amount of comparisons
    switch(glType){
        case 5126:
            return Float32Array;
        case 5123:
        case 33635:
        case 32819:
        case 32820:
            return Uint16Array;
        case 5125:
            return Uint32Array;
        case 5121:
            return clamped ? Uint8ClampedArray : Uint8Array;
        case 5120:
            return Int8Array;
        case 5122:
            return Int16Array;
        case 5124:
            return Int32Array;
        default:
            throw new Error('Failed to deduce typed array type from GL constant');
    }
}
function flipRows(options) {
    const { data, width, height, bytesPerPixel = 4, temp } = options;
    const bytesPerRow = width * bytesPerPixel;
    // make a temp buffer to hold one row
    const tempBuffer = temp || new Uint8Array(bytesPerRow);
    for(let y = 0; y < height / 2; ++y){
        const topOffset = y * bytesPerRow;
        const bottomOffset = (height - y - 1) * bytesPerRow;
        // make copy of a row on the top half
        tempBuffer.set(data.subarray(topOffset, topOffset + bytesPerRow));
        // copy a row from the bottom half to the top
        data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
        // copy the copy of the top half row to the bottom half
        data.set(tempBuffer, bottomOffset);
    }
}
function scalePixels(options) {
    const { data, width, height } = options;
    const newWidth = Math.round(width / 2);
    const newHeight = Math.round(height / 2);
    const newData = new Uint8Array(newWidth * newHeight * 4);
    for(let y = 0; y < newHeight; y++){
        for(let x = 0; x < newWidth; x++){
            for(let c = 0; c < 4; c++){
                newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];
            }
        }
    }
    return {
        data: newData,
        width: newWidth,
        height: newHeight
    };
} //# sourceMappingURL=typed-array-utils.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/format-utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "glFormatToComponents": (()=>glFormatToComponents),
    "glTypeToBytes": (()=>glTypeToBytes)
});
;
function glFormatToComponents(format) {
    switch(format){
        case 6406:
        case 33326:
        case 6403:
        case 36244:
            return 1;
        case 33339:
        case 33340:
        case 33328:
        case 33320:
        case 33319:
            return 2;
        case 6407:
        case 36248:
        case 34837:
            return 3;
        case 6408:
        case 36249:
        case 34836:
            return 4;
        // TODO: Add support for additional WebGL2 formats
        default:
            return 0;
    }
}
function glTypeToBytes(type) {
    switch(type){
        case 5121:
            return 1;
        case 33635:
        case 32819:
        case 32820:
            return 2;
        case 5126:
            return 4;
        // TODO: Add support for additional WebGL2 types
        default:
            return 0;
    }
} //# sourceMappingURL=format-utils.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/webgl-texture-utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "copyCPUDataToMipLevel": (()=>copyCPUDataToMipLevel),
    "copyExternalImageToMipLevel": (()=>copyExternalImageToMipLevel),
    "copyGPUBufferToMipLevel": (()=>copyGPUBufferToMipLevel),
    "copyToTexture": (()=>copyToTexture),
    "getWebGLCubeFaceTarget": (()=>getWebGLCubeFaceTarget),
    "getWebGLTextureTarget": (()=>getWebGLTextureTarget),
    "initializeTextureStorage": (()=>initializeTextureStorage),
    "readPixelsToArray": (()=>readPixelsToArray),
    "readPixelsToBuffer": (()=>readPixelsToBuffer),
    "toFramebuffer": (()=>toFramebuffer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$state$2d$tracker$2f$with$2d$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/state-tracker/with-parameters.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$typed$2d$array$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/typed-array-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$format$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/format-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/framebuffer.js [app-client] (ecmascript)");
;
;
;
;
;
;
/** A "border" parameter is required in many WebGL texture APIs, but must always be 0... */ const BORDER = 0;
function initializeTextureStorage(gl, levels, options) {
    const { dimension, width, height, depth = 0 } = options;
    const { glInternalFormat } = options;
    const glTarget = options.glTarget; // getWebGLCubeFaceTarget(options.glTarget, dimension, depth);
    switch(dimension){
        case '2d-array':
        case '3d':
            gl.texStorage3D(glTarget, levels, glInternalFormat, width, height, depth);
            break;
        default:
            gl.texStorage2D(glTarget, levels, glInternalFormat, width, height);
    }
}
function copyExternalImageToMipLevel(gl, handle, image, options) {
    const { width, height } = options;
    const { dimension, depth = 0, mipLevel = 0 } = options;
    const { x = 0, y = 0, z = 0 } = options;
    const { glFormat, glType } = options;
    const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);
    const glParameters = options.flipY ? {
        [37440]: true
    } : {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$state$2d$tracker$2f$with$2d$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withGLParameters"])(gl, glParameters, ()=>{
        switch(dimension){
            case '2d-array':
            case '3d':
                gl.bindTexture(glTarget, handle);
                // prettier-ignore
                gl.texSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, glType, image);
                gl.bindTexture(glTarget, null);
                break;
            case '2d':
            case 'cube':
                gl.bindTexture(glTarget, handle);
                // prettier-ignore
                gl.texSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, glType, image);
                gl.bindTexture(glTarget, null);
                break;
            default:
                throw new Error(dimension);
        }
    });
}
function copyCPUDataToMipLevel(gl, typedArray, options) {
    const { dimension, width, height, depth = 0, mipLevel = 0, byteOffset = 0 } = options;
    const { x = 0, y = 0, z = 0 } = options;
    const { glFormat, glType, compressed } = options;
    const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);
    // gl.bindTexture(glTarget, null);
    switch(dimension){
        case '2d-array':
        case '3d':
            if (compressed) {
                // prettier-ignore
                gl.compressedTexSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, typedArray, byteOffset); // , byteLength
            } else {
                // prettier-ignore
                gl.texSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, glType, typedArray, byteOffset); // , byteLength
            }
            break;
        case '2d':
        case 'cube':
            if (compressed) {
                // prettier-ignore
                gl.compressedTexSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, typedArray, byteOffset); // , byteLength
            } else {
                // prettier-ignore
                gl.texSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, glType, typedArray, byteOffset); // , byteLength
            }
            break;
        default:
            throw new Error(dimension);
    }
}
function copyGPUBufferToMipLevel(gl, webglBuffer, byteLength, options) {
    const { dimension, width, height, depth = 0, mipLevel = 0, byteOffset = 0 } = options;
    const { x = 0, y = 0, z = 0 } = options;
    const { glFormat, glType, compressed } = options;
    const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);
    gl.bindBuffer(35052, webglBuffer);
    switch(dimension){
        case '2d-array':
        case '3d':
            // 3 dimensional textures requires 3D texture functions
            if (compressed) {
                // TODO enable extension?
                // prettier-ignore
                gl.compressedTexSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, byteLength, byteOffset);
            } else {
                // prettier-ignore
                gl.texSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, glType, byteOffset);
            }
            break;
        case '2d':
        case 'cube':
            if (compressed) {
                // prettier-ignore
                gl.compressedTexSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, byteLength, byteOffset);
            } else {
                // prettier-ignore
                gl.texSubImage2D(glTarget, mipLevel, x, y, width, height, BORDER, glFormat, byteOffset);
            }
            break;
        default:
            throw new Error(dimension);
    }
}
function getWebGLTextureTarget(dimension) {
    // prettier-ignore
    switch(dimension){
        case '1d':
            break; // not supported in any WebGL version
        case '2d':
            return 3553; // supported in WebGL1
        case '3d':
            return 32879; // supported in WebGL2
        case 'cube':
            return 34067; // supported in WebGL1
        case '2d-array':
            return 35866; // supported in WebGL2
        case 'cube-array':
            break; // not supported in any WebGL version
    }
    throw new Error(dimension);
}
function getWebGLCubeFaceTarget(glTarget, dimension, level) {
    return dimension === 'cube' ? 34069 + level : glTarget;
}
function readPixelsToArray(source, options) {
    const { sourceX = 0, sourceY = 0, sourceAttachment = 0 // TODO - support gl.readBuffer
     } = options || {};
    let { target: target1 = null, // following parameters are auto deduced if not provided
    sourceWidth, sourceHeight, sourceDepth, sourceFormat, sourceType } = options || {};
    const { framebuffer, deleteFramebuffer } = getFramebuffer(source);
    // assert(framebuffer);
    const { gl, handle } = framebuffer;
    sourceWidth ||= framebuffer.width;
    sourceHeight ||= framebuffer.height;
    const texture = framebuffer.colorAttachments[sourceAttachment]?.texture;
    if (!texture) {
        throw new Error(`Invalid framebuffer attachment ${sourceAttachment}`);
    }
    sourceDepth = texture?.depth || 1;
    sourceFormat ||= texture?.glFormat || 6408;
    // Deduce the type from color attachment if not provided.
    sourceType ||= texture?.glType || 5121;
    // Deduce type and allocated pixelArray if needed
    target1 = getPixelArray(target1, sourceType, sourceFormat, sourceWidth, sourceHeight, sourceDepth);
    // Pixel array available, if necessary, deduce type from it.
    sourceType = sourceType || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$typed$2d$array$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGLTypeFromTypedArray"])(target1);
    // Note: luma.gl overrides bindFramebuffer so that we can reliably restore the previous framebuffer (this is the only function for which we do that)
    const prevHandle = gl.bindFramebuffer(36160, handle);
    // Select the color attachment to read from
    gl.readBuffer(36064 + sourceAttachment);
    // There is a lot of hedging in the WebGL2 spec about what formats are guaranteed to be readable
    // (It should always be possible to read RGBA/UNSIGNED_BYTE, but most other combinations are not guaranteed)
    // Querying is possible but expensive:
    // const {device} = framebuffer;
    // texture.glReadFormat ||= gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT);
    // texture.glReadType ||= gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE);
    // console.log('params', device.getGLKey(texture.glReadFormat), device.getGLKey(texture.glReadType));
    gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target1);
    gl.readBuffer(36064);
    gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) {
        framebuffer.destroy();
    }
    return target1;
}
function readPixelsToBuffer(source, options) {
    const { target: target1, sourceX = 0, sourceY = 0, sourceFormat = 6408, targetByteOffset = 0 } = options || {};
    // following parameters are auto deduced if not provided
    let { sourceWidth, sourceHeight, sourceType } = options || {};
    const { framebuffer, deleteFramebuffer } = getFramebuffer(source);
    // assert(framebuffer);
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    // Asynchronous read (PIXEL_PACK_BUFFER) is WebGL2 only feature
    const webglFramebuffer = framebuffer;
    // deduce type if not available.
    sourceType = sourceType || 5121;
    let webglBufferTarget = target1;
    if (!webglBufferTarget) {
        // Create new buffer with enough size
        const components = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$format$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["glFormatToComponents"])(sourceFormat);
        const byteCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$format$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["glTypeToBytes"])(sourceType);
        const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
        webglBufferTarget = webglFramebuffer.device.createBuffer({
            byteLength
        });
    }
    // TODO(donmccurdy): Do we have tests to confirm this is working?
    const commandEncoder = source.device.createCommandEncoder();
    commandEncoder.copyTextureToBuffer({
        sourceTexture: source,
        width: sourceWidth,
        height: sourceHeight,
        origin: [
            sourceX,
            sourceY
        ],
        destinationBuffer: webglBufferTarget,
        byteOffset: targetByteOffset
    });
    commandEncoder.destroy();
    if (deleteFramebuffer) {
        framebuffer.destroy();
    }
    return webglBufferTarget;
}
function copyToTexture(sourceTexture, destinationTexture, options) {
    const { sourceX = 0, sourceY = 0, // attachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer
    targetMipmaplevel = 0, targetInternalFormat = 6408 } = options || {};
    let { targetX, targetY, targetZ, width, height// defaults to target height
     } = options || {};
    const { framebuffer, deleteFramebuffer } = getFramebuffer(sourceTexture);
    // assert(framebuffer);
    const webglFramebuffer = framebuffer;
    const { device, handle } = webglFramebuffer;
    const isSubCopy = typeof targetX !== 'undefined' || typeof targetY !== 'undefined' || typeof targetZ !== 'undefined';
    targetX = targetX || 0;
    targetY = targetY || 0;
    targetZ = targetZ || 0;
    const prevHandle = device.gl.bindFramebuffer(36160, handle);
    // TODO - support gl.readBuffer (WebGL2 only)
    // const prevBuffer = gl.readBuffer(attachment);
    // assert(target);
    let texture = null;
    let textureTarget;
    if (destinationTexture instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLTexture"]) {
        texture = destinationTexture;
        width = Number.isFinite(width) ? width : texture.width;
        height = Number.isFinite(height) ? height : texture.height;
        texture?.bind(0);
        // @ts-ignore
        textureTarget = texture.target;
    } else {
        // @ts-ignore
        textureTarget = target;
    }
    if (!isSubCopy) {
        device.gl.copyTexImage2D(textureTarget, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0 /* border must be 0 */ );
    } else {
        switch(textureTarget){
            case 3553:
            case 34067:
                device.gl.copyTexSubImage2D(textureTarget, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);
                break;
            case 35866:
            case 32879:
                device.gl.copyTexSubImage3D(textureTarget, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);
                break;
            default:
        }
    }
    if (texture) {
        texture.unbind();
    }
    // @ts-expect-error
    device.gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) {
        framebuffer.destroy();
    }
    return texture;
}
function getFramebuffer(source) {
    if (!(source instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Framebuffer"])) {
        return {
            framebuffer: toFramebuffer(source),
            deleteFramebuffer: true
        };
    }
    return {
        framebuffer: source,
        deleteFramebuffer: false
    };
}
function toFramebuffer(texture, props) {
    const { device, width, height, id } = texture;
    const framebuffer = device.createFramebuffer({
        ...props,
        id: `framebuffer-for-${id}`,
        width,
        height,
        colorAttachments: [
            texture
        ]
    });
    return framebuffer;
}
// eslint-disable-next-line max-params
function getPixelArray(pixelArray, glType, glFormat, width, height, depth) {
    if (pixelArray) {
        return pixelArray;
    }
    // const formatInfo = decodeTextureFormat(format);
    // Allocate pixel array if not already available, using supplied type
    glType ||= 5121;
    const ArrayType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$typed$2d$array$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTypedArrayFromGLType"])(glType, {
        clamped: false
    });
    const components = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$format$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["glFormatToComponents"])(glFormat);
    // TODO - check for composite type (components = 1).
    return new ArrayType(width * height * components);
} //# sourceMappingURL=webgl-texture-utils.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture-view.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// import {decodeTextureFormat} from '@luma.gl/core';
__turbopack_esm__({
    "WEBGLTextureView": (()=>WEBGLTextureView)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2d$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/texture-view.js [app-client] (ecmascript)");
;
class WEBGLTextureView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2d$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureView"] {
    device;
    gl;
    handle;
    texture;
    constructor(device, props){
        super(device, {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"].defaultProps,
            ...props
        });
        this.device = device;
        this.gl = this.device.gl;
        this.handle = null;
        this.texture = props.texture;
    }
} //# sourceMappingURL=webgl-texture-view.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/converters/device-parameters.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "convertCompareFunction": (()=>convertCompareFunction),
    "convertToCompareFunction": (()=>convertToCompareFunction),
    "setDeviceParameters": (()=>setDeviceParameters),
    "withDeviceAndGLParameters": (()=>withDeviceAndGLParameters),
    "withDeviceParameters": (()=>withDeviceParameters),
    "withGLParameters": (()=>withGLParameters)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$unified$2d$parameter$2d$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/parameters/unified-parameter-api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
;
;
;
function withDeviceAndGLParameters(device, parameters, glParameters, func) {
    if (isObjectEmpty(parameters)) {
        // Avoid setting state if no parameters provided. Just call and return
        return func(device);
    }
    // Wrap in a try-catch to ensure that parameters are restored on exceptions
    const webglDevice = device;
    webglDevice.pushState();
    try {
        setDeviceParameters(device, parameters);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$unified$2d$parameter$2d$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setGLParameters"])(webglDevice.gl, glParameters);
        return func(device);
    } finally{
        webglDevice.popState();
    }
}
function withGLParameters(device, parameters, func) {
    if (isObjectEmpty(parameters)) {
        // Avoid setting state if no parameters provided. Just call and return
        return func(device);
    }
    // Wrap in a try-catch to ensure that parameters are restored on exceptions
    const webglDevice = device;
    webglDevice.pushState();
    try {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$unified$2d$parameter$2d$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setGLParameters"])(webglDevice.gl, parameters);
        return func(device);
    } finally{
        webglDevice.popState();
    }
}
function withDeviceParameters(device, parameters, func) {
    if (isObjectEmpty(parameters)) {
        // Avoid setting state if no parameters provided. Just call and return
        return func(device);
    }
    // Wrap in a try-catch to ensure that parameters are restored on exceptions'
    const webglDevice = device;
    webglDevice.pushState();
    try {
        setDeviceParameters(device, parameters);
        return func(device);
    } finally{
        webglDevice.popState();
    }
}
function setDeviceParameters(device, parameters) {
    const webglDevice = device;
    const { gl } = webglDevice;
    // RASTERIZATION SETTINGS
    if (parameters.cullMode) {
        switch(parameters.cullMode){
            case 'none':
                gl.disable(2884);
                break;
            case 'front':
                gl.enable(2884);
                gl.cullFace(1028);
                break;
            case 'back':
                gl.enable(2884);
                gl.cullFace(1029);
                break;
        }
    }
    if (parameters.frontFace) {
        gl.frontFace(map('frontFace', parameters.frontFace, {
            ccw: 2305,
            cw: 2304
        }));
    }
    if (parameters.unclippedDepth) {
        if (device.features.has('depth-clip-control')) {
            // EXT_depth_clamp
            gl.enable(34383);
        }
    }
    if (parameters.depthBias !== undefined) {
        gl.enable(32823);
        gl.polygonOffset(parameters.depthBias, parameters.depthBiasSlopeScale || 0);
    }
    // depthBiasSlopeScale: {
    //   // Handled by depthBias
    // },
    // WEBGL EXTENSIONS
    if (parameters.provokingVertex) {
        if (device.features.has('provoking-vertex-webgl')) {
            const extensions = webglDevice.getExtension('WEBGL_provoking_vertex');
            const ext = extensions.WEBGL_provoking_vertex;
            const vertex = map('provokingVertex', parameters.provokingVertex, {
                first: 36429,
                last: 36430
            });
            ext?.provokingVertexWEBGL(vertex);
        }
    }
    if (parameters.polygonMode || parameters.polygonOffsetLine) {
        if (device.features.has('polygon-mode-webgl')) {
            if (parameters.polygonMode) {
                const extensions = webglDevice.getExtension('WEBGL_polygon_mode');
                const ext = extensions.WEBGL_polygon_mode;
                const mode = map('polygonMode', parameters.polygonMode, {
                    fill: 6914,
                    line: 6913
                });
                ext?.polygonModeWEBGL(1028, mode);
                ext?.polygonModeWEBGL(1029, mode);
            }
            if (parameters.polygonOffsetLine) {
                gl.enable(10754);
            }
        }
    }
    if (device.features.has('shader-clip-cull-distance-webgl')) {
        if (parameters.clipDistance0) {
            gl.enable(12288);
        }
        if (parameters.clipDistance1) {
            gl.enable(12289);
        }
        if (parameters.clipDistance2) {
            gl.enable(12290);
        }
        if (parameters.clipDistance3) {
            gl.enable(12291);
        }
        if (parameters.clipDistance4) {
            gl.enable(12292);
        }
        if (parameters.clipDistance5) {
            gl.enable(12293);
        }
        if (parameters.clipDistance6) {
            gl.enable(12294);
        }
        if (parameters.clipDistance7) {
            gl.enable(12295);
        }
    }
    // DEPTH STENCIL
    if (parameters.depthWriteEnabled !== undefined) {
        gl.depthMask(mapBoolean('depthWriteEnabled', parameters.depthWriteEnabled));
    }
    if (parameters.depthCompare) {
        parameters.depthCompare !== 'always' ? gl.enable(2929) : gl.disable(2929);
        gl.depthFunc(convertCompareFunction('depthCompare', parameters.depthCompare));
    }
    if (parameters.stencilWriteMask) {
        const mask = parameters.stencilWriteMask;
        gl.stencilMaskSeparate(1028, mask);
        gl.stencilMaskSeparate(1029, mask);
    }
    if (parameters.stencilReadMask) {
        // stencilReadMask is handle inside stencil***Compare.
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn('stencilReadMask not supported under WebGL');
    }
    if (parameters.stencilCompare) {
        const mask = parameters.stencilReadMask || 0xffffffff;
        const glValue = convertCompareFunction('depthCompare', parameters.stencilCompare);
        // TODO - ensure back doesn't overwrite
        parameters.stencilCompare !== 'always' ? gl.enable(2960) : gl.disable(2960);
        gl.stencilFuncSeparate(1028, glValue, 0, mask);
        gl.stencilFuncSeparate(1029, glValue, 0, mask);
    }
    if (parameters.stencilPassOperation && parameters.stencilFailOperation && parameters.stencilDepthFailOperation) {
        const dppass = convertStencilOperation('stencilPassOperation', parameters.stencilPassOperation);
        const sfail = convertStencilOperation('stencilFailOperation', parameters.stencilFailOperation);
        const dpfail = convertStencilOperation('stencilDepthFailOperation', parameters.stencilDepthFailOperation);
        gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
        gl.stencilOpSeparate(1029, sfail, dpfail, dppass);
    }
    // stencilDepthFailOperation() {
    //   // handled by stencilPassOperation
    // },
    // stencilFailOperation() {
    //   // handled by stencilPassOperation
    // },
    // COLOR STATE
    switch(parameters.blend){
        case true:
            gl.enable(3042);
            break;
        case false:
            gl.disable(3042);
            break;
        default:
    }
    if (parameters.blendColorOperation || parameters.blendAlphaOperation) {
        const colorEquation = convertBlendOperationToEquation('blendColorOperation', parameters.blendColorOperation || 'add');
        const alphaEquation = convertBlendOperationToEquation('blendAlphaOperation', parameters.blendAlphaOperation || 'add');
        gl.blendEquationSeparate(colorEquation, alphaEquation);
        const colorSrcFactor = convertBlendFactorToFunction('blendColorSrcFactor', parameters.blendColorSrcFactor || 'one');
        const colorDstFactor = convertBlendFactorToFunction('blendColorDstFactor', parameters.blendColorDstFactor || 'zero');
        const alphaSrcFactor = convertBlendFactorToFunction('blendAlphaSrcFactor', parameters.blendAlphaSrcFactor || 'one');
        const alphaDstFactor = convertBlendFactorToFunction('blendAlphaDstFactor', parameters.blendAlphaDstFactor || 'zero');
        gl.blendFuncSeparate(colorSrcFactor, colorDstFactor, alphaSrcFactor, alphaDstFactor);
    }
}
function convertCompareFunction(parameter, value) {
    return map(parameter, value, {
        never: 512,
        less: 513,
        equal: 514,
        'less-equal': 515,
        greater: 516,
        'not-equal': 517,
        'greater-equal': 518,
        always: 519
    });
}
function convertToCompareFunction(parameter, value) {
    return map(parameter, value, {
        [512]: 'never',
        [513]: 'less',
        [514]: 'equal',
        [515]: 'less-equal',
        [516]: 'greater',
        [517]: 'not-equal',
        [518]: 'greater-equal',
        [519]: 'always'
    });
}
function convertStencilOperation(parameter, value) {
    return map(parameter, value, {
        keep: 7680,
        zero: 0,
        replace: 7681,
        invert: 5386,
        'increment-clamp': 7682,
        'decrement-clamp': 7683,
        'increment-wrap': 34055,
        'decrement-wrap': 34056
    });
}
function convertBlendOperationToEquation(parameter, value) {
    return map(parameter, value, {
        add: 32774,
        subtract: 32778,
        'reverse-subtract': 32779,
        min: 32775,
        max: 32776
    });
}
function convertBlendFactorToFunction(parameter, value) {
    return map(parameter, value, {
        one: 1,
        zero: 0,
        'src-color': 768,
        'one-minus-src-color': 769,
        'dst-color': 774,
        'one-minus-dst-color': 775,
        'src-alpha': 770,
        'one-minus-src-alpha': 771,
        'dst-alpha': 772,
        'one-minus-dst-alpha': 773,
        'src-alpha-saturated': 776,
        'constant-color': 32769,
        'one-minus-constant-color': 32770,
        'constant-alpha': 32771,
        'one-minus-constant-alpha': 32772
    });
}
function message(parameter, value) {
    return `Illegal parameter ${value} for ${parameter}`;
}
function map(parameter, value, valueMap) {
    if (!(value in valueMap)) {
        throw new Error(message(parameter, value));
    }
    return valueMap[value];
}
function mapBoolean(parameter, value) {
    return value;
}
/** Returns true if given object is empty, false otherwise. */ function isObjectEmpty(obj) {
    let isEmpty = true;
    // @ts-ignore key is unused
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for(const key in obj){
        isEmpty = false;
        break;
    }
    return isEmpty;
} //# sourceMappingURL=device-parameters.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/converters/sampler-parameters.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "convertSamplerParametersToWebGL": (()=>convertSamplerParametersToWebGL)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$device$2d$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/converters/device-parameters.js [app-client] (ecmascript)");
;
;
function convertSamplerParametersToWebGL(props) {
    const params = {};
    if (props.addressModeU) {
        params[10242] = convertAddressMode(props.addressModeU);
    }
    if (props.addressModeV) {
        params[10243] = convertAddressMode(props.addressModeV);
    }
    if (props.addressModeW) {
        params[32882] = convertAddressMode(props.addressModeW);
    }
    if (props.magFilter) {
        params[10240] = convertMaxFilterMode(props.magFilter);
    }
    if (props.minFilter || props.mipmapFilter) {
        // TODO - arbitrary choice of linear?
        params[10241] = convertMinFilterMode(props.minFilter || 'linear', props.mipmapFilter);
    }
    if (props.lodMinClamp !== undefined) {
        params[33082] = props.lodMinClamp;
    }
    if (props.lodMaxClamp !== undefined) {
        params[33083] = props.lodMaxClamp;
    }
    if (props.type === 'comparison-sampler') {
        // Setting prop.compare turns this into a comparison sampler
        params[34892] = 34894;
    }
    if (props.compare) {
        params[34893] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$device$2d$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertCompareFunction"])('compare', props.compare);
    }
    // Note depends on WebGL extension
    if (props.maxAnisotropy) {
        params[34046] = props.maxAnisotropy;
    }
    return params;
}
// HELPERS
/** Convert address more */ function convertAddressMode(addressMode) {
    switch(addressMode){
        case 'clamp-to-edge':
            return 33071;
        case 'repeat':
            return 10497;
        case 'mirror-repeat':
            return 33648;
    }
}
function convertMaxFilterMode(maxFilter) {
    switch(maxFilter){
        case 'nearest':
            return 9728;
        case 'linear':
            return 9729;
    }
}
/**
 * WebGPU has separate min filter and mipmap filter,
 * WebGL is combined and effectively offers 6 options
 */ function convertMinFilterMode(minFilter, mipmapFilter = 'none') {
    if (!mipmapFilter) {
        return convertMaxFilterMode(minFilter);
    }
    switch(mipmapFilter){
        case 'none':
            return convertMaxFilterMode(minFilter);
        case 'nearest':
            return minFilter === 'nearest' ? 9984 : 9986;
        case 'linear':
            return minFilter === 'nearest' ? 9985 : 9987;
    }
} //# sourceMappingURL=sampler-parameters.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-sampler.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "WEBGLSampler": (()=>WEBGLSampler)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$sampler$2d$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/converters/sampler-parameters.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/sampler.js [app-client] (ecmascript)");
;
;
;
class WEBGLSampler extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Sampler"] {
    device;
    handle;
    parameters;
    constructor(device, props){
        super(device, props);
        this.device = device;
        this.parameters = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$sampler$2d$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertSamplerParametersToWebGL"])(props);
        this.handle = this.handle || this.device.gl.createSampler();
        this._setSamplerParameters(this.parameters);
    }
    destroy() {
        if (this.handle) {
            this.device.gl.deleteSampler(this.handle);
            // @ts-expect-error read-only/undefined
            this.handle = undefined;
        }
    }
    toString() {
        return `Sampler(${this.id},${JSON.stringify(this.props)})`;
    }
    /** Set sampler parameters on the sampler */ _setSamplerParameters(parameters) {
        for (const [pname, value] of Object.entries(parameters)){
            // Apparently there are integer/float conversion issues requires two parameter setting functions in JavaScript.
            // For now, pick the float version for parameters specified as GLfloat.
            const param = Number(pname);
            switch(param){
                case 33082:
                case 33083:
                    this.device.gl.samplerParameterf(this.handle, param, value);
                    break;
                default:
                    this.device.gl.samplerParameteri(this.handle, param, value);
                    break;
            }
        }
    }
} //# sourceMappingURL=webgl-sampler.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "WEBGLTexture": (()=>WEBGLTexture)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$webgl$2d$texture$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/webgl-texture-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$webgl$2d$texture$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/converters/webgl-texture-table.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2d$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture-view.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-sampler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$sampler$2d$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/converters/sampler-parameters.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
class WEBGLTexture extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"] {
    // readonly MAX_ATTRIBUTES: number;
    device;
    gl;
    handle;
    sampler = undefined;
    view = undefined;
    mipmaps;
    // Texture type
    /** Whether the internal format is compressed */ compressed;
    /**
     * The WebGL target corresponding to the texture type
     * @note `target` cannot be modified by bind:
     * textures are special because when you first bind them to a target,
     * When you first bind a texture as a GL_TEXTURE_2D, you are saying that this texture is a 2D texture.
     * And it will always be a 2D texture; this state cannot be changed ever.
     * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;
     * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error
     */ glTarget;
    /** The WebGL format - essentially channel structure */ glFormat;
    /** The WebGL data format - the type of each channel */ glType;
    /** The WebGL constant corresponding to the WebGPU style constant in format */ glInternalFormat;
    // state
    /** Texture binding slot - TODO - move to texture view? */ textureUnit = 0;
    constructor(device, props){
        super(device, props);
        // Texture base class strips out the data prop, so we need to add it back in
        const propsWithData = {
            ...this.props
        };
        propsWithData.data = props.data;
        this.device = device;
        this.gl = this.device.gl;
        // Note: In WebGL the texture target defines the type of texture on first bind.
        this.glTarget = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$webgl$2d$texture$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWebGLTextureTarget"])(this.props.dimension);
        // The target format of this texture
        const formatInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$webgl$2d$texture$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTextureFormatWebGL"])(this.props.format);
        this.glInternalFormat = formatInfo.internalFormat;
        this.glFormat = formatInfo.format;
        this.glType = formatInfo.type;
        this.compressed = formatInfo.compressed;
        this.mipmaps = Boolean(this.props.mipmaps);
        this._initialize(propsWithData);
        Object.seal(this);
    }
    /** Initialize texture with supplied props */ // eslint-disable-next-line max-statements
    _initialize(propsWithData) {
        this.handle = this.props.handle || this.gl.createTexture();
        this.device.setSpectorMetadata(this.handle, {
            ...this.props,
            data: propsWithData.data
        });
        let { width, height } = propsWithData;
        if (!width || !height) {
            const textureSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"].getTextureDataSize(propsWithData.data);
            width = textureSize?.width || 1;
            height = textureSize?.height || 1;
        }
        // Store opts for accessors
        this.width = width;
        this.height = height;
        this.depth = propsWithData.depth;
        // Set texture sampler parameters
        this.setSampler(propsWithData.sampler);
        // @ts-ignore TODO - fix types
        this.view = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2d$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLTextureView"](this.device, {
            ...this.props,
            texture: this
        });
        this.bind();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$webgl$2d$texture$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initializeTextureStorage"])(this.gl, this.mipLevels, this);
        if (propsWithData.data) {
            // prettier-ignore
            switch(propsWithData.dimension){
                case '1d':
                    this.setTexture1DData(propsWithData.data);
                    break;
                case '2d':
                    this.setTexture2DData(propsWithData.data);
                    break;
                case '3d':
                    this.setTexture3DData(propsWithData.data);
                    break;
                case 'cube':
                    this.setTextureCubeData(propsWithData.data);
                    break;
                case '2d-array':
                    this.setTextureArrayData(propsWithData.data);
                    break;
                case 'cube-array':
                    this.setTextureCubeArrayData(propsWithData.data);
                    break;
                // @ts-expect-error
                default:
                    throw new Error(propsWithData.dimension);
            }
        }
        if (this.mipmaps) {
            this.generateMipmap();
        }
    }
    destroy() {
        if (this.handle) {
            this.gl.deleteTexture(this.handle);
            this.removeStats();
            this.trackDeallocatedMemory('Texture');
            // this.handle = null;
            this.destroyed = true;
        }
    }
    createView(props) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2d$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLTextureView"](this.device, {
            ...props,
            texture: this
        });
    }
    setSampler(sampler = {}) {
        let samplerProps;
        if (sampler instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLSampler"]) {
            this.sampler = sampler;
            samplerProps = sampler.props;
        } else {
            this.sampler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLSampler"](this.device, sampler);
            samplerProps = sampler;
        }
        const parameters = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$sampler$2d$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertSamplerParametersToWebGL"])(samplerProps);
        this._setSamplerParameters(parameters);
    }
    // Call to regenerate mipmaps after modifying texture(s)
    generateMipmap(options) {
        const isFilterableAndRenderable = this.device.isTextureFormatRenderable(this.props.format) && this.device.isTextureFormatFilterable(this.props.format);
        if (!isFilterableAndRenderable) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`${this} is not renderable or filterable, may not be able to generate mipmaps`)();
            if (!options?.force) {
                return;
            }
        }
        try {
            this.gl.bindTexture(this.glTarget, this.handle);
            this.gl.generateMipmap(this.glTarget);
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`Error generating mipmap for ${this}: ${error.message}`)();
        } finally{
            this.gl.bindTexture(this.glTarget, null);
        }
    }
    // Image Data Setters
    copyExternalImage(options) {
        const size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"].getExternalImageSize(options.image);
        const opts = {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"].defaultCopyExternalImageOptions,
            ...size,
            ...options
        };
        const { image, depth, mipLevel, x, y, z, flipY } = opts;
        let { width, height } = opts;
        const { dimension, glTarget, glFormat, glInternalFormat, glType } = this;
        // WebGL will error if we try to copy outside the bounds of the texture
        width = Math.min(width, this.width - x);
        height = Math.min(height, this.height - y);
        if (options.sourceX || options.sourceY) {
            // requires copyTexSubImage2D from a framebuffer'
            throw new Error('WebGL does not support sourceX/sourceY)');
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$webgl$2d$texture$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copyExternalImageToMipLevel"])(this.device.gl, this.handle, image, {
            dimension,
            mipLevel,
            x,
            y,
            z,
            width,
            height,
            depth,
            glFormat,
            glInternalFormat,
            glType,
            glTarget,
            flipY
        });
        return {
            width: opts.width,
            height: opts.height
        };
    }
    setTexture1DData(data) {
        throw new Error('setTexture1DData not supported in WebGL.');
    }
    /** Set a simple texture */ setTexture2DData(lodData, depth = 0) {
        this.bind();
        const lodArray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"].normalizeTextureData(lodData, this);
        // If the user provides multiple LODs, then automatic mipmap
        // generation generateMipmap() should be disabled to avoid overwriting them.
        if (lodArray.length > 1 && this.props.mipmaps !== false) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`Texture ${this.id} mipmap and multiple LODs.`)();
        }
        for(let lodLevel = 0; lodLevel < lodArray.length; lodLevel++){
            const imageData = lodArray[lodLevel];
            this._setMipLevel(depth, lodLevel, imageData);
        }
        this.unbind();
    }
    /**
     * Sets a 3D texture
     * @param data
     */ setTexture3DData(data) {
        if (this.props.dimension !== '3d') {
            throw new Error(this.id);
        }
        if (ArrayBuffer.isView(data)) {
            this.bind();
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$webgl$2d$texture$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copyCPUDataToMipLevel"])(this.device.gl, data, this);
            this.unbind();
        }
    }
    /**
     * Set a Texture Cube Data
     * @todo - could support TextureCubeArray with depth
     * @param data
     * @param index
     */ setTextureCubeData(data, depth = 0) {
        if (this.props.dimension !== 'cube') {
            throw new Error(this.id);
        }
        for (const face of __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"].CubeFaces){
            this.setTextureCubeFaceData(data[face], face);
        }
    }
    /**
     * Sets an entire texture array
     * @param data
     */ setTextureArrayData(data) {
        if (this.props.dimension !== '2d-array') {
            throw new Error(this.id);
        }
        throw new Error('setTextureArrayData not implemented.');
    }
    /**
     * Sets an entire texture cube array
     * @param data
     */ setTextureCubeArrayData(data) {
        throw new Error('setTextureCubeArrayData not supported in WebGL2.');
    }
    setTextureCubeFaceData(lodData, face, depth = 0) {
        // assert(this.props.dimension === 'cube');
        // If the user provides multiple LODs, then automatic mipmap
        // generation generateMipmap() should be disabled to avoid overwriting them.
        if (Array.isArray(lodData) && lodData.length > 1 && this.props.mipmaps !== false) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`${this.id} has mipmap and multiple LODs.`)();
        }
        const faceDepth = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"].CubeFaces.indexOf(face);
        this.setTexture2DData(lodData, faceDepth);
    }
    // DEPRECATED METHODS
    /** Update external texture (video frame or canvas) @deprecated Use ExternalTexture */ update() {
        throw new Error('Texture.update() not implemented. Use ExternalTexture');
    }
    // INTERNAL METHODS
    /** @todo update this method to accept LODs */ setImageDataForFace(options) {
        const { face, width, height, pixels, data, format = 6408, type = 5121 } = options;
        const { gl } = this;
        const imageData = pixels || data;
        this.bind();
        if (imageData instanceof Promise) {
            imageData.then((resolvedImageData)=>this.setImageDataForFace(Object.assign({}, options, {
                    face,
                    data: resolvedImageData,
                    pixels: resolvedImageData
                })));
        } else if (this.width || this.height) {
            gl.texImage2D(face, 0, format, width, height, 0 /* border*/ , format, type, imageData);
        } else {
            gl.texImage2D(face, 0, format, format, type, imageData);
        }
    }
    _getImageDataMap(faceData) {
        for(let i = 0; i < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"].CubeFaces.length; ++i){
            const faceName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"].CubeFaces[i];
            if (faceData[faceName]) {
                faceData[34069 + i] = faceData[faceName];
                delete faceData[faceName];
            }
        }
        return faceData;
    }
    // RESOURCE METHODS
    /**
     * Sets sampler parameters on texture
     */ _setSamplerParameters(parameters) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].log(1, `${this.id} sampler parameters`, this.device.getGLKeys(parameters))();
        this.gl.bindTexture(this.glTarget, this.handle);
        for (const [pname, pvalue] of Object.entries(parameters)){
            const param = Number(pname);
            const value = pvalue;
            // Apparently integer/float issues require two different texture parameter setting functions in JavaScript.
            // For now, pick the float version for parameters specified as GLfloat.
            switch(param){
                case 33082:
                case 33083:
                    this.gl.texParameterf(this.glTarget, param, value);
                    break;
                case 10241:
                    this.gl.texParameteri(this.glTarget, param, value);
                    break;
                case 10242:
                case 10243:
                    this.gl.texParameteri(this.glTarget, param, value);
                    break;
                case 34046:
                    // We have to query feature before using it
                    if (this.device.features.has('texture-filterable-anisotropic-webgl')) {
                        this.gl.texParameteri(this.glTarget, param, value);
                    }
                    break;
                default:
                    this.gl.texParameteri(this.glTarget, param, value);
                    break;
            }
        }
        this.gl.bindTexture(this.glTarget, null);
    }
    // INTERNAL SETTERS
    /**
     * Copy a region of data from a CPU memory buffer into this texture.
     * @todo -   GLUnpackParameters parameters
     */ _setMipLevel(depth, mipLevel, textureData, glTarget = this.glTarget) {
        // if (!textureData) {
        //   clearMipLevel(this.device.gl, {...this, depth, level});
        //   return;
        // }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"].isExternalImage(textureData)) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$webgl$2d$texture$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copyExternalImageToMipLevel"])(this.device.gl, this.handle, textureData, {
                ...this,
                depth,
                mipLevel,
                glTarget,
                flipY: this.props.flipY
            });
            return;
        }
        // @ts-expect-error
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"].isTextureLevelData(textureData)) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$webgl$2d$texture$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copyCPUDataToMipLevel"])(this.device.gl, textureData.data, {
                ...this,
                depth,
                mipLevel,
                glTarget
            });
            return;
        }
        throw new Error('Texture: invalid image data');
    }
    // HELPERS
    getActiveUnit() {
        return this.gl.getParameter(34016) - 33984;
    }
    bind(textureUnit) {
        const { gl } = this;
        if (textureUnit !== undefined) {
            this.textureUnit = textureUnit;
            gl.activeTexture(33984 + textureUnit);
        }
        gl.bindTexture(this.glTarget, this.handle);
        return textureUnit;
    }
    unbind(textureUnit) {
        const { gl } = this;
        if (textureUnit !== undefined) {
            this.textureUnit = textureUnit;
            gl.activeTexture(33984 + textureUnit);
        }
        gl.bindTexture(this.glTarget, null);
        return textureUnit;
    }
} // TODO - Remove when texture refactor is complete
 /*
setCubeMapData(options: {
  width: number;
  height: number;
  data: Record<GL, Texture2DData> | Record<TextureCubeFace, Texture2DData>;
  format?: any;
  type?: any;
  /** @deprecated Use .data *
  pixels: any;
}): void {
  const {gl} = this;

  const {width, height, pixels, data, format = GL.RGBA, type = GL.UNSIGNED_BYTE} = options;

  // pixel data (imageDataMap) is an Object from Face to Image or Promise.
  // For example:
  // {
  // GL.TEXTURE_CUBE_MAP_POSITIVE_X : Image-or-Promise,
  // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : Image-or-Promise,
  // ... }
  // To provide multiple level-of-details (LODs) this can be Face to Array
  // of Image or Promise, like this
  // {
  // GL.TEXTURE_CUBE_MAP_POSITIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],
  // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],
  // ... }

  const imageDataMap = this._getImageDataMap(pixels || data);

  const resolvedFaces = WEBGLTexture.FACES.map(face => {
    const facePixels = imageDataMap[face];
    return Array.isArray(facePixels) ? facePixels : [facePixels];
  });
  this.bind();

  WEBGLTexture.FACES.forEach((face, index) => {
    if (resolvedFaces[index].length > 1 && this.props.mipmaps !== false) {
      // If the user provides multiple LODs, then automatic mipmap
      // generation generateMipmap() should be disabled to avoid overwritting them.
      log.warn(`${this.id} has mipmap and multiple LODs.`)();
    }
    resolvedFaces[index].forEach((image, lodLevel) => {
      // TODO: adjust width & height for LOD!
      if (width && height) {
        gl.texImage2D(face, lodLevel, format, width, height, 0 /* border*, format, type, image);
      } else {
        gl.texImage2D(face, lodLevel, format, format, type, image);
      }
    });
  });

  this.unbind();
}
*/  //# sourceMappingURL=webgl-texture.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/parse-shader-compiler-log.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 * Parse a WebGL-format GLSL compilation log into an array of WebGPU style message records.
 * This follows documented WebGL conventions for compilation logs.
 * Based on https://github.com/wwwtyro/gl-format-compiler-error (public domain)
 */ __turbopack_esm__({
    "parseShaderCompilerLog": (()=>parseShaderCompilerLog)
});
function parseShaderCompilerLog(errLog) {
    // Parse the error - note: browser and driver dependent
    const lines = errLog.split(/\r?\n/);
    const messages = [];
    for (const line of lines){
        if (line.length <= 1) {
            continue; // eslint-disable-line no-continue
        }
        const segments = line.split(':');
        // Check for messages with no line information `ERROR: unsupported shader version`
        if (segments.length === 2) {
            const [messageType, message] = segments;
            messages.push({
                message: message.trim(),
                type: getMessageType(messageType),
                lineNum: 0,
                linePos: 0
            });
            continue; // eslint-disable-line no-continue
        }
        const [messageType, linePosition, lineNumber, ...rest] = segments;
        let lineNum = parseInt(lineNumber, 10);
        if (isNaN(lineNum)) {
            lineNum = 0;
        }
        let linePos = parseInt(linePosition, 10);
        if (isNaN(linePos)) {
            linePos = 0;
        }
        messages.push({
            message: rest.join(':').trim(),
            type: getMessageType(messageType),
            lineNum,
            linePos
        });
    }
    return messages;
}
/** Ensure supported type */ function getMessageType(messageType) {
    const MESSAGE_TYPES = [
        'warning',
        'error',
        'info'
    ];
    const lowerCaseType = messageType.toLowerCase();
    return MESSAGE_TYPES.includes(lowerCaseType) ? lowerCaseType : 'info';
} //# sourceMappingURL=parse-shader-compiler-log.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-shader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "WEBGLShader": (()=>WEBGLShader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$parse$2d$shader$2d$compiler$2d$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/parse-shader-compiler-log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/shader.js [app-client] (ecmascript)");
;
;
;
class WEBGLShader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Shader"] {
    device;
    handle;
    constructor(device, props){
        super(device, props);
        this.device = device;
        switch(this.props.stage){
            case 'vertex':
                this.handle = this.props.handle || this.device.gl.createShader(35633);
                break;
            case 'fragment':
                this.handle = this.props.handle || this.device.gl.createShader(35632);
                break;
            default:
                throw new Error(this.props.stage);
        }
        this._compile(this.source);
    }
    destroy() {
        if (this.handle) {
            this.removeStats();
            this.device.gl.deleteShader(this.handle);
            // this.handle = null;
            this.destroyed = true;
        }
    }
    get asyncCompilationStatus() {
        return this._waitForCompilationComplete().then(()=>this.compilationStatus);
    }
    async getCompilationInfo() {
        await this._waitForCompilationComplete();
        return this.getCompilationInfoSync();
    }
    getCompilationInfoSync() {
        const shaderLog = this.device.gl.getShaderInfoLog(this.handle);
        return shaderLog ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$parse$2d$shader$2d$compiler$2d$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseShaderCompilerLog"])(shaderLog) : [];
    }
    getTranslatedSource() {
        const extensions = this.device.getExtension('WEBGL_debug_shaders');
        const ext = extensions.WEBGL_debug_shaders;
        return ext?.getTranslatedShaderSource(this.handle) || null;
    }
    // PRIVATE METHODS
    /** Compile a shader and get compilation status */ async _compile(source) {
        source = source.startsWith('#version ') ? source : `#version 300 es\n${source}`;
        const { gl } = this.device;
        gl.shaderSource(this.handle, source);
        gl.compileShader(this.handle);
        // For performance reasons, avoid checking shader compilation errors on production
        if (!this.device.props.debug) {
            this.compilationStatus = 'pending';
            return;
        }
        // Sync case - slower, but advantage is that it throws in the constructor, making break on error more useful
        if (!this.device.features.has('compilation-status-async-webgl')) {
            this._getCompilationStatus();
            // The `Shader` base class will determine if debug window should be opened based on this.compilationStatus
            this.debugShader();
            if (this.compilationStatus === 'error') {
                throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
            }
            return;
        }
        // async case
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].once(1, 'Shader compilation is asynchronous')();
        await this._waitForCompilationComplete();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)();
        this._getCompilationStatus();
        // The `Shader` base class will determine if debug window should be opened based on this.compilationStatus
        this.debugShader();
    }
    /** Use KHR_parallel_shader_compile extension if available */ async _waitForCompilationComplete() {
        const waitMs = async (ms)=>await new Promise((resolve)=>setTimeout(resolve, ms));
        const DELAY_MS = 10; // Shader compilation is typically quite fast (with some exceptions)
        // If status polling is not available, we can't wait for completion. Just wait a little to minimize blocking
        if (!this.device.features.has('compilation-status-async-webgl')) {
            await waitMs(DELAY_MS);
            return;
        }
        const { gl } = this.device;
        for(;;){
            const complete = gl.getShaderParameter(this.handle, 37297);
            if (complete) {
                return;
            }
            await waitMs(DELAY_MS);
        }
    }
    /**
     * Get the shader compilation status
     * TODO - Load log even when no error reported, to catch warnings?
     * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
     */ _getCompilationStatus() {
        this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? 'success' : 'error';
    }
} // TODO - Original code from luma.gl v8 - keep until new debug functionality has matured
 // if (!compilationSuccess) {
 //   const parsedLog = shaderLog ? parseShaderCompilerLog(shaderLog) : [];
 //   const messages = parsedLog.filter(message => message.type === 'error');
 //   const formattedLog = formatCompilerLog(messages, source, {showSourceCode: 'all', html: true});
 //   const shaderDescription = `${this.stage} shader ${shaderName}`;
 //   log.error(`GLSL compilation errors in ${shaderDescription}\n${formattedLog}`)();
 //   displayShaderLog(parsedLog, source, shaderName);
 // }
 //# sourceMappingURL=webgl-shader.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/utils/fill-array.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Uses copyWithin to significantly speed up typed array value filling
__turbopack_esm__({
    "fillArray": (()=>fillArray)
});
function fillArray(options) {
    const { target, source, start = 0, count = 1 } = options;
    const length = source.length;
    const total = count * length;
    let copied = 0;
    for(let i = start; copied < length; copied++){
        target[i++] = source[copied];
    }
    while(copied < total){
        // If we have copied less than half, copy everything we got
        // else copy remaining in one operation
        if (copied < total - copied) {
            target.copyWithin(start + copied, start, start + copied);
            copied *= 2;
        } else {
            target.copyWithin(start + copied, start, start + total - copied);
            copied = total;
        }
    }
    return options.target;
} //# sourceMappingURL=fill-array.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-vertex-array.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "WEBGLVertexArray": (()=>WEBGLVertexArray)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$get$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@probe.gl/env/dist/lib/get-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$vertex$2d$formats$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/converters/vertex-formats.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$array$2d$utils$2d$flat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/array-utils-flat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$utils$2f$fill$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/utils/fill-array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$vertex$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/vertex-array.js [app-client] (ecmascript)");
;
;
;
;
;
class WEBGLVertexArray extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$vertex$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexArray"] {
    get [Symbol.toStringTag]() {
        return 'VertexArray';
    }
    device;
    handle;
    /** Attribute 0 buffer constant */ buffer = null;
    bufferValue = null;
    /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */ static isConstantAttributeZeroSupported(device) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$get$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBrowser"])() === 'Chrome';
    }
    // Create a VertexArray
    constructor(device, props){
        super(device, props);
        this.device = device;
        this.handle = this.device.gl.createVertexArray();
    }
    destroy() {
        super.destroy();
        if (this.buffer) {
            this.buffer?.destroy();
        }
        if (this.handle) {
            this.device.gl.deleteVertexArray(this.handle);
            // @ts-expect-error read-only/undefined
            this.handle = undefined;
        }
    // Auto-delete elements?
    // return [this.elements];
    }
    /**
    // Set (bind/unbind) an elements buffer, for indexed rendering.
    // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported
     *
     * @param elementBuffer
     */ setIndexBuffer(indexBuffer) {
        const buffer = indexBuffer;
        // Explicitly allow `null` to support clearing the index buffer
        if (buffer && buffer.glTarget !== 34963) {
            throw new Error('Use .setBuffer()');
        }
        // In WebGL The GL.ELEMENT_ARRAY_BUFFER_BINDING is stored on the VertexArrayObject
        this.device.gl.bindVertexArray(this.handle);
        this.device.gl.bindBuffer(34963, buffer ? buffer.handle : null);
        this.indexBuffer = buffer;
        // Unbind to prevent unintended changes to the VAO.
        this.device.gl.bindVertexArray(null);
    }
    /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */ setBuffer(location, attributeBuffer) {
        const buffer = attributeBuffer;
        // Sanity check target
        if (buffer.glTarget === 34963) {
            throw new Error('Use .setIndexBuffer()');
        }
        const { size, type, stride, offset, normalized, integer, divisor } = this._getAccessor(location);
        this.device.gl.bindVertexArray(this.handle);
        // A non-zero buffer object must be bound to the GL_ARRAY_BUFFER target
        this.device.gl.bindBuffer(34962, buffer.handle);
        // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
        if (integer) {
            this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
        } else {
            // Attaches ARRAY_BUFFER with specified buffer format to location
            this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
        }
        // Clear binding - keeping it may cause [.WebGL-0x12804417100]
        // GL_INVALID_OPERATION: A transform feedback buffer that would be written to is also bound to a non-transform-feedback target
        this.device.gl.bindBuffer(34962, null);
        // Mark as non-constant
        this.device.gl.enableVertexAttribArray(location);
        // Set the step mode 0=vertex, 1=instance
        this.device.gl.vertexAttribDivisor(location, divisor || 0);
        this.attributes[location] = buffer;
        // Unbind to prevent unintended changes to the VAO.
        this.device.gl.bindVertexArray(null);
    }
    /** Set a location in vertex attributes array to a constant value, disables the location */ setConstantWebGL(location, value) {
        this._enable(location, false);
        this.attributes[location] = value;
    }
    bindBeforeRender() {
        this.device.gl.bindVertexArray(this.handle);
        this._applyConstantAttributes();
    }
    unbindAfterRender() {
        // Unbind to prevent unintended changes to the VAO.
        this.device.gl.bindVertexArray(null);
    }
    // Internal methods
    /**
     * Constant attributes need to be reset before every draw call
     * Any attribute that is disabled in the current vertex array object
     * is read from the context's global constant value for that attribute location.
     * @note Constant attributes are only supported in WebGL, not in WebGPU
     */ _applyConstantAttributes() {
        for(let location = 0; location < this.maxVertexAttributes; ++location){
            const constant = this.attributes[location];
            // A typed array means this is a constant
            if (ArrayBuffer.isView(constant)) {
                this.device.setConstantAttributeWebGL(location, constant);
            }
        }
    }
    /**
     * Set a location in vertex attributes array to a buffer, enables the location, sets divisor
     * @note requires vertex array to be bound
     */ // protected _setAttributeLayout(location: number): void {
    //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);
    //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
    //   if (integer) {
    //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
    //   } else {
    //     // Attaches ARRAY_BUFFER with specified buffer format to location
    //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
    //   }
    //   this.device.gl.vertexAttribDivisor(location, divisor || 0);
    // }
    /** Get an accessor from the  */ _getAccessor(location) {
        const attributeInfo = this.attributeInfos[location];
        if (!attributeInfo) {
            throw new Error(`Unknown attribute location ${location}`);
        }
        const glType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$vertex$2d$formats$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGLFromVertexType"])(attributeInfo.bufferDataType);
        return {
            size: attributeInfo.bufferComponents,
            type: glType,
            stride: attributeInfo.byteStride,
            offset: attributeInfo.byteOffset,
            normalized: attributeInfo.normalized,
            // it is the shader attribute declaration, not the vertex memory format,
            // that determines if the data in the buffer will be treated as integers.
            //
            // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,
            // but as far as we can tell, WebGPU does not.
            integer: attributeInfo.integer,
            divisor: attributeInfo.stepMode === 'instance' ? 1 : 0
        };
    }
    /**
     * Enabling an attribute location makes it reference the currently bound buffer
     * Disabling an attribute location makes it reference the global constant value
     * TODO - handle single values for size 1 attributes?
     * TODO - convert classic arrays based on known type?
     */ _enable(location, enable = true) {
        // Attribute 0 cannot be disabled in most desktop OpenGL based browsers...
        const canDisableAttributeZero = WEBGLVertexArray.isConstantAttributeZeroSupported(this.device);
        const canDisableAttribute = canDisableAttributeZero || location !== 0;
        if (enable || canDisableAttribute) {
            location = Number(location);
            this.device.gl.bindVertexArray(this.handle);
            if (enable) {
                this.device.gl.enableVertexAttribArray(location);
            } else {
                this.device.gl.disableVertexAttribArray(location);
            }
            this.device.gl.bindVertexArray(null);
        }
    }
    /**
     * Provide a means to create a buffer that is equivalent to a constant.
     * NOTE: Desktop OpenGL cannot disable attribute 0.
     * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
     * this-has-significant-performance-penalty
     */ getConstantBuffer(elementCount, value) {
        // Create buffer only when needed, and reuse it (avoids inflating buffer creation statistics)
        const constantValue = normalizeConstantArrayValue(value);
        const byteLength = constantValue.byteLength * elementCount;
        const length = constantValue.length * elementCount;
        if (this.buffer && byteLength !== this.buffer.byteLength) {
            throw new Error(`Buffer size is immutable, byte length ${byteLength} !== ${this.buffer.byteLength}.`);
        }
        let updateNeeded = !this.buffer;
        this.buffer = this.buffer || this.device.createBuffer({
            byteLength
        });
        // Reallocate and update contents if needed
        updateNeeded = updateNeeded || !compareConstantArrayValues(constantValue, this.bufferValue);
        if (updateNeeded) {
            // Create a typed array that is big enough, and fill it with the required data
            const typedArray = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$array$2d$utils$2d$flat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getScratchArray"])(value.constructor, length);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$utils$2f$fill$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillArray"])({
                target: typedArray,
                source: constantValue,
                start: 0,
                count: length
            });
            this.buffer.write(typedArray);
            this.bufferValue = value;
        }
        return this.buffer;
    }
}
// HELPER FUNCTIONS
/**
 * TODO - convert Arrays based on known type? (read type from accessor, don't assume Float32Array)
 * TODO - handle single values for size 1 attributes?
 */ function normalizeConstantArrayValue(arrayValue) {
    if (Array.isArray(arrayValue)) {
        return new Float32Array(arrayValue);
    }
    return arrayValue;
}
/**
 *
 */ function compareConstantArrayValues(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
        return false;
    }
    for(let i = 0; i < v1.length; ++i){
        if (v1[i] !== v2[i]) {
            return false;
        }
    }
    return true;
} //# sourceMappingURL=webgl-vertex-array.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/webgl-topology-utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "getGLDrawMode": (()=>getGLDrawMode),
    "getGLPrimitive": (()=>getGLPrimitive),
    "getPrimitiveCount": (()=>getPrimitiveCount),
    "getPrimitiveDrawMode": (()=>getPrimitiveDrawMode),
    "getVertexCount": (()=>getVertexCount)
});
;
function getPrimitiveDrawMode(drawMode) {
    switch(drawMode){
        case 0:
            return 0;
        case 1:
            return 1;
        case 3:
            return 1;
        case 2:
            return 1;
        case 4:
            return 4;
        case 5:
            return 4;
        case 6:
            return 4;
        default:
            throw new Error('drawMode');
    }
}
function getPrimitiveCount(options) {
    const { drawMode, vertexCount } = options;
    switch(drawMode){
        case 0:
        case 2:
            return vertexCount;
        case 1:
            return vertexCount / 2;
        case 3:
            return vertexCount - 1;
        case 4:
            return vertexCount / 3;
        case 5:
        case 6:
            return vertexCount - 2;
        default:
            throw new Error('drawMode');
    }
}
function getVertexCount(options) {
    const { drawMode, vertexCount } = options;
    const primitiveCount = getPrimitiveCount({
        drawMode,
        vertexCount
    });
    switch(getPrimitiveDrawMode(drawMode)){
        case 0:
            return primitiveCount;
        case 1:
            return primitiveCount * 2;
        case 4:
            return primitiveCount * 3;
        default:
            throw new Error('drawMode');
    }
}
function getGLDrawMode(topology) {
    // prettier-ignore
    switch(topology){
        case 'point-list':
            return 0;
        case 'line-list':
            return 1;
        case 'line-strip':
            return 3;
        case 'triangle-list':
            return 4;
        case 'triangle-strip':
            return 5;
        default:
            throw new Error(topology);
    }
}
function getGLPrimitive(topology) {
    // prettier-ignore
    switch(topology){
        case 'point-list':
            return 0;
        case 'line-list':
            return 1;
        case 'line-strip':
            return 1;
        case 'triangle-list':
            return 4;
        case 'triangle-strip':
            return 4;
        default:
            throw new Error(topology);
    }
} //# sourceMappingURL=webgl-topology-utils.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-transform-feedback.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "WEBGLTransformFeedback": (()=>WEBGLTransformFeedback)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$webgl$2d$topology$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/webgl-topology-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$transform$2d$feedback$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/transform-feedback.js [app-client] (ecmascript)");
;
;
;
;
class WEBGLTransformFeedback extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$transform$2d$feedback$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransformFeedback"] {
    device;
    gl;
    handle;
    /**
     * NOTE: The Model already has this information while drawing, but
     * TransformFeedback currently needs it internally, to look up
     * varying information outside of a draw() call.
     */ layout;
    buffers = {};
    unusedBuffers = {};
    /**
     * Allows us to avoid a Chrome bug where a buffer that is already bound to a
     * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
     * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346
     */ bindOnUse = true;
    _bound = false;
    constructor(device, props){
        super(device, props);
        this.device = device;
        this.gl = device.gl;
        this.handle = this.props.handle || this.gl.createTransformFeedback();
        this.layout = this.props.layout;
        if (props.buffers) {
            this.setBuffers(props.buffers);
        }
        Object.seal(this);
    }
    destroy() {
        this.gl.deleteTransformFeedback(this.handle);
        super.destroy();
    }
    begin(topology = 'point-list') {
        this.gl.bindTransformFeedback(36386, this.handle);
        if (this.bindOnUse) {
            this._bindBuffers();
        }
        this.gl.beginTransformFeedback((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$webgl$2d$topology$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGLPrimitive"])(topology));
    }
    end() {
        this.gl.endTransformFeedback();
        if (this.bindOnUse) {
            this._unbindBuffers();
        }
        this.gl.bindTransformFeedback(36386, null);
    }
    // SUBCLASS
    setBuffers(buffers) {
        this.buffers = {};
        this.unusedBuffers = {};
        this.bind(()=>{
            for(const bufferName in buffers){
                this.setBuffer(bufferName, buffers[bufferName]);
            }
        });
    }
    setBuffer(locationOrName, bufferOrRange) {
        const location = this._getVaryingIndex(locationOrName);
        const { buffer, byteLength, byteOffset } = this._getBufferRange(bufferOrRange);
        if (location < 0) {
            this.unusedBuffers[locationOrName] = buffer;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`${this.id} unusedBuffers varying buffer ${locationOrName}`)();
            return;
        }
        this.buffers[location] = {
            buffer,
            byteLength,
            byteOffset
        };
        // Need to avoid chrome bug where buffer that is already bound to a different target
        // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
        if (!this.bindOnUse) {
            this._bindBuffer(location, buffer, byteOffset, byteLength);
        }
    }
    getBuffer(locationOrName) {
        if (isIndex(locationOrName)) {
            return this.buffers[locationOrName] || null;
        }
        const location = this._getVaryingIndex(locationOrName);
        return location >= 0 ? this.buffers[location] : null;
    }
    bind(funcOrHandle = this.handle) {
        if (typeof funcOrHandle !== 'function') {
            this.gl.bindTransformFeedback(36386, funcOrHandle);
            return this;
        }
        let value;
        if (!this._bound) {
            this.gl.bindTransformFeedback(36386, this.handle);
            this._bound = true;
            value = funcOrHandle();
            this._bound = false;
            this.gl.bindTransformFeedback(36386, null);
        } else {
            value = funcOrHandle();
        }
        return value;
    }
    unbind() {
        this.bind(null);
    }
    // PRIVATE METHODS
    /** Extract offsets for bindBufferRange */ _getBufferRange(bufferOrRange) {
        if (bufferOrRange instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLBuffer"]) {
            return {
                buffer: bufferOrRange,
                byteOffset: 0,
                byteLength: bufferOrRange.byteLength
            };
        }
        // To use bindBufferRange either offset or size must be specified.
        // @ts-expect-error Must be a BufferRange.
        const { buffer, byteOffset = 0, byteLength = bufferOrRange.buffer.byteLength } = bufferOrRange;
        return {
            buffer,
            byteOffset,
            byteLength
        };
    }
    _getVaryingIndex(locationOrName) {
        if (isIndex(locationOrName)) {
            return Number(locationOrName);
        }
        for (const varying of this.layout.varyings){
            if (locationOrName === varying.name) {
                return varying.location;
            }
        }
        return -1;
    }
    /**
     * Need to avoid chrome bug where buffer that is already bound to a different target
     * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
     */ _bindBuffers() {
        for(const bufferIndex in this.buffers){
            const { buffer, byteLength, byteOffset } = this._getBufferRange(this.buffers[bufferIndex]);
            this._bindBuffer(Number(bufferIndex), buffer, byteOffset, byteLength);
        }
    }
    _unbindBuffers() {
        for(const bufferIndex in this.buffers){
            this.gl.bindBufferBase(35982, Number(bufferIndex), null);
        }
    }
    _bindBuffer(index, buffer, byteOffset = 0, byteLength) {
        const handle = buffer && buffer.handle;
        if (!handle || byteLength === undefined) {
            this.gl.bindBufferBase(35982, index, handle);
        } else {
            this.gl.bindBufferRange(35982, index, handle, byteOffset, byteLength);
        }
    }
}
/**
 * Returns true if the given value is an integer, or a string that
 * trivially converts to an integer (only numeric characters).
 */ function isIndex(value) {
    if (typeof value === 'number') {
        return Number.isInteger(value);
    }
    return /^\d+$/.test(value);
} //# sourceMappingURL=webgl-transform-feedback.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-query-set.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// WebGL2 Query (also handles disjoint timer extensions)
__turbopack_esm__({
    "WEBGLQuerySet": (()=>WEBGLQuerySet)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$query$2d$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/query-set.js [app-client] (ecmascript)");
;
;
class WEBGLQuerySet extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$query$2d$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QuerySet"] {
    device;
    handle;
    target = null;
    _queryPending = false;
    _pollingPromise = null;
    get [Symbol.toStringTag]() {
        return 'Query';
    }
    // Create a query class
    constructor(device, props){
        super(device, props);
        this.device = device;
        if (props.count > 1) {
            throw new Error('WebGL QuerySet can only have one value');
        }
        this.handle = this.device.gl.createQuery();
        Object.seal(this);
    }
    destroy() {
        this.device.gl.deleteQuery(this.handle);
    }
    // FOR RENDER PASS AND COMMAND ENCODER
    /**
     * Shortcut for timer query (dependent on extension in both WebGL1 and 2)
     * Measures GPU time delta between this call and a matching `end` call in the
     * GPU instruction stream.
     */ beginTimestampQuery() {
        return this._begin(35007);
    }
    endTimestampQuery() {
        this._end();
    }
    // Shortcut for occlusion queries
    beginOcclusionQuery(options) {
        return this._begin(options?.conservative ? 36202 : 35887);
    }
    endOcclusionQuery() {
        this._end();
    }
    // Shortcut for transformFeedbackQuery
    beginTransformFeedbackQuery() {
        return this._begin(35976);
    }
    endTransformFeedbackQuery() {
        this._end();
    }
    async resolveQuery() {
        const value = await this.pollQuery();
        return [
            value
        ];
    }
    // PRIVATE METHODS
    /**
     * Due to OpenGL API limitations, after calling `begin()` on one Query
     * instance, `end()` must be called on that same instance before
     * calling `begin()` on another query. While there can be multiple
     * outstanding queries representing disjoint `begin()`/`end()` intervals.
     * It is not possible to interleave or overlap `begin` and `end` calls.
     */ _begin(target) {
        // Don't start a new query if one is already active.
        if (this._queryPending) {
            return;
        }
        this.target = target;
        this.device.gl.beginQuery(this.target, this.handle);
        return;
    }
    // ends the current query
    _end() {
        // Can't end a new query if the last one hasn't been resolved.
        if (this._queryPending) {
            return;
        }
        if (this.target) {
            this.device.gl.endQuery(this.target);
            this.target = null;
            this._queryPending = true;
        }
        return;
    }
    // Returns true if the query result is available
    isResultAvailable() {
        if (!this._queryPending) {
            return false;
        }
        const resultAvailable = this.device.gl.getQueryParameter(this.handle, 34919);
        if (resultAvailable) {
            this._queryPending = false;
        }
        return resultAvailable;
    }
    // Timing query is disjoint, i.e. results are invalid
    isTimerDisjoint() {
        return this.device.gl.getParameter(36795);
    }
    // Returns query result.
    getResult() {
        return this.device.gl.getQueryParameter(this.handle, 34918);
    }
    // Returns the query result, converted to milliseconds to match JavaScript conventions.
    getTimerMilliseconds() {
        return this.getResult() / 1e6;
    }
    // Polls the query
    pollQuery(limit = Number.POSITIVE_INFINITY) {
        if (this._pollingPromise) {
            return this._pollingPromise;
        }
        let counter = 0;
        this._pollingPromise = new Promise((resolve, reject)=>{
            const poll = ()=>{
                if (this.isResultAvailable()) {
                    resolve(this.getResult());
                    this._pollingPromise = null;
                } else if (counter++ > limit) {
                    reject('Timed out');
                    this._pollingPromise = null;
                } else {
                    requestAnimationFrame(poll);
                }
            };
            requestAnimationFrame(poll);
        });
        return this._pollingPromise;
    }
} //# sourceMappingURL=webgl-query-set.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/decode-webgl-types.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "decodeGLAttributeType": (()=>decodeGLAttributeType),
    "decodeGLUniformType": (()=>decodeGLUniformType),
    "decomposeCompositeGLDataType": (()=>decomposeCompositeGLDataType),
    "getCompositeGLDataType": (()=>getCompositeGLDataType),
    "isSamplerUniform": (()=>isSamplerUniform)
});
;
function isSamplerUniform(type) {
    return SAMPLER_TYPES.includes(type);
}
const SAMPLER_TYPES = [
    35678,
    35680,
    35679,
    35682,
    36289,
    36292,
    36293,
    36298,
    36299,
    36300,
    36303,
    36306,
    36307,
    36308,
    36311
];
// Composite types table
const COMPOSITE_GL_TYPES = {
    [5126]: [
        5126,
        1,
        'float',
        'f32',
        'float32'
    ],
    [35664]: [
        5126,
        2,
        'vec2',
        'vec2<f32>',
        'float32x2'
    ],
    [35665]: [
        5126,
        3,
        'vec3',
        'vec3<f32>',
        'float32x3'
    ],
    [35666]: [
        5126,
        4,
        'vec4',
        'vec4<f32>',
        'float32x4'
    ],
    [5124]: [
        5124,
        1,
        'int',
        'i32',
        'sint32'
    ],
    [35667]: [
        5124,
        2,
        'ivec2',
        'vec2<i32>',
        'sint32x2'
    ],
    [35668]: [
        5124,
        3,
        'ivec3',
        'vec3<i32>',
        'sint32x3'
    ],
    [35669]: [
        5124,
        4,
        'ivec4',
        'vec4<i32>',
        'sint32x4'
    ],
    [5125]: [
        5125,
        1,
        'uint',
        'u32',
        'uint32'
    ],
    [36294]: [
        5125,
        2,
        'uvec2',
        'vec2<u32>',
        'uint32x2'
    ],
    [36295]: [
        5125,
        3,
        'uvec3',
        'vec3<u32>',
        'uint32x3'
    ],
    [36296]: [
        5125,
        4,
        'uvec4',
        'vec4<u32>',
        'uint32x4'
    ],
    [35670]: [
        5126,
        1,
        'bool',
        'f32',
        'float32'
    ],
    [35671]: [
        5126,
        2,
        'bvec2',
        'vec2<f32>',
        'float32x2'
    ],
    [35672]: [
        5126,
        3,
        'bvec3',
        'vec3<f32>',
        'float32x3'
    ],
    [35673]: [
        5126,
        4,
        'bvec4',
        'vec4<f32>',
        'float32x4'
    ],
    // TODO - are sizes/components below correct?
    [35674]: [
        5126,
        8,
        'mat2',
        'mat2x2<f32>'
    ],
    [35685]: [
        5126,
        8,
        'mat2x3',
        'mat2x3<f32>'
    ],
    [35686]: [
        5126,
        8,
        'mat2x4',
        'mat2x4<f32>'
    ],
    [35687]: [
        5126,
        12,
        'mat3x2',
        'mat3x2<f32>'
    ],
    [35675]: [
        5126,
        12,
        'mat3',
        'mat3x3<f32>'
    ],
    [35688]: [
        5126,
        12,
        'mat3x4',
        'mat3x4<f32>'
    ],
    [35689]: [
        5126,
        16,
        'mat4x2',
        'mat4x2<f32>'
    ],
    [35690]: [
        5126,
        16,
        'mat4x3',
        'mat4x3<f32>'
    ],
    [35676]: [
        5126,
        16,
        'mat4',
        'mat4x4<f32>'
    ] // 16
};
function decodeGLUniformType(glUniformType) {
    const typeAndSize = COMPOSITE_GL_TYPES[glUniformType];
    if (!typeAndSize) {
        throw new Error('uniform');
    }
    const [glType, components, , format] = typeAndSize;
    return {
        format,
        components,
        glType
    };
}
function decodeGLAttributeType(glAttributeType) {
    const typeAndSize = COMPOSITE_GL_TYPES[glAttributeType];
    if (!typeAndSize) {
        throw new Error('attribute');
    }
    const [, components, , shaderType, vertexFormat] = typeAndSize;
    // TODO sanity - if (shaderType.startsWith('mat' ...))
    const attributeType = shaderType;
    return {
        attributeType,
        vertexFormat,
        components
    }; // , glType};
}
function decomposeCompositeGLDataType(compositeGLDataType) {
    const typeAndSize = COMPOSITE_GL_TYPES[compositeGLDataType];
    if (!typeAndSize) {
        return null;
    }
    const [type, components] = typeAndSize;
    return {
        type,
        components
    };
}
function getCompositeGLDataType(type, components) {
    switch(type){
        case 5120:
        case 5121:
        case 5122:
        case 5123:
            type = 5126;
            break;
        default:
    }
    for(const glType in COMPOSITE_GL_TYPES){
        const [compType, compComponents, name] = COMPOSITE_GL_TYPES[glType];
        if (compType === type && compComponents === components) {
            return {
                glType: Number(glType),
                name
            };
        }
    }
    return null;
} //# sourceMappingURL=decode-webgl-types.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/get-shader-layout.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "getShaderLayoutFromGLSL": (()=>getShaderLayoutFromGLSL)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$decode$2d$webgl$2d$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/decode-webgl-types.js [app-client] (ecmascript)");
;
;
function getShaderLayoutFromGLSL(gl, program) {
    const shaderLayout = {
        attributes: [],
        bindings: []
    };
    shaderLayout.attributes = readAttributeDeclarations(gl, program);
    // Uniform blocks
    const uniformBlocks = readUniformBlocks(gl, program);
    for (const uniformBlock of uniformBlocks){
        const uniforms = uniformBlock.uniforms.map((uniform)=>({
                name: uniform.name,
                format: uniform.format,
                byteOffset: uniform.byteOffset,
                byteStride: uniform.byteStride,
                arrayLength: uniform.arrayLength
            }));
        shaderLayout.bindings.push({
            type: 'uniform',
            name: uniformBlock.name,
            group: 0,
            location: uniformBlock.location,
            visibility: (uniformBlock.vertex ? 0x1 : 0) & (uniformBlock.fragment ? 0x2 : 0),
            minBindingSize: uniformBlock.byteLength,
            uniforms
        });
    }
    const uniforms = readUniformBindings(gl, program);
    let textureUnit = 0;
    for (const uniform of uniforms){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$decode$2d$webgl$2d$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSamplerUniform"])(uniform.type)) {
            const { viewDimension, sampleType } = getSamplerInfo(uniform.type);
            shaderLayout.bindings.push({
                type: 'texture',
                name: uniform.name,
                group: 0,
                location: textureUnit,
                viewDimension,
                sampleType
            });
            // @ts-expect-error
            uniform.textureUnit = textureUnit;
            textureUnit += 1;
        }
    }
    if (uniforms.length) {
        shaderLayout.uniforms = uniforms;
    }
    // Varyings
    const varyings = readVaryings(gl, program);
    // Note - samplers are always in unform bindings, even if uniform blocks are used
    if (varyings?.length) {
        shaderLayout.varyings = varyings;
    }
    return shaderLayout;
}
// HELPERS
/**
 * Extract info about all transform feedback varyings
 *
 * linkProgram needs to have been called, although linking does not need to have been successful
 */ function readAttributeDeclarations(gl, program) {
    const attributes = [];
    const count = gl.getProgramParameter(program, 35721);
    for(let index = 0; index < count; index++){
        const activeInfo = gl.getActiveAttrib(program, index);
        if (!activeInfo) {
            throw new Error('activeInfo');
        }
        const { name, type: compositeType /* , size*/  } = activeInfo;
        const location = gl.getAttribLocation(program, name);
        // Add only user provided attributes, for built-in attributes like `gl_InstanceID` location will be < 0
        if (location >= 0) {
            const { attributeType } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$decode$2d$webgl$2d$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeGLAttributeType"])(compositeType);
            // Whether an attribute is instanced is essentially fixed by the structure of the shader code,
            // so it is arguably a static property of the shader.
            // There is no hint in the shader declarations
            // Heuristic: Any attribute name containing the word "instance" will be assumed to be instanced
            const stepMode = /instance/i.test(name) ? 'instance' : 'vertex';
            attributes.push({
                name,
                location,
                stepMode,
                type: attributeType
            });
        }
    }
    // Sort by declaration order
    attributes.sort((a, b)=>a.location - b.location);
    return attributes;
}
/**
 * Extract info about all transform feedback varyings
 *
 * linkProgram needs to have been called, although linking does not need to have been successful
 */ function readVaryings(gl, program) {
    const varyings = [];
    const count = gl.getProgramParameter(program, 35971);
    for(let location = 0; location < count; location++){
        const activeInfo = gl.getTransformFeedbackVarying(program, location);
        if (!activeInfo) {
            throw new Error('activeInfo');
        }
        const { name, type: compositeType, size } = activeInfo;
        const { glType, components } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$decode$2d$webgl$2d$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeGLUniformType"])(compositeType);
        const varying = {
            location,
            name,
            type: glType,
            size: size * components
        }; // Base values
        varyings.push(varying);
    }
    varyings.sort((a, b)=>a.location - b.location);
    return varyings;
}
/**
 * Extract info about all uniforms
 *
 * Query uniform locations and build name to setter map.
 */ function readUniformBindings(gl, program) {
    const uniforms = [];
    const uniformCount = gl.getProgramParameter(program, 35718);
    for(let i = 0; i < uniformCount; i++){
        const activeInfo = gl.getActiveUniform(program, i);
        if (!activeInfo) {
            throw new Error('activeInfo');
        }
        const { name: rawName, size, type } = activeInfo;
        const { name, isArray } = parseUniformName(rawName);
        let webglLocation = gl.getUniformLocation(program, name);
        const uniformInfo = {
            // WebGL locations are uniquely typed but just numbers
            location: webglLocation,
            name,
            size,
            type,
            isArray
        };
        uniforms.push(uniformInfo);
        // Array (e.g. matrix) uniforms can occupy several 4x4 byte banks
        if (uniformInfo.size > 1) {
            for(let j = 0; j < uniformInfo.size; j++){
                const elementName = `${name}[${j}]`;
                webglLocation = gl.getUniformLocation(program, elementName);
                const arrayElementUniformInfo = {
                    ...uniformInfo,
                    name: elementName,
                    location: webglLocation
                };
                uniforms.push(arrayElementUniformInfo);
            }
        }
    }
    return uniforms;
}
/**
 * Extract info about all "active" uniform blocks
 * @note In WebGL, "active" just means that unused (inactive) blocks may have been optimized away during linking)
 */ function readUniformBlocks(gl, program) {
    const getBlockParameter = (blockIndex, pname)=>gl.getActiveUniformBlockParameter(program, blockIndex, pname);
    const uniformBlocks = [];
    const blockCount = gl.getProgramParameter(program, 35382);
    for(let blockIndex = 0; blockIndex < blockCount; blockIndex++){
        const blockInfo = {
            name: gl.getActiveUniformBlockName(program, blockIndex) || '',
            location: getBlockParameter(blockIndex, 35391),
            byteLength: getBlockParameter(blockIndex, 35392),
            vertex: getBlockParameter(blockIndex, 35396),
            fragment: getBlockParameter(blockIndex, 35398),
            uniformCount: getBlockParameter(blockIndex, 35394),
            uniforms: []
        };
        const uniformIndices = getBlockParameter(blockIndex, 35395) || [];
        const uniformType = gl.getActiveUniforms(program, uniformIndices, 35383); // Array of GLenum indicating the types of the uniforms.
        const uniformArrayLength = gl.getActiveUniforms(program, uniformIndices, 35384); // Array of GLuint indicating the sizes of the uniforms.
        // const uniformBlockIndex = gl.getActiveUniforms(
        //   program,
        //   uniformIndices,
        //   GL.UNIFORM_BLOCK_INDEX
        // ); // Array of GLint indicating the block indices of the uniforms.
        const uniformOffset = gl.getActiveUniforms(program, uniformIndices, 35387); // Array of GLint indicating the uniform buffer offsets.
        const uniformStride = gl.getActiveUniforms(program, uniformIndices, 35388); // Array of GLint indicating the strides between the elements.
        // const uniformMatrixStride = gl.getActiveUniforms(
        //   program,
        //   uniformIndices,
        //   GL.UNIFORM_MATRIX_STRIDE
        // ); // Array of GLint indicating the strides between columns of a column-major matrix or a row-major matrix.
        // const uniformRowMajor = gl.getActiveUniforms(program, uniformIndices, GL.UNIFORM_IS_ROW_MAJOR);
        for(let i = 0; i < blockInfo.uniformCount; ++i){
            const activeInfo = gl.getActiveUniform(program, uniformIndices[i]);
            if (!activeInfo) {
                throw new Error('activeInfo');
            }
            blockInfo.uniforms.push({
                name: activeInfo.name,
                format: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$decode$2d$webgl$2d$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeGLUniformType"])(uniformType[i]).format,
                type: uniformType[i],
                arrayLength: uniformArrayLength[i],
                byteOffset: uniformOffset[i],
                byteStride: uniformStride[i]
            });
        }
        uniformBlocks.push(blockInfo);
    }
    uniformBlocks.sort((a, b)=>a.location - b.location);
    return uniformBlocks;
}
/**
 * TOOD - compare with a above, confirm copy, then delete
  const bindings: Binding[] = [];
  const count = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
  for (let blockIndex = 0; blockIndex < count; blockIndex++) {
    const vertex = gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),
    const fragment = gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),
    const visibility = (vertex) + (fragment);
    const binding: BufferBinding = {
      location: gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_BINDING),
      // name: gl.getActiveUniformBlockName(program, blockIndex),
      type: 'uniform',
      visibility,
      minBindingSize: gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_DATA_SIZE),
      // uniformCount: gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_ACTIVE_UNIFORMS),
      // uniformIndices: gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),
    }
    bindings.push(binding);
  }
*/ const SAMPLER_UNIFORMS_GL_TO_GPU = {
    [35678]: [
        '2d',
        'float'
    ],
    [35680]: [
        'cube',
        'float'
    ],
    [35679]: [
        '3d',
        'float'
    ],
    [35682]: [
        '3d',
        'depth'
    ],
    [36289]: [
        '2d-array',
        'float'
    ],
    [36292]: [
        '2d-array',
        'depth'
    ],
    [36293]: [
        'cube',
        'float'
    ],
    [36298]: [
        '2d',
        'sint'
    ],
    [36299]: [
        '3d',
        'sint'
    ],
    [36300]: [
        'cube',
        'sint'
    ],
    [36303]: [
        '2d-array',
        'uint'
    ],
    [36306]: [
        '2d',
        'uint'
    ],
    [36307]: [
        '3d',
        'uint'
    ],
    [36308]: [
        'cube',
        'uint'
    ],
    [36311]: [
        '2d-array',
        'uint'
    ]
};
function getSamplerInfo(type) {
    const sampler = SAMPLER_UNIFORMS_GL_TO_GPU[type];
    if (!sampler) {
        throw new Error('sampler');
    }
    const [viewDimension, sampleType] = sampler;
    return {
        viewDimension,
        sampleType
    };
}
// HELPERS
function parseUniformName(name) {
    // Shortcut to avoid redundant or bad matches
    if (name[name.length - 1] !== ']') {
        return {
            name,
            length: 1,
            isArray: false
        };
    }
    // if array name then clean the array brackets
    const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
    const matches = UNIFORM_NAME_REGEXP.exec(name);
    if (!matches || matches.length < 2) {
        throw new Error(`Failed to parse GLSL uniform name ${name}`);
    }
    return {
        name: matches[1],
        length: matches[2] ? 1 : 0,
        isArray: Boolean(matches[2])
    };
} //# sourceMappingURL=get-shader-layout.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/utils/split-uniforms-and-bindings.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "isUniformValue": (()=>isUniformValue),
    "splitUniformsAndBindings": (()=>splitUniformsAndBindings)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$types$2f$dist$2f$is$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@math.gl/types/dist/is-array.js [app-client] (ecmascript)");
;
function isUniformValue(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$types$2f$dist$2f$is$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumericArray"])(value) !== null || typeof value === 'number' || typeof value === 'boolean';
}
function splitUniformsAndBindings(uniforms) {
    const result = {
        bindings: {},
        uniforms: {}
    };
    Object.keys(uniforms).forEach((name)=>{
        const uniform = uniforms[name];
        if (isUniformValue(uniform)) {
            result.uniforms[name] = uniform;
        } else {
            result.bindings[name] = uniform;
        }
    });
    return result;
} //# sourceMappingURL=split-uniforms-and-bindings.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/set-uniform.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "setUniform": (()=>setUniform)
});
;
function setUniform(gl, location, type, value) {
    const gl2 = gl;
    // Prepare the value for WebGL setters
    let uniformValue = value;
    if (uniformValue === true) {
        uniformValue = 1;
    }
    if (uniformValue === false) {
        uniformValue = 0;
    }
    const arrayValue = typeof uniformValue === 'number' ? [
        uniformValue
    ] : uniformValue;
    // prettier-ignore
    switch(type){
        case 35678:
        case 35680:
        case 35679:
        case 35682:
        case 36289:
        case 36292:
        case 36293:
        case 36298:
        case 36299:
        case 36300:
        case 36303:
        case 36306:
        case 36307:
        case 36308:
        case 36311:
            if (typeof value !== 'number') {
                throw new Error('samplers must be set to integers');
            }
            return gl.uniform1i(location, value);
        case 5126:
            return gl.uniform1fv(location, arrayValue);
        case 35664:
            return gl.uniform2fv(location, arrayValue);
        case 35665:
            return gl.uniform3fv(location, arrayValue);
        case 35666:
            return gl.uniform4fv(location, arrayValue);
        case 5124:
            return gl.uniform1iv(location, arrayValue);
        case 35667:
            return gl.uniform2iv(location, arrayValue);
        case 35668:
            return gl.uniform3iv(location, arrayValue);
        case 35669:
            return gl.uniform4iv(location, arrayValue);
        case 35670:
            return gl.uniform1iv(location, arrayValue);
        case 35671:
            return gl.uniform2iv(location, arrayValue);
        case 35672:
            return gl.uniform3iv(location, arrayValue);
        case 35673:
            return gl.uniform4iv(location, arrayValue);
        // WEBGL2 - unsigned integers
        case 5125:
            return gl2.uniform1uiv(location, arrayValue, 1);
        case 36294:
            return gl2.uniform2uiv(location, arrayValue, 2);
        case 36295:
            return gl2.uniform3uiv(location, arrayValue, 3);
        case 36296:
            return gl2.uniform4uiv(location, arrayValue, 4);
        // WebGL2 - quadratic matrices
        // false: don't transpose the matrix
        case 35674:
            return gl.uniformMatrix2fv(location, false, arrayValue);
        case 35675:
            return gl.uniformMatrix3fv(location, false, arrayValue);
        case 35676:
            return gl.uniformMatrix4fv(location, false, arrayValue);
        // WebGL2 - rectangular matrices
        case 35685:
            return gl2.uniformMatrix2x3fv(location, false, arrayValue);
        case 35686:
            return gl2.uniformMatrix2x4fv(location, false, arrayValue);
        case 35687:
            return gl2.uniformMatrix3x2fv(location, false, arrayValue);
        case 35688:
            return gl2.uniformMatrix3x4fv(location, false, arrayValue);
        case 35689:
            return gl2.uniformMatrix4x2fv(location, false, arrayValue);
        case 35690:
            return gl2.uniformMatrix4x3fv(location, false, arrayValue);
    }
    throw new Error('Illegal uniform');
} //# sourceMappingURL=set-uniform.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-render-pipeline.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "WEBGLRenderPipeline": (()=>WEBGLRenderPipeline)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$get$2d$shader$2d$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/get-shader-layout.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2d$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture-view.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-framebuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$webgl$2d$topology$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/webgl-topology-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$device$2d$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/converters/device-parameters.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$utils$2f$split$2d$uniforms$2d$and$2d$bindings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/utils/split-uniforms-and-bindings.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$set$2d$uniform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/set-uniform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/render-pipeline.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
const LOG_PROGRAM_PERF_PRIORITY = 4;
class WEBGLRenderPipeline extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RenderPipeline"] {
    /** The WebGL device that created this render pipeline */ device;
    /** Handle to underlying WebGL program */ handle;
    /** vertex shader */ vs;
    /** fragment shader */ fs;
    /** The layout extracted from shader by WebGL introspection APIs */ introspectedLayout;
    /** Uniforms set on this model */ uniforms = {};
    /** Bindings set on this model */ bindings = {};
    /** WebGL varyings */ varyings = null;
    _uniformCount = 0;
    _uniformSetters = {};
    constructor(device, props){
        super(device, props);
        this.device = device;
        this.handle = this.props.handle || this.device.gl.createProgram();
        this.device.setSpectorMetadata(this.handle, {
            id: this.props.id
        });
        // Create shaders if needed
        this.vs = props.vs;
        this.fs = props.fs;
        // assert(this.vs.stage === 'vertex');
        // assert(this.fs.stage === 'fragment');
        // Setup varyings if supplied
        // @ts-expect-error WebGL only
        const { varyings, bufferMode = 35981 } = props;
        if (varyings && varyings.length > 0) {
            this.varyings = varyings;
            this.device.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);
        }
        this._linkShaders();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();
        this.introspectedLayout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$get$2d$shader$2d$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getShaderLayoutFromGLSL"])(this.device.gl, this.handle);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();
        // Merge provided layout with introspected layout
        this.shaderLayout = mergeShaderLayout(this.introspectedLayout, props.shaderLayout);
    }
    destroy() {
        if (this.handle) {
            this.device.gl.deleteProgram(this.handle);
            // this.handle = null;
            this.destroyed = true;
        }
    }
    /**
     * Bindings include: textures, samplers and uniform buffers
     * @todo needed for portable model
     */ setBindings(bindings, options) {
        // if (log.priority >= 2) {
        //   checkUniformValues(uniforms, this.id, this._uniformSetters);
        // }
        for (const [name, value] of Object.entries(bindings)){
            // Accept both `xyz` and `xyzUniforms` as valid names for `xyzUniforms` uniform block
            // This convention allows shaders to name uniform blocks as `uniform appUniforms {} app;`
            // and reference them as `app` from both GLSL and JS.
            // TODO - this is rather hacky - we could also remap the name directly in the shader layout.
            const binding = this.shaderLayout.bindings.find((binding_)=>binding_.name === name) || this.shaderLayout.bindings.find((binding_)=>binding_.name === `${name}Uniforms`);
            if (!binding) {
                const validBindings = this.shaderLayout.bindings.map((binding_)=>`"${binding_.name}"`).join(', ');
                if (!options?.disableWarnings) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`No binding "${name}" in render pipeline "${this.id}", expected one of ${validBindings}`, value)();
                }
                continue; // eslint-disable-line no-continue
            }
            if (!value) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`Unsetting binding "${name}" in render pipeline "${this.id}"`)();
            }
            switch(binding.type){
                case 'uniform':
                    // @ts-expect-error
                    if (!(value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLBuffer"]) && !(value.buffer instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLBuffer"])) {
                        throw new Error('buffer value');
                    }
                    break;
                case 'texture':
                    if (!(value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2d$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLTextureView"] || value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLTexture"] || value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLFramebuffer"])) {
                        throw new Error('texture value');
                    }
                    break;
                case 'sampler':
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`Ignoring sampler ${name}`)();
                    break;
                default:
                    throw new Error(binding.type);
            }
            this.bindings[name] = value;
        }
    }
    /** @todo needed for portable model
     * @note The WebGL API is offers many ways to draw things
     * This function unifies those ways into a single call using common parameters with sane defaults
     */ draw(options) {
        const { renderPass, parameters = this.props.parameters, topology = this.props.topology, vertexArray, vertexCount, // indexCount,
        instanceCount, isInstanced = false, firstVertex = 0, // firstIndex,
        // firstInstance,
        // baseVertex,
        transformFeedback } = options;
        const glDrawMode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$webgl$2d$topology$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGLDrawMode"])(topology);
        const isIndexed = Boolean(vertexArray.indexBuffer);
        const glIndexType = vertexArray.indexBuffer?.glIndexType;
        // Note that we sometimes get called with 0 instances
        // If we are using async linking, we need to wait until linking completes
        if (this.linkStatus !== 'success') {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)();
            return false;
        }
        // Avoid WebGL draw call when not rendering any data or values are incomplete
        // Note: async textures set as uniforms might still be loading.
        // Now that all uniforms have been updated, check if any texture
        // in the uniforms is not yet initialized, then we don't draw
        if (!this._areTexturesRenderable()) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)();
            //  Note: false means that the app needs to redraw the pipeline again.
            return false;
        }
        // (isInstanced && instanceCount === 0)
        // if (vertexCount === 0) {
        //   log.info(2, `RenderPipeline:${this.id}.draw() aborted - no vertices to draw`)();
        //   Note: false means that the app needs to redraw the pipeline again.
        //   return true;
        // }
        this.device.gl.useProgram(this.handle);
        // Note: Rebinds constant attributes before each draw call
        vertexArray.bindBeforeRender(renderPass);
        if (transformFeedback) {
            transformFeedback.begin(this.props.topology);
        }
        // We have to apply bindings before every draw call since other draw calls will overwrite
        this._applyBindings();
        this._applyUniforms();
        const webglRenderPass = renderPass;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$device$2d$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withDeviceAndGLParameters"])(this.device, parameters, webglRenderPass.glParameters, ()=>{
            if (isIndexed && isInstanced) {
                this.device.gl.drawElementsInstanced(glDrawMode, vertexCount || 0, glIndexType, firstVertex, instanceCount || 0);
            // } else if (isIndexed && this.device.isWebGL2 && !isNaN(start) && !isNaN(end)) {
            //   this.device.gldrawRangeElements(glDrawMode, start, end, vertexCount, glIndexType, offset);
            } else if (isIndexed) {
                this.device.gl.drawElements(glDrawMode, vertexCount || 0, glIndexType, firstVertex); // indexCount?
            } else if (isInstanced) {
                this.device.gl.drawArraysInstanced(glDrawMode, firstVertex, vertexCount || 0, instanceCount || 0);
            } else {
                this.device.gl.drawArrays(glDrawMode, firstVertex, vertexCount || 0);
            }
            if (transformFeedback) {
                transformFeedback.end();
            }
        });
        vertexArray.unbindAfterRender(renderPass);
        return true;
    }
    // DEPRECATED METHODS
    setUniformsWebGL(uniforms) {
        const { bindings } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$utils$2f$split$2d$uniforms$2d$and$2d$bindings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["splitUniformsAndBindings"])(uniforms);
        Object.keys(bindings).forEach((name)=>{
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`Unsupported value "${JSON.stringify(bindings[name])}" used in setUniforms() for key ${name}. Use setBindings() instead?`)();
        });
        // TODO - check against layout
        Object.assign(this.uniforms, uniforms);
    }
    // PRIVATE METHODS
    // setAttributes(attributes: Record<string, Buffer>): void {}
    // setBindings(bindings: Record<string, Binding>): void {}
    async _linkShaders() {
        const { gl } = this.device;
        gl.attachShader(this.handle, this.vs.handle);
        gl.attachShader(this.handle, this.fs.handle);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
        gl.linkProgram(this.handle);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
        // TODO Avoid checking program linking error in production
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].level === 0) {
        // return;
        }
        if (!this.device.features.has('compilation-status-async-webgl')) {
            const status = this._getLinkStatus();
            this._reportLinkStatus(status);
            return;
        }
        // async case
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].once(1, 'RenderPipeline linking is asynchronous')();
        await this._waitForLinkComplete();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
        const status = this._getLinkStatus();
        this._reportLinkStatus(status);
    }
    /** Report link status. First, check for shader compilation failures if linking fails */ async _reportLinkStatus(status) {
        switch(status){
            case 'success':
                return;
            default:
                // First check for shader compilation failures if linking fails
                switch(this.vs.compilationStatus){
                    case 'error':
                        this.vs.debugShader();
                        throw new Error(`Error during compilation of shader ${this.vs.id}`);
                    case 'pending':
                        this.vs.asyncCompilationStatus.then(()=>this.vs.debugShader());
                        break;
                    case 'success':
                        break;
                }
                switch(this.fs?.compilationStatus){
                    case 'error':
                        this.fs.debugShader();
                        throw new Error(`Error during compilation of shader ${this.fs.id}`);
                    case 'pending':
                        this.fs.asyncCompilationStatus.then(()=>this.fs.debugShader());
                        break;
                    case 'success':
                        break;
                }
                const linkErrorLog = this.device.gl.getProgramInfoLog(this.handle);
                throw new Error(`Error during ${status}: ${linkErrorLog}`);
        }
    }
    /**
     * Get the shader compilation status
     * TODO - Load log even when no error reported, to catch warnings?
     * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
     */ _getLinkStatus() {
        const { gl } = this.device;
        const linked = gl.getProgramParameter(this.handle, 35714);
        if (!linked) {
            this.linkStatus = 'error';
            return 'linking';
        }
        gl.validateProgram(this.handle);
        const validated = gl.getProgramParameter(this.handle, 35715);
        if (!validated) {
            this.linkStatus = 'error';
            return 'validation';
        }
        this.linkStatus = 'success';
        return 'success';
    }
    /** Use KHR_parallel_shader_compile extension if available */ async _waitForLinkComplete() {
        const waitMs = async (ms)=>await new Promise((resolve)=>setTimeout(resolve, ms));
        const DELAY_MS = 10; // Shader compilation is typically quite fast (with some exceptions)
        // If status polling is not available, we can't wait for completion. Just wait a little to minimize blocking
        if (!this.device.features.has('compilation-status-async-webgl')) {
            await waitMs(DELAY_MS);
            return;
        }
        const { gl } = this.device;
        for(;;){
            const complete = gl.getProgramParameter(this.handle, 37297);
            if (complete) {
                return;
            }
            await waitMs(DELAY_MS);
        }
    }
    /**
     * Checks if all texture-values uniforms are renderable (i.e. loaded)
     * Update a texture if needed (e.g. from video)
     * Note: This is currently done before every draw call
     */ _areTexturesRenderable() {
        let texturesRenderable = true;
        for (const bindingInfo of this.shaderLayout.bindings){
            if (!this.bindings[bindingInfo.name] && !this.bindings[bindingInfo.name.replace(/Uniforms$/, '')]) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`Binding ${bindingInfo.name} not found in ${this.id}`)();
                texturesRenderable = false;
            }
        }
        // TODO - remove this should be handled by ExternalTexture
        // for (const [, texture] of Object.entries(this.bindings)) {
        //   if (texture instanceof WEBGLTexture) {
        //     texture.update();
        //   }
        // }
        return texturesRenderable;
    }
    /** Apply any bindings (before each draw call) */ _applyBindings() {
        // If we are using async linking, we need to wait until linking completes
        if (this.linkStatus !== 'success') {
            return;
        }
        const { gl } = this.device;
        gl.useProgram(this.handle);
        let textureUnit = 0;
        let uniformBufferIndex = 0;
        for (const binding of this.shaderLayout.bindings){
            // Accept both `xyz` and `xyzUniforms` as valid names for `xyzUniforms` uniform block
            const value = this.bindings[binding.name] || this.bindings[binding.name.replace(/Uniforms$/, '')];
            if (!value) {
                throw new Error(`No value for binding ${binding.name} in ${this.id}`);
            }
            switch(binding.type){
                case 'uniform':
                    // Set buffer
                    const { name } = binding;
                    const location = gl.getUniformBlockIndex(this.handle, name);
                    if (location === 4294967295) {
                        throw new Error(`Invalid uniform block name ${name}`);
                    }
                    gl.uniformBlockBinding(this.handle, uniformBufferIndex, location);
                    // console.debug(binding, location);
                    if (value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLBuffer"]) {
                        gl.bindBufferBase(35345, uniformBufferIndex, value.handle);
                    } else {
                        gl.bindBufferRange(35345, uniformBufferIndex, // @ts-expect-error
                        value.buffer.handle, // @ts-expect-error
                        value.offset || 0, // @ts-expect-error
                        value.size || value.buffer.byteLength - value.offset);
                    }
                    uniformBufferIndex += 1;
                    break;
                case 'texture':
                    if (!(value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2d$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLTextureView"] || value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLTexture"] || value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLFramebuffer"])) {
                        throw new Error('texture');
                    }
                    let texture;
                    if (value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2d$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLTextureView"]) {
                        texture = value.texture;
                    } else if (value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLTexture"]) {
                        texture = value;
                    } else if (value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLFramebuffer"] && value.colorAttachments[0] instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2d$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLTextureView"]) {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn('Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead')();
                        texture = value.colorAttachments[0].texture;
                    } else {
                        throw new Error('No texture');
                    }
                    gl.activeTexture(33984 + textureUnit);
                    gl.bindTexture(texture.glTarget, texture.handle);
                    // gl.bindSampler(textureUnit, sampler.handle);
                    textureUnit += 1;
                    break;
                case 'sampler':
                    break;
                case 'storage':
                case 'read-only-storage':
                    throw new Error(`binding type '${binding.type}' not supported in WebGL`);
            }
        }
    }
    /**
     * Due to program sharing, uniforms need to be reset before every draw call
     * (though caching will avoid redundant WebGL calls)
     */ _applyUniforms() {
        for (const uniformLayout of this.shaderLayout.uniforms || []){
            const { name, location, type, textureUnit } = uniformLayout;
            const value = this.uniforms[name] ?? textureUnit;
            if (value !== undefined) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$set$2d$uniform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setUniform"])(this.device.gl, location, type, value);
            }
        }
    }
}
/**
 * Merges an provided shader layout into a base shader layout
 * In WebGL, this allows the auto generated shader layout to be overridden by the application
 * Typically to change the format of the vertex attributes (from float32x4 to uint8x4 etc).
 * @todo Drop this? Aren't all use cases covered by mergeBufferLayout()?
 */ function mergeShaderLayout(baseLayout, overrideLayout) {
    // Deep clone the base layout
    const mergedLayout = {
        ...baseLayout,
        attributes: baseLayout.attributes.map((attribute)=>({
                ...attribute
            }))
    };
    // Merge the attributes
    for (const attribute of overrideLayout?.attributes || []){
        const baseAttribute = mergedLayout.attributes.find((attr)=>attr.name === attribute.name);
        if (!baseAttribute) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn(`shader layout attribute ${attribute.name} not present in shader`);
        } else {
            baseAttribute.type = attribute.type || baseAttribute.type;
            baseAttribute.stepMode = attribute.stepMode || baseAttribute.stepMode;
        }
    }
    return mergedLayout;
} //# sourceMappingURL=webgl-render-pipeline.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-render-pass.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "WEBGLRenderPass": (()=>WEBGLRenderPass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$unified$2d$parameter$2d$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/parameters/unified-parameter-api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$state$2d$tracker$2f$with$2d$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/state-tracker/with-parameters.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/render-pass.js [app-client] (ecmascript)");
;
;
;
;
const COLOR_CHANNELS = [
    0x1,
    0x2,
    0x4,
    0x8
]; // GPUColorWrite RED, GREEN, BLUE, ALPHA
class WEBGLRenderPass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RenderPass"] {
    device;
    /** Parameters that should be applied before each draw call */ glParameters;
    constructor(device, props){
        super(device, props);
        this.device = device;
        // If no viewport is provided, apply reasonably defaults
        let viewport;
        if (!props?.parameters?.viewport) {
            if (props?.framebuffer) {
                // Set the viewport to the size of the framebuffer
                const { width, height } = props.framebuffer;
                viewport = [
                    0,
                    0,
                    width,
                    height
                ];
            } else {
                // Instead of using our own book-keeping, we can just read the values from the WebGL context
                const [width, height] = device.getCanvasContext().getDrawingBufferSize();
                viewport = [
                    0,
                    0,
                    width,
                    height
                ];
            }
        }
        // TODO - do parameters (scissorRect) affect the clear operation?
        this.device.pushState();
        this.setParameters({
            viewport,
            ...this.props.parameters
        });
        // Specify mapping of draw buffer locations to color attachments
        if (this.props.framebuffer) {
            const drawBuffers = this.props.framebuffer.colorAttachments.map((_, i)=>36064 + i);
            this.device.gl.drawBuffers(drawBuffers);
        } else {
            this.device.gl.drawBuffers([
                1029
            ]);
        }
        // Hack - for now WebGL draws in "immediate mode" (instead of queueing the operations)...
        this.clear();
    }
    end() {
        this.device.popState();
    // should add commands to CommandEncoder.
    }
    pushDebugGroup(groupLabel) {}
    popDebugGroup() {}
    insertDebugMarker(markerLabel) {}
    // beginOcclusionQuery(queryIndex: number): void;
    // endOcclusionQuery(): void;
    // executeBundles(bundles: Iterable<GPURenderBundle>): void;
    /**
     * Maps RenderPass parameters to GL parameters
     */ setParameters(parameters = {}) {
        const glParameters = {
            ...this.glParameters
        };
        // Framebuffers are specified using parameters in WebGL
        glParameters.framebuffer = this.props.framebuffer || null;
        if (this.props.depthReadOnly) {
            glParameters.depthMask = !this.props.depthReadOnly;
        }
        glParameters.stencilMask = this.props.stencilReadOnly ? 0 : 1;
        glParameters[35977] = this.props.discard;
        // Map the four renderpass parameters to WebGL parameters
        if (parameters.viewport) {
            // WebGPU viewports are 6 coordinates (X, Y, Z)
            if (parameters.viewport.length >= 6) {
                glParameters.viewport = parameters.viewport.slice(0, 4);
                glParameters.depthRange = [
                    parameters.viewport[4],
                    parameters.viewport[5]
                ];
            } else {
                // WebGL viewports are 4 coordinates (X, Y)
                glParameters.viewport = parameters.viewport;
            }
        }
        if (parameters.scissorRect) {
            glParameters.scissorTest = true;
            glParameters.scissor = parameters.scissorRect;
        }
        if (parameters.blendConstant) {
            glParameters.blendColor = parameters.blendConstant;
        }
        if (parameters.stencilReference) {
            // eslint-disable-next-line no-console
            console.warn('RenderPassParameters.stencilReference not yet implemented in WebGL');
            // parameters.stencilFunc = [func, ref, mask];
            // Does this work?
            parameters[2967] = parameters.stencilReference;
        }
        if (parameters.colorMask) {
            glParameters.colorMask = COLOR_CHANNELS.map((channel)=>Boolean(channel & parameters.colorMask));
        }
        this.glParameters = glParameters;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$unified$2d$parameter$2d$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setGLParameters"])(this.device.gl, glParameters);
    }
    beginOcclusionQuery(queryIndex) {
        const webglQuerySet = this.props.occlusionQuerySet;
        webglQuerySet?.beginOcclusionQuery();
    }
    endOcclusionQuery() {
        const webglQuerySet = this.props.occlusionQuerySet;
        webglQuerySet?.endOcclusionQuery();
    }
    // PRIVATE
    /**
     * Optionally clears depth, color and stencil buffers based on parameters
     */ clear() {
        const glParameters = {
            ...this.glParameters
        };
        let clearMask = 0;
        if (this.props.clearColors) {
            this.props.clearColors.forEach((color, drawBufferIndex)=>{
                if (color) {
                    this.clearColorBuffer(drawBufferIndex, color);
                }
            });
        }
        if (this.props.clearColor !== false && this.props.clearColors === undefined) {
            clearMask |= 16384;
            glParameters.clearColor = this.props.clearColor;
        }
        if (this.props.clearDepth !== false) {
            clearMask |= 256;
            glParameters.clearDepth = this.props.clearDepth;
        }
        if (this.props.clearStencil !== false) {
            clearMask |= 1024;
            glParameters.clearStencil = this.props.clearStencil;
        }
        if (clearMask !== 0) {
            // Temporarily set any clear "colors" and call clear
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$state$2d$tracker$2f$with$2d$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withGLParameters"])(this.device.gl, glParameters, ()=>{
                this.device.gl.clear(clearMask);
            });
        }
    }
    /**
     * WebGL2 - clear a specific color buffer
     */ clearColorBuffer(drawBuffer = 0, value = [
        0,
        0,
        0,
        0
    ]) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$state$2d$tracker$2f$with$2d$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withGLParameters"])(this.device.gl, {
            framebuffer: this.props.framebuffer
        }, ()=>{
            // Method selection per OpenGL ES 3 docs
            switch(value.constructor){
                case Int8Array:
                case Int16Array:
                case Int32Array:
                    this.device.gl.clearBufferiv(6144, drawBuffer, value);
                    break;
                case Uint8Array:
                case Uint8ClampedArray:
                case Uint16Array:
                case Uint32Array:
                    this.device.gl.clearBufferuiv(6144, drawBuffer, value);
                    break;
                case Float32Array:
                    this.device.gl.clearBufferfv(6144, drawBuffer, value);
                    break;
                default:
                    throw new Error('clearColorBuffer: color must be typed array');
            }
        });
    }
} //# sourceMappingURL=webgl-render-pass.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-command-buffer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "WEBGLCommandBuffer": (()=>WEBGLCommandBuffer),
    "getWebGLCubeFaceTarget": (()=>getWebGLCubeFaceTarget),
    "glFormatToComponents": (()=>glFormatToComponents),
    "glTypeToBytes": (()=>glTypeToBytes)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$command$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/command-buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$webgl$2d$texture$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/converters/webgl-texture-table.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/texture.js [app-client] (ecmascript)");
;
;
;
;
class WEBGLCommandBuffer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$command$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CommandBuffer"] {
    device;
    commands = [];
    constructor(device){
        super(device, {});
        this.device = device;
    }
    submitCommands(commands = this.commands) {
        for (const command of commands){
            switch(command.name){
                case 'copy-buffer-to-buffer':
                    _copyBufferToBuffer(this.device, command.options);
                    break;
                case 'copy-buffer-to-texture':
                    _copyBufferToTexture(this.device, command.options);
                    break;
                case 'copy-texture-to-buffer':
                    _copyTextureToBuffer(this.device, command.options);
                    break;
                case 'copy-texture-to-texture':
                    _copyTextureToTexture(this.device, command.options);
                    break;
                // case 'clear-texture':
                //   _clearTexture(this.device, command.options);
                //   break;
                default:
                    throw new Error(command.name);
            }
        }
    }
}
function _copyBufferToBuffer(device, options) {
    const source = options.sourceBuffer;
    const destination = options.destinationBuffer;
    // {In WebGL2 we can p}erform the copy on the GPU
    // Use GL.COPY_READ_BUFFER+GL.COPY_WRITE_BUFFER avoid disturbing other targets and locking type
    device.gl.bindBuffer(36662, source.handle);
    device.gl.bindBuffer(36663, destination.handle);
    device.gl.copyBufferSubData(36662, 36663, options.sourceOffset ?? 0, options.destinationOffset ?? 0, options.size);
    device.gl.bindBuffer(36662, null);
    device.gl.bindBuffer(36663, null);
}
/**
 * Copies data from a Buffer object into a Texture object
 * NOTE: doesn't wait for copy to be complete
 */ function _copyBufferToTexture(device, options) {
    throw new Error('Not implemented');
}
/**
 * Copies data from a Texture object into a Buffer object.
 * NOTE: doesn't wait for copy to be complete
 */ function _copyTextureToBuffer(device, options) {
    const { /** Texture to copy to/from. */ sourceTexture, /**  Mip-map level of the texture to copy to/from. (Default 0) */ mipLevel = 0, /** Defines which aspects of the texture to copy to/from. */ aspect = 'all', /** Width to copy */ width = options.sourceTexture.width, /** Height to copy */ height = options.sourceTexture.height, depthOrArrayLayers = 0, /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */ origin = [
        0,
        0
    ], /** Destination buffer */ destinationBuffer, /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */ byteOffset = 0, /**
     * The stride, in bytes, between the beginning of each block row and the subsequent block row.
     * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).
     */ bytesPerRow, /**
     * Number of block rows per single image of the texture.
     * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.
     * Required if there are multiple images (i.e. the copy depth is more than one).
     */ rowsPerImage } = options;
    // TODO - Not possible to read just stencil or depth part in WebGL?
    if (aspect !== 'all') {
        throw new Error('aspect not supported in WebGL');
    }
    // TODO - mipLevels are set when attaching texture to framebuffer
    if (mipLevel !== 0 || depthOrArrayLayers !== 0 || bytesPerRow || rowsPerImage) {
        throw new Error('not implemented');
    }
    // Asynchronous read (PIXEL_PACK_BUFFER) is WebGL2 only feature
    const { framebuffer, destroyFramebuffer } = getFramebuffer(sourceTexture);
    let prevHandle;
    try {
        const webglBuffer = destinationBuffer;
        const sourceWidth = width || framebuffer.width;
        const sourceHeight = height || framebuffer.height;
        const sourceParams = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$webgl$2d$texture$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTextureFormatWebGL"])(framebuffer.colorAttachments[0].texture.props.format);
        const sourceFormat = sourceParams.format;
        const sourceType = sourceParams.type;
        // if (!target) {
        //   // Create new buffer with enough size
        //   const components = glFormatToComponents(sourceFormat);
        //   const byteCount = glTypeToBytes(sourceType);
        //   const byteLength = byteOffset + sourceWidth * sourceHeight * components * byteCount;
        //   target = device.createBuffer({byteLength});
        // }
        device.gl.bindBuffer(35051, webglBuffer.handle);
        // @ts-expect-error native bindFramebuffer is overridden by our state tracker
        prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);
        device.gl.readPixels(origin[0], origin[1], sourceWidth, sourceHeight, sourceFormat, sourceType, byteOffset);
    } finally{
        device.gl.bindBuffer(35051, null);
        // prevHandle may be unassigned if the try block failed before binding
        if (prevHandle !== undefined) {
            device.gl.bindFramebuffer(36160, prevHandle);
        }
        if (destroyFramebuffer) {
            framebuffer.destroy();
        }
    }
}
/**
 * Copies data from a Framebuffer or a Texture object into a Buffer object.
 * NOTE: doesn't wait for copy to be complete, it programs GPU to perform a DMA transfer.
export function readPixelsToBuffer(
  source: Framebuffer | Texture,
  options?: {
    sourceX?: number;
    sourceY?: number;
    sourceFormat?: number;
    target?: Buffer; // A new Buffer object is created when not provided.
    targetByteOffset?: number; // byte offset in buffer object
    // following parameters are auto deduced if not provided
    sourceWidth?: number;
    sourceHeight?: number;
    sourceType?: number;
  }
): Buffer
 */ /**
 * Copy a rectangle from a Framebuffer or Texture object into a texture (at an offset)
 */ // eslint-disable-next-line complexity, max-statements
function _copyTextureToTexture(device, options) {
    const { /** Texture to copy to/from. */ sourceTexture, /**  Mip-map level of the texture to copy to (Default 0) */ destinationMipLevel = 0, /** Defines which aspects of the texture to copy to/from. */ // aspect = 'all',
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */ origin = [
        0,
        0
    ], /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */ destinationOrigin = [
        0,
        0
    ], /** Texture to copy to/from. */ destinationTexture } = options;
    let { width = options.destinationTexture.width, height = options.destinationTexture.height } = options;
    const { framebuffer, destroyFramebuffer } = getFramebuffer(sourceTexture);
    const [sourceX, sourceY] = origin;
    const [destinationX, destinationY, destinationZ] = destinationOrigin;
    // @ts-expect-error native bindFramebuffer is overridden by our state tracker
    const prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);
    // TODO - support gl.readBuffer (WebGL2 only)
    // const prevBuffer = gl.readBuffer(attachment);
    let texture = null;
    let textureTarget;
    if (destinationTexture instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLTexture"]) {
        texture = destinationTexture;
        width = Number.isFinite(width) ? width : texture.width;
        height = Number.isFinite(height) ? height : texture.height;
        texture.bind(0);
        textureTarget = texture.glTarget;
    } else {
        throw new Error('invalid destination');
    }
    switch(textureTarget){
        case 3553:
        case 34067:
            device.gl.copyTexSubImage2D(textureTarget, destinationMipLevel, destinationX, destinationY, sourceX, sourceY, width, height);
            break;
        case 35866:
        case 32879:
            device.gl.copyTexSubImage3D(textureTarget, destinationMipLevel, destinationX, destinationY, destinationZ, sourceX, sourceY, width, height);
            break;
        default:
    }
    if (texture) {
        texture.unbind();
    }
    device.gl.bindFramebuffer(36160, prevHandle);
    if (destroyFramebuffer) {
        framebuffer.destroy();
    }
}
function getWebGLCubeFaceTarget(glTarget, dimension, level) {
    return dimension === 'cube' ? 34069 + level : glTarget;
}
/** Wrap a texture in a framebuffer so that we can use WebGL APIs that work on framebuffers */ function getFramebuffer(source) {
    if (source instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"]) {
        const { width, height, id } = source;
        const framebuffer = source.device.createFramebuffer({
            id: `framebuffer-for-${id}`,
            width,
            height,
            colorAttachments: [
                source
            ]
        });
        return {
            framebuffer,
            destroyFramebuffer: true
        };
    }
    return {
        framebuffer: source,
        destroyFramebuffer: false
    };
}
function glFormatToComponents(format) {
    switch(format){
        case 6406:
        case 33326:
        case 6403:
            return 1;
        case 33328:
        case 33319:
            return 2;
        case 6407:
        case 34837:
            return 3;
        case 6408:
        case 34836:
            return 4;
        // TODO: Add support for additional WebGL2 formats
        default:
            throw new Error('GLFormat');
    }
}
function glTypeToBytes(type) {
    switch(type){
        case 5121:
            return 1;
        case 33635:
        case 32819:
        case 32820:
            return 2;
        case 5126:
            return 4;
        // TODO: Add support for additional WebGL2 types
        default:
            throw new Error('GLType');
    }
} //# sourceMappingURL=webgl-command-buffer.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-command-encoder.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "WEBGLCommandEncoder": (()=>WEBGLCommandEncoder)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$command$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-command-buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$command$2d$encoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/resources/command-encoder.js [app-client] (ecmascript)");
;
;
class WEBGLCommandEncoder extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$command$2d$encoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CommandEncoder"] {
    device;
    commandBuffer;
    constructor(device, props){
        super(device, props);
        this.device = device;
        this.commandBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$command$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLCommandBuffer"](device);
    }
    destroy() {}
    finish() {
        this.commandBuffer.submitCommands();
    }
    // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;
    // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;
    // finish(options?: {id?: string}): GPUCommandBuffer;
    copyBufferToBuffer(options) {
        this.commandBuffer.commands.push({
            name: 'copy-buffer-to-buffer',
            options
        });
    }
    copyBufferToTexture(options) {
        this.commandBuffer.commands.push({
            name: 'copy-buffer-to-texture',
            options
        });
    }
    copyTextureToBuffer(options) {
        this.commandBuffer.commands.push({
            name: 'copy-texture-to-buffer',
            options
        });
    }
    copyTextureToTexture(options) {
        this.commandBuffer.commands.push({
            name: 'copy-texture-to-texture',
            options
        });
    }
    // clearTexture(options: ClearTextureOptions): void {
    //   this.commandBuffer.commands.push({name: 'copy-texture-to-texture', options});
    // }
    pushDebugGroup(groupLabel) {}
    popDebugGroup() {}
    insertDebugMarker(markerLabel) {}
    resolveQuerySet(querySet, destination, options) {}
} //# sourceMappingURL=webgl-command-encoder.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/webgl-device.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "WebGLDevice": (()=>WebGLDevice)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/utils/uid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/device.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$webgl$2d$canvas$2d$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/webgl-canvas-context.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$helpers$2f$create$2d$browser$2d$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/helpers/create-browser-context.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$debug$2f$spector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/debug/spector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$device$2d$helpers$2f$webgl$2d$device$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-info.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$device$2d$helpers$2f$webgl$2d$device$2d$limits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-limits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$device$2d$helpers$2f$webgl$2d$device$2d$features$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-features.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$state$2d$tracker$2f$webgl$2d$state$2d$tracker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/state-tracker/webgl-state-tracker.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$debug$2f$webgl$2d$developer$2d$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/debug/webgl-developer-tools.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-sampler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-shader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-framebuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$vertex$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-vertex-array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$transform$2d$feedback$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-transform-feedback.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$query$2d$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-query-set.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$render$2d$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-render-pipeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$render$2d$pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-render-pass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$command$2d$encoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-command-encoder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$webgl$2d$texture$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/helpers/webgl-texture-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$unified$2d$parameter$2d$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/parameters/unified-parameter-api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$state$2d$tracker$2f$with$2d$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/state-tracker/with-parameters.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$webgl$2d$texture$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/converters/webgl-texture-table.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$helpers$2f$webgl$2d$extensions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/helpers/webgl-extensions.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
class WebGLDevice extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Device"] {
    //
    // Public `Device` API
    //
    /** type of this device */ type = 'webgl';
    // Use the ! assertion to handle the case where _reuseDevices causes the constructor to return early
    /** The underlying WebGL context */ handle;
    features;
    limits;
    info;
    canvasContext;
    lost;
    _resolveContextLost;
    /** WebGL2 context. */ gl;
    debug = false;
    /** State used by luma.gl classes: TODO - move to canvasContext*/ _canvasSizeInfo = {
        clientWidth: 0,
        clientHeight: 0,
        devicePixelRatio: 1
    };
    /** State used by luma.gl classes - TODO - not used? */ _extensions = {};
    _polyfilled = false;
    /** Instance of Spector.js (if initialized) */ spectorJS;
    //
    // Public API
    //
    constructor(props){
        super({
            ...props,
            id: props.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$utils$2f$uid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])('webgl-device')
        });
        const canvasContextProps = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Device"]._getCanvasContextProps(props);
        // WebGL requires a canvas to be created before creating the context
        if (!canvasContextProps) {
            throw new Error('WebGLDevice requires props.createCanvasContext to be set');
        }
        // Check if the WebGL context is already associated with a device
        // Note that this can be avoided in webgl2adapter.create() if
        // DeviceProps._reuseDevices is set.
        // @ts-expect-error device is attached to context
        let device = canvasContextProps.canvas?.gl?.device;
        if (device) {
            throw new Error(`WebGL context already attached to device ${device.id}`);
        }
        // Create and instrument context
        this.canvasContext = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$webgl$2d$canvas$2d$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLCanvasContext"](this, canvasContextProps);
        this.lost = new Promise((resolve)=>{
            this._resolveContextLost = resolve;
        });
        const webglContextAttributes = {
            ...props.webgl
        };
        // Copy props from CanvasContextProps
        if (canvasContextProps.alphaMode === 'premultiplied') {
            webglContextAttributes.premultipliedAlpha = true;
        }
        if (props.powerPreference !== undefined) {
            webglContextAttributes.powerPreference = props.powerPreference;
        }
        // Check if we should attach to an externally created context or create a new context
        const externalGLContext = this.props._handle;
        const gl = externalGLContext || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$helpers$2f$create$2d$browser$2d$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createBrowserContext"])(this.canvasContext.canvas, {
            onContextLost: (event)=>this._resolveContextLost?.({
                    reason: 'destroyed',
                    message: 'Entered sleep mode, or too many apps or browser tabs are using the GPU.'
                }),
            // eslint-disable-next-line no-console
            onContextRestored: (event)=>console.log('WebGL context restored')
        }, webglContextAttributes);
        if (!gl) {
            throw new Error('WebGL context creation failed');
        }
        // Note that the browser will only create one WebGL context per canvas.
        // This means that a newly created gl context may already have a device attached to it.
        // @ts-expect-error luma.gl stores a device reference on the context.
        device = gl.device;
        if (device) {
            if (props._reuseDevices) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].log(1, `Not creating a new Device, instead returning a reference to Device ${device.id} already attached to WebGL context`, device)();
                device._reused = true;
                return device;
            }
            throw new Error(`WebGL context already attached to device ${device.id}`);
        }
        this.handle = gl;
        this.gl = gl;
        // Add spector debug instrumentation to context
        // We need to trust spector integration to decide if spector should be initialized
        // We also run spector instrumentation first, otherwise spector can clobber luma instrumentation.
        this.spectorJS = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$debug$2f$spector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initializeSpectorJS"])({
            ...this.props,
            gl: this.handle
        });
        // Instrument context
        this.gl.device = this; // Update GL context: Link webgl context back to device
        // TODO - remove, this is only used to detect debug contexts.
        this.gl._version = 2; // Update GL context: Store WebGL version field on gl context (HACK to identify debug contexts)
        // initialize luma Device fields
        this.info = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$device$2d$helpers$2f$webgl$2d$device$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDeviceInfo"])(this.gl, this._extensions);
        this.limits = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$device$2d$helpers$2f$webgl$2d$device$2d$limits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLDeviceLimits"](this.gl);
        this.features = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$device$2d$helpers$2f$webgl$2d$device$2d$features$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLDeviceFeatures"](this.gl, this._extensions, this.props._disabledFeatures);
        if (this.props._initializeFeatures) {
            this.features.initializeFeatures();
        }
        if (canvasContextProps.autoResize !== false) {
            this.canvasContext.resize();
        }
        // Install context state tracking
        const glState = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$state$2d$tracker$2f$webgl$2d$state$2d$tracker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLStateTracker"](this.gl, {
            log: (...args)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].log(1, ...args)()
        });
        glState.trackState(this.gl, {
            copyState: false
        });
        // DEBUG contexts: Add luma debug instrumentation to the context, force log level to at least 1
        const debugWebGL = props.debugWebGL || props.debug;
        const traceWebGL = props.debugWebGL;
        if (debugWebGL) {
            this.gl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$debug$2f$webgl$2d$developer$2d$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makeDebugContext"])(this.gl, {
                debugWebGL,
                traceWebGL
            });
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn('WebGL debug mode activated. Performance reduced.')();
            if (props.debugWebGL) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].level = Math.max(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].level, 1);
            }
        }
    }
    /**
     * Destroys the device
     *
     * @note "Detaches" from the WebGL context unless _reuseDevices is true.
     *
     * @note The underlying WebGL context is not immediately destroyed,
     * but may be destroyed later through normal JavaScript garbage collection.
     * This is a fundamental limitation since WebGL does not offer any
     * browser API for destroying WebGL contexts.
     */ destroy() {
        // Note that deck.gl (especially in React strict mode) depends on being able
        // to asynchronously create a Device against the same canvas (i.e. WebGL context)
        // multiple times and getting the same device back. Since deck.gl is not aware
        // of this sharing, it might call destroy() multiple times on the same device.
        // Therefore we must do nothing in destroy() if props._reuseDevices is true
        if (!this.props._reuseDevices && !this._reused) {
            // Delete the reference to the device that we store on the WebGL context
            delete this.gl.device;
        }
    }
    get isLost() {
        return this.gl.isContextLost();
    }
    // IMPLEMENTATION OF ABSTRACT DEVICE
    createCanvasContext(props) {
        throw new Error('WebGL only supports a single canvas');
    }
    createBuffer(props) {
        const newProps = this._normalizeBufferProps(props);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLBuffer"](this, newProps);
    }
    createTexture(props) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLTexture"](this, props);
    }
    createExternalTexture(props) {
        throw new Error('createExternalTexture() not implemented'); // return new Program(props);
    }
    createSampler(props) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLSampler"](this, props);
    }
    createShader(props) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLShader"](this, props);
    }
    createFramebuffer(props) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLFramebuffer"](this, props);
    }
    createVertexArray(props) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$vertex$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLVertexArray"](this, props);
    }
    createTransformFeedback(props) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$transform$2d$feedback$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLTransformFeedback"](this, props);
    }
    createQuerySet(props) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$query$2d$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLQuerySet"](this, props);
    }
    createRenderPipeline(props) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$render$2d$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLRenderPipeline"](this, props);
    }
    beginRenderPass(props) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$render$2d$pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLRenderPass"](this, props);
    }
    createComputePipeline(props) {
        throw new Error('ComputePipeline not supported in WebGL');
    }
    beginComputePass(props) {
        throw new Error('ComputePass not supported in WebGL');
    }
    renderPass = null;
    createCommandEncoder(props = {}) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$resources$2f$webgl$2d$command$2d$encoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WEBGLCommandEncoder"](this, props);
    }
    /**
     * Offscreen Canvas Support: Commit the frame
     * https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/commit
     * Chrome's offscreen canvas does not require gl.commit
     */ submit() {
        this.renderPass?.end();
        this.renderPass = null;
    // this.canvasContext.commit();
    }
    //
    // TEMPORARY HACKS - will be removed in v9.1
    //
    /** @deprecated - should use command encoder */ readPixelsToArrayWebGL(source, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$webgl$2d$texture$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readPixelsToArray"])(source, options);
    }
    /** @deprecated - should use command encoder */ readPixelsToBufferWebGL(source, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$helpers$2f$webgl$2d$texture$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readPixelsToBuffer"])(source, options);
    }
    setParametersWebGL(parameters) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$unified$2d$parameter$2d$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setGLParameters"])(this.gl, parameters);
    }
    getParametersWebGL(parameters) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$unified$2d$parameter$2d$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGLParameters"])(this.gl, parameters);
    }
    withParametersWebGL(parameters, func) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$state$2d$tracker$2f$with$2d$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withGLParameters"])(this.gl, parameters, func);
    }
    resetWebGL() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].warn('WebGLDevice.resetWebGL is deprecated, use only for debugging')();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$parameters$2f$unified$2d$parameter$2d$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resetGLParameters"])(this.gl);
    }
    _getDeviceSpecificTextureFormatCapabilities(capabilities) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$converters$2f$webgl$2d$texture$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTextureFormatCapabilitiesWebGL"])(this.gl, capabilities, this._extensions);
    }
    //
    // WebGL-only API (not part of `Device` API)
    //
    /**
     * Triggers device (or WebGL context) loss.
     * @note primarily intended for testing how application reacts to device loss
     */ loseDevice() {
        let deviceLossTriggered = false;
        const extensions = this.getExtension('WEBGL_lose_context');
        const ext = extensions.WEBGL_lose_context;
        if (ext) {
            deviceLossTriggered = true;
            ext.loseContext();
        // ext.loseContext should trigger context loss callback but the platform may not do this, so do it explicitly
        }
        this._resolveContextLost?.({
            reason: 'destroyed',
            message: 'Application triggered context loss'
        });
        return deviceLossTriggered;
    }
    /** Save current WebGL context state onto an internal stack */ pushState() {
        const webglState = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$state$2d$tracker$2f$webgl$2d$state$2d$tracker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLStateTracker"].get(this.gl);
        webglState.push();
    }
    /** Restores previously saved context state */ popState() {
        const webglState = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$state$2d$tracker$2f$webgl$2d$state$2d$tracker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLStateTracker"].get(this.gl);
        webglState.pop();
    }
    /**
     * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension
     * luma.gl ids and props can be inspected
     */ setSpectorMetadata(handle, props) {
        // @ts-expect-error
        // eslint-disable-next-line camelcase
        handle.__SPECTOR_Metadata = props;
    }
    /**
     * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant
     * Be aware that there are some duplicates especially for constants that are 0,
     * so this isn't guaranteed to return the right key in all cases.
     */ getGLKey(value, options) {
        const number = Number(value);
        for(const key in this.gl){
            // @ts-ignore expect-error depends on settings
            if (this.gl[key] === number) {
                return `GL.${key}`;
            }
        }
        // No constant found. Stringify the value and return it.
        return options?.emptyIfUnknown ? '' : String(value);
    }
    /**
     * Returns a map with any GL.<KEY> constants mapped to strings, both for keys and values
     */ getGLKeys(glParameters) {
        const opts = {
            emptyIfUnknown: true
        };
        return Object.entries(glParameters).reduce((keys, [key, value])=>{
            // eslint-disable-next-line @typescript-eslint/no-base-to-string
            keys[`${key}:${this.getGLKey(key, opts)}`] = `${value}:${this.getGLKey(value, opts)}`;
            return keys;
        }, {});
    }
    /** Store constants */ _constants;
    /**
     * Set a constant value for a location. Disabled attributes at that location will read from this value
     * @note WebGL constants are stored globally on the WebGL context, not the VertexArray
     * so they need to be updated before every render
     * @todo - remember/cache values to avoid setting them unnecessarily?
     */ setConstantAttributeWebGL(location, constant) {
        const maxVertexAttributes = this.limits.maxVertexAttributes;
        this._constants = this._constants || new Array(maxVertexAttributes).fill(null);
        const currentConstant = this._constants[location];
        if (currentConstant && compareConstantArrayValues(currentConstant, constant)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].info(1, `setConstantAttributeWebGL(${location}) could have been skipped, value unchanged`)();
        }
        this._constants[location] = constant;
        switch(constant.constructor){
            case Float32Array:
                setConstantFloatArray(this, location, constant);
                break;
            case Int32Array:
                setConstantIntArray(this, location, constant);
                break;
            case Uint32Array:
                setConstantUintArray(this, location, constant);
                break;
            default:
                throw new Error('constant');
        }
    }
    /** Ensure extensions are only requested once */ getExtension(name) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$helpers$2f$webgl$2d$extensions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWebGLExtension"])(this.gl, name, this._extensions);
        return this._extensions;
    }
}
/** Set constant float array attribute */ function setConstantFloatArray(device, location, array) {
    switch(array.length){
        case 1:
            device.gl.vertexAttrib1fv(location, array);
            break;
        case 2:
            device.gl.vertexAttrib2fv(location, array);
            break;
        case 3:
            device.gl.vertexAttrib3fv(location, array);
            break;
        case 4:
            device.gl.vertexAttrib4fv(location, array);
            break;
        default:
    }
}
/** Set constant signed int array attribute */ function setConstantIntArray(device, location, array) {
    device.gl.vertexAttribI4iv(location, array);
// TODO - not clear if we need to use the special forms, more testing needed
// switch (array.length) {
//   case 1:
//     gl.vertexAttribI1iv(location, array);
//     break;
//   case 2:
//     gl.vertexAttribI2iv(location, array);
//     break;
//   case 3:
//     gl.vertexAttribI3iv(location, array);
//     break;
//   case 4:
//     break;
//   default:
//     assert(false);
// }
}
/** Set constant unsigned int array attribute */ function setConstantUintArray(device, location, array) {
    device.gl.vertexAttribI4uiv(location, array);
// TODO - not clear if we need to use the special forms, more testing needed
// switch (array.length) {
//   case 1:
//     gl.vertexAttribI1uiv(location, array);
//     break;
//   case 2:
//     gl.vertexAttribI2uiv(location, array);
//     break;
//   case 3:
//     gl.vertexAttribI3uiv(location, array);
//     break;
//   case 4:
//     gl.vertexAttribI4uiv(location, array);
//     break;
//   default:
//     assert(false);
// }
}
/**
 * Compares contents of two typed arrays
 * @todo max length?
 */ function compareConstantArrayValues(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
        return false;
    }
    for(let i = 0; i < v1.length; ++i){
        if (v1[i] !== v2[i]) {
            return false;
        }
    }
    return true;
} //# sourceMappingURL=webgl-device.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/context/polyfills/polyfill-webgl1-extensions.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Goal is to make WebGL2 contexts look like WebGL1
// @note Partly inspired by with some older code from the `regl` library
/* eslint-disable camelcase */ __turbopack_esm__({
    "enforceWebGL2": (()=>enforceWebGL2),
    "polyfillWebGL1Extensions": (()=>polyfillWebGL1Extensions)
});
;
// webgl1 extensions natively supported by webgl2
const WEBGL1_STATIC_EXTENSIONS = {
    WEBGL_depth_texture: {
        UNSIGNED_INT_24_8_WEBGL: 34042
    },
    OES_element_index_uint: {},
    OES_texture_float: {},
    OES_texture_half_float: {
        // @ts-expect-error different numbers?
        HALF_FLOAT_OES: 5131
    },
    EXT_color_buffer_float: {},
    OES_standard_derivatives: {
        FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723
    },
    EXT_frag_depth: {},
    EXT_blend_minmax: {
        MIN_EXT: 32775,
        MAX_EXT: 32776
    },
    EXT_shader_texture_lod: {}
};
const getWEBGL_draw_buffers = (gl)=>({
        drawBuffersWEBGL (buffers) {
            return gl.drawBuffers(buffers);
        },
        COLOR_ATTACHMENT0_WEBGL: 36064,
        COLOR_ATTACHMENT1_WEBGL: 36065,
        COLOR_ATTACHMENT2_WEBGL: 36066,
        COLOR_ATTACHMENT3_WEBGL: 36067
    }); // - too many fields
const getOES_vertex_array_object = (gl)=>({
        VERTEX_ARRAY_BINDING_OES: 34229,
        createVertexArrayOES () {
            return gl.createVertexArray();
        },
        deleteVertexArrayOES (vertexArray) {
            return gl.deleteVertexArray(vertexArray);
        },
        isVertexArrayOES (vertexArray) {
            return gl.isVertexArray(vertexArray);
        },
        bindVertexArrayOES (vertexArray) {
            return gl.bindVertexArray(vertexArray);
        }
    });
const getANGLE_instanced_arrays = (gl)=>({
        VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 0x88fe,
        drawArraysInstancedANGLE (...args) {
            return gl.drawArraysInstanced(...args);
        },
        drawElementsInstancedANGLE (...args) {
            return gl.drawElementsInstanced(...args);
        },
        vertexAttribDivisorANGLE (...args) {
            return gl.vertexAttribDivisor(...args);
        }
    });
function enforceWebGL2(enforce = true) {
    const prototype = HTMLCanvasElement.prototype;
    if (!enforce && prototype.originalGetContext) {
        // Reset the original getContext function
        prototype.getContext = prototype.originalGetContext;
        prototype.originalGetContext = undefined;
        return;
    }
    // Store the original getContext function
    prototype.originalGetContext = prototype.getContext;
    // Override the getContext function
    prototype.getContext = function(contextId, options) {
        // Attempt to force WebGL2 for all WebGL1 contexts
        if (contextId === 'webgl' || contextId === 'experimental-webgl') {
            const context = this.originalGetContext('webgl2', options);
            // Work around test mocking
            if (context instanceof HTMLElement) {
                polyfillWebGL1Extensions(context);
            }
            return context;
        }
        // For any other type, return the original context
        return this.originalGetContext(contextId, options);
    };
}
function polyfillWebGL1Extensions(gl) {
    // Enable, to support float and half-float textures
    gl.getExtension('EXT_color_buffer_float');
    // WebGL1 extensions implemented using WebGL2 APIs
    const boundExtensions = {
        ...WEBGL1_STATIC_EXTENSIONS,
        WEBGL_disjoint_timer_query: gl.getExtension('EXT_disjoint_timer_query_webgl2'),
        WEBGL_draw_buffers: getWEBGL_draw_buffers(gl),
        OES_vertex_array_object: getOES_vertex_array_object(gl),
        ANGLE_instanced_arrays: getANGLE_instanced_arrays(gl)
    };
    // Override gl.getExtension
    // eslint-disable-next-line @typescript-eslint/unbound-method
    const originalGetExtension = gl.getExtension;
    gl.getExtension = function(extensionName) {
        const ext = originalGetExtension.call(gl, extensionName);
        if (ext) {
            return ext;
        }
        // Injected extensions
        if (extensionName in boundExtensions) {
            return boundExtensions[extensionName];
        }
        return null;
    };
    // Override gl.getSupportedExtensions
    // eslint-disable-next-line @typescript-eslint/unbound-method
    const originalGetSupportedExtensions = gl.getSupportedExtensions;
    gl.getSupportedExtensions = function() {
        const extensions = originalGetSupportedExtensions.apply(gl) || [];
        return extensions?.concat(Object.keys(boundExtensions));
    };
} // Update unsized WebGL1 formats to sized WebGL2 formats
 // todo move to texture format file
 // export function getInternalFormat(gl: WebGL2RenderingContext, format: GL, type: GL): GL {
 //   // webgl2 texture formats
 //   // https://webgl2fundamentals.org/webgl/lessons/webgl-data-textures.html
 //   switch (format) {
 //     case GL.DEPTH_COMPONENT:
 //       return GL.DEPTH_COMPONENT24;
 //     case GL.DEPTH_STENCIL:
 //       return GL.DEPTH24_STENCIL8;
 //     case GL.RGBA:
 //       return type === GL.HALF_FLOAT ? GL.RGBA16F : GL.RGBA32F;
 //     case GL.RGB:
 //       return type === GL.HALF_FLOAT ? GL.RGB16F : GL.RGB32F;
 //     default:
 //       return format;
 //   }
 // }
 /*
// texture type to update on the fly
export function getTextureType(gl: WebGL2RenderingContext, type: GL): GL {
  if (type === HALF_FLOAT_OES) {
    return GL.HALF_FLOAT;
  }
  return type;
}

  // And texImage2D to convert the internalFormat to webgl2.
  const webgl2 = this;
  const origTexImage = gl.texImage2D;
  gl.texImage2D = function (target, miplevel, iformat, a, typeFor6, c, d, typeFor9, f) {
    if (arguments.length == 6) {
      var ifmt = webgl2.getInternalFormat(gl, iformat, typeFor6);
      origTexImage.apply(gl, [target, miplevel, ifmt, a, webgl.getTextureType(gl, typeFor6), c]);
    } else {
      // arguments.length == 9
      var ifmt = webgl2.getInternalFormat(gl, iformat, typeFor9);
      origTexImage.apply(gl, [
        target,
        miplevel,
        ifmt,
        a,
        typeFor6,
        c,
        d,
        webgl2.getTextureType(gl, typeFor9),
        f
      ]);
    }
  };
};
*/  //# sourceMappingURL=polyfill-webgl1-extensions.js.map
}}),
"[project]/node_modules/@luma.gl/webgl/dist/adapter/webgl-adapter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_esm__({
    "WebGLAdapter": (()=>WebGLAdapter),
    "webgl2Adapter": (()=>webgl2Adapter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/device.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$debug$2f$spector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/debug/spector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$webgl$2d$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/adapter/webgl-device.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$polyfills$2f$polyfill$2d$webgl1$2d$extensions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/polyfills/polyfill-webgl1-extensions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/utils/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$debug$2f$webgl$2d$developer$2d$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/webgl/dist/context/debug/webgl-developer-tools.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$adapter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@luma.gl/core/dist/adapter/adapter.js [app-client] (ecmascript)");
;
;
;
;
;
const LOG_LEVEL = 1;
class WebGLAdapter extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$adapter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Adapter"] {
    /** type of device's created by this adapter */ type = 'webgl';
    constructor(){
        super();
        // Add spector default props to device default props, so that runtime settings are observed
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Device"].defaultProps = {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Device"].defaultProps,
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$debug$2f$spector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_SPECTOR_PROPS"]
        };
        // @ts-ignore DEPRECATED For backwards compatibility luma.registerDevices
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$webgl$2d$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLDevice"].adapter = this;
    }
    /** Check if WebGL 2 is available */ isSupported() {
        return typeof WebGL2RenderingContext !== 'undefined';
    }
    /** Force any created WebGL contexts to be WebGL2 contexts, polyfilled with WebGL1 extensions */ enforceWebGL2(enable) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$polyfills$2f$polyfill$2d$webgl1$2d$extensions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enforceWebGL2"])(enable);
    }
    /**
     * Get a device instance from a GL context
     * Creates a WebGLCanvasContext against the contexts canvas
     * @note autoResize will be disabled, assuming that whoever created the external context will be handling resizes.
     * @param gl
     * @returns
     */ async attach(gl) {
        if (gl instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$webgl$2d$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLDevice"]) {
            return gl;
        }
        // @ts-expect-error
        if (gl?.device instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Device"]) {
            // @ts-expect-error
            return gl.device;
        }
        if (!isWebGL(gl)) {
            throw new Error('Invalid WebGL2RenderingContext');
        }
        // We create a new device using the provided WebGL context and its canvas
        // Assume that whoever created the external context will be handling resizes.
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$webgl$2d$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLDevice"]({
            _handle: gl,
            createCanvasContext: {
                canvas: gl.canvas,
                autoResize: false
            }
        });
    }
    async create(props = {}) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].groupCollapsed(LOG_LEVEL, 'WebGLDevice created')();
        const promises = [];
        // Load webgl and spector debug scripts from CDN if requested
        if (props.debugWebGL || props.debug) {
            promises.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$debug$2f$webgl$2d$developer$2d$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["loadWebGLDeveloperTools"])());
        }
        if (props.debugSpectorJS) {
            promises.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$context$2f$debug$2f$spector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["loadSpectorJS"])(props));
        }
        // Wait for all the loads to settle before creating the context.
        // The Device.create() functions are async, so in contrast to the constructor, we can `await` here.
        const results = await Promise.allSettled(promises);
        for (const result of results){
            if (result.status === 'rejected') {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].error(`Failed to initialize debug libraries ${result.reason}`)();
            }
        }
        const device = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$webgl$2f$dist$2f$adapter$2f$webgl$2d$device$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLDevice"](props);
        // Log some debug info about the newly created context
        const message = `\
${device._reused ? 'Reusing' : 'Created'} device with WebGL2 ${device.debug ? 'debug ' : ''}context: \
${device.info.vendor}, ${device.info.renderer} for canvas: ${device.canvasContext.id}`;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].probe(LOG_LEVEL, message)();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].table(LOG_LEVEL, device.info)();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"].groupEnd(LOG_LEVEL)();
        return device;
    }
}
/** Check if supplied parameter is a WebGL2RenderingContext */ function isWebGL(gl) {
    if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
        return true;
    }
    // Look for debug contexts, headless gl etc
    return Boolean(gl && Number.isFinite(gl._version));
}
const webgl2Adapter = new WebGLAdapter(); //# sourceMappingURL=webgl-adapter.js.map
}}),
}]);

//# sourceMappingURL=node_modules_%40luma_gl_webgl_dist_1ff635._.js.map